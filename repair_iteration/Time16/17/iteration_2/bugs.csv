bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  instant.setMillis(parser.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(parser.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	21	None	replace
2	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	21	None	replace
3	[BUG]  [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  }  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  }	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	21	None	replace
4	[BUG]  [BUGGY]  if(iDefaultYear!=  null)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  }  [CE]  incomparable  types:  int  and  <null>  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(iDefaultYear!=  null)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(iDefaultYear!=  null)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  }	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  incomparable  types:  int  and  <null>	21	None	replace
5	[BUG]  [BUGGY]  InstantParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  InstantParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	InstantParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	21	None	replace
6	[BUG]  [BUGGY]  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	21	None	replace
7	[BUG]  [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  }  else  {  instant.set  [CE]  not  a  statement  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  }  else  {  instant.set  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  }  else  {  instant.set	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  not  a  statement	21	None	replace
8	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  instantLocal);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  instantLocal);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  instantLocal);  instant.setMillis(parser.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	21	None	replace
9	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocale(iLocale);    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	42	None	replace
10	[BUG]  [BUGGY]  instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocale(iLocale);    }    	non-compiled	[CE]  cannot  find  symbol	42	None	replace
11	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocale(iLocale);    }    	non-compiled	[CE]  cannot  find  symbol	42	None	replace
12	[BUG]  [BUGGY]  instant.setMillis(flush.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [CE]  cannot  find  symbol  flush  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(flush.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(flush.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocale(iLocale);    }    	non-compiled	[CE]  cannot  find  symbol  flush	42	None	replace
13	[BUG]  [BUGGY]  instant.setMillis(shape.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [CE]  cannot  find  symbol  shape  [FE]                              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(shape.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(shape.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocale(iLocale);    }    	non-compiled	[CE]  cannot  find  symbol  shape	42	None	replace
14	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [CE]  not  a  statement  [FE]                                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocale(iLocale);    }    	non-compiled	[CE]  not  a  statement	42	None	replace
15	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  position));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }  [CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  position));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text,  position));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocal(instantLocal    +    newPos);    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)	40	None	replace
16	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocal(instantLocal    +    newPos);    }    	non-compiled	[CE]  cannot  find  symbol	40	None	replace
17	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  position);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocal(instantLocal    +    newPos);    }    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	40	None	replace
18	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocal(instantLocal    +    newPos);    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	40	None	replace
19	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  newPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text,  newPos));	      instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)	7	None	replace
20	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  newPos));	      instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	7	None	replace
21	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text,  newPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text,  newPos));	      instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)	7	None	replace
22	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos,  text));  [CE]  no  suitable  method  found  for  computeMillis(boolean,int,String)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos,  text));	      instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int,String)	7	None	replace
23	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  false,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(boolean,boolean,int)  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  false,  newPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  false,  newPos));	      instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,boolean,int)	7	None	replace
24	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	26	None	replace
25	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	26	None	replace
26	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	26	None	replace
27	[BUG]  [BUGGY]  parser.parseInto(bucket,  position,  textPos);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  textPos  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  parser.parseInto(bucket,  position,  textPos);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	parser.parseInto(bucket,  position,  textPos);  instant.setMillis(bucket.computeMillis(false,  text));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol  textPos	26	None	replace
28	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	26	None	replace
29	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textLocal);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  textLocal  [FE]                              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textLocal);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  textLocal);  instant.setMillis(bucket.computeMillis(false,  text));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol  textLocal	26	None	replace
30	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	26	None	replace
31	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  message);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  message  [FE]                                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  message);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  message);  instant.setMillis(bucket.computeMillis(false,  text));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol  message	26	None	replace
32	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
33	[BUG]  [BUGGY]  InstantParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  InstantParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	InstantParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
34	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  instantLocal);  instant.setLocale(parser.getLocale());  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  instantLocal);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  instantLocal);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
35	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iLocale);  instant.setLocale(parser.getLocale());  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iLocale);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iLocale);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
36	[BUG]  [BUGGY]  instant.setLocale(iLocale.getLocale());  [CE]  cannot  find  symbol  [FE]                              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setLocale(iLocale.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setLocale(iLocale.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
37	[BUG]  [BUGGY]  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iLocale);  instant.setLocale(parser.getLocale());  [CE]  cannot  find  symbol  [FE]                                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iLocale);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iLocale);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
38	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  instantLocal,  newPos);  instant.setLocale(parser.getLocale());  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  instantLocal,  newPos);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  instantLocal,  newPos);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
39	[BUG]  [BUGGY]  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());  [CE]  cannot  find  symbol  [FE]                                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
40	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  text);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  text);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  text);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	24	None	replace
41	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textLocal);  [CE]  cannot  find  symbol  textLocal  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  textLocal);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  cannot  find  symbol  textLocal	24	None	replace
42	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  newPos);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  newPos);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	24	None	replace
43	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  iLocale);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  iLocale);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  iLocale);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	24	None	replace
44	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textLocation);  [CE]  cannot  find  symbol  textLocation  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textLocation);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  textLocation);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  cannot  find  symbol  textLocation	24	None	replace
45	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  instantLocal,  textPos,  position);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  instantLocal,  textPos,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  instantLocal,  textPos,  position);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	24	None	replace
46	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textEnd);  [CE]  cannot  find  symbol  textEnd  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textEnd);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  textEnd);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  cannot  find  symbol  textEnd	24	None	replace
47	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textOffset);  [CE]  cannot  find  symbol  textOffset  [FE]                              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textOffset);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  textOffset);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  cannot  find  symbol  textOffset	24	None	replace
48	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textText);  [CE]  cannot  find  symbol  textText  [FE]                                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textText);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  textText);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  cannot  find  symbol  textText	24	None	replace
49	[BUG]  [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	14	None	add
50	[BUG]  [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  if(iOffsetParsed  ||  bucket.getOffsetInteger()  ==  null)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  if(iOffsetParsed  ||  bucket.getOffsetInteger()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    if(iOffsetParsed  ||  bucket.getOffsetInteger()  ==  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	14	None	add
51	[BUG]  [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iParser.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iParser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  illegal  start  of  expression	14	None	add
52	[BUG]  [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iChrono.forOffsetMillis(parsedOffset);  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iChrono.forOffsetMillis(parsedOffset);  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iChrono.forOffsetMillis(parsedOffset);	  	non-compiled	[CE]  illegal  start  of  expression	14	None	add
53	[BUG]  [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  if(iOffsetParsed  ||  bucket.getOffsetInteger()  >=  null)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  if(iOffsetParsed  ||  bucket.getOffsetInteger()  >=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    if(iOffsetParsed  ||  bucket.getOffsetInteger()  >=  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	14	None	add
54	[BUG]  [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  new  DateTimeZone(instantLocal,  iPivotYear,  iDefaultYear);  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  new  DateTimeZone(instantLocal,  iPivotYear,  iDefaultYear);  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  new  DateTimeZone(instantLocal,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  illegal  start  of  expression	14	None	add
55	[BUG]  [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  If(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  [CE]  ';'  expected  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  If(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    If(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {	  	non-compiled	[CE]  ';'  expected	14	None	add
56	[BUG]  [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iChrono.computeMillis(false,  text));  [CE]  ';'  expected  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iChrono.computeMillis(false,  text));  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iChrono.computeMillis(false,  text));	  	non-compiled	[CE]  ';'  expected	14	None	add
57	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  instantLocal);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  instantLocal);	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
58	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  instantLocal,  newPos);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  instantLocal,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  instantLocal,  newPos);	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
59	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iLocale);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iLocale);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iLocale);	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
60	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  chrono);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  chrono);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  chrono);	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
61	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  chrono);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  chrono);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  chrono);	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
62	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos  +  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos  +  1);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos  +  1);	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
63	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  point);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  point);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  point);	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
64	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iDefaultYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iDefaultYear);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iDefaultYear);	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
65	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  index);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  index);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  index);	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
66	[BUG]  [BUGGY]  if(iOffsetParsed  ||  bucket.getOffset()!=  null)  {  [CE]  incomparable  types:  int  and  <null>  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  ||  bucket.getOffset()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  ||  bucket.getOffset()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffset()!=    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	32	None	replace
67	[BUG]  [BUGGY]  if(bucket.getOffset()!=  null  &&  bucket.getOffset()!=  null)  {  [CE]  incomparable  types:  int  and  <null>  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(bucket.getOffset()!=  null  &&  bucket.getOffset()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(bucket.getOffset()!=  null  &&  bucket.getOffset()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffset()!=    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	32	None	replace
68	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  bucket.getOffsetInteger()!=  null)  {  [CE]  incomparable  types:  int  and  <null>  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffset()!=    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	32	None	replace
69	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  bucket.getOffsetInteger()!=  0)  {  [CE]  incomparable  types:  int  and  <null>  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  bucket.getOffsetInteger()!=  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  bucket.getOffsetInteger()!=  0)  {	  if(iOffsetParsed    &&    bucket.getOffset()!=    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	32	None	replace
70	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetType()!=  null)  {  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetType()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffsetType()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffset()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	32	None	replace
71	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(false,  text));	      	non-compiled	[CE]  illegal  start  of  type	19	None	replace
72	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetInteger();	      	non-compiled	[CE]  illegal  start  of  type	19	None	replace
73	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));	      	non-compiled	[CE]  illegal  start  of  type	19	None	replace
74	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  newPos));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  newPos));  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  newPos));	      	non-compiled	[CE]  illegal  start  of  type	19	None	replace
75	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));	      	non-compiled	[CE]  illegal  start  of  type	19	None	replace
76	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      	non-compiled	[CE]  illegal  start  of  type	19	None	replace
77	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position);	      	non-compiled	[CE]  illegal  start  of  type	19	None	replace
78	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetMillis()  ==  null)  {  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetMillis()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if  (iOffsetParsed  &&  bucket.getOffsetMillis()  ==  null)  {	  if    (iOffsetParsed    &&    bucket.getOffsetMillis()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
79	[BUG]  [BUGGY]  if  (isOffsetParsed  &&  bucket.getOffsetMillis()!=  null)  {  [CE]  cannot  find  symbol  isOffsetParsed  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (isOffsetParsed  &&  bucket.getOffsetMillis()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if  (isOffsetParsed  &&  bucket.getOffsetMillis()!=  null)  {	  if    (iOffsetParsed    &&    bucket.getOffsetMillis()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  isOffsetParsed	13	None	replace
80	[BUG]  [BUGGY]  if  (iOffsetParsed  ||  bucket.getOffsetMillis()!=  null)  {  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  ||  bucket.getOffsetMillis()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if  (iOffsetParsed  ||  bucket.getOffsetMillis()!=  null)  {	  if    (iOffsetParsed    &&    bucket.getOffsetMillis()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
81	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  instant.getOffsetMillis()!=  null)  {  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  instant.getOffsetMillis()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if  (iOffsetParsed  &&  instant.getOffsetMillis()!=  null)  {	  if    (iOffsetParsed    &&    bucket.getOffsetMillis()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
82	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetMillis()  >=  null)  {  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetMillis()  >=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if  (iOffsetParsed  &&  bucket.getOffsetMillis()  >=  null)  {	  if    (iOffsetParsed    &&    bucket.getOffsetMillis()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
83	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setOffset(instantLocal);    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	37	None	replace
84	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setOffset(instantLocal);    }    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
85	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOff  [CE]  not  a  statement  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOff  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOff	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setOffset(instantLocal);    }    	non-compiled	[CE]  not  a  statement	37	None	replace
86	[BUG]  [BUGGY]  instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setOffset(instantLocal);    }    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
87	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }  [CE]  not  a  statement  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setOffset(instantLocal);    }    	non-compiled	[CE]  not  a  statement	37	None	replace
88	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
89	[BUG]  [BUGGY]  InstantParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  InstantParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	InstantParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  cannot  find  symbol	29	None	replace
90	[BUG]  [BUGGY]  int  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
91	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  newPos);  instant.setLocale(parser.getLocale());  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  newPos);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  newPos);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
92	[BUG]  [BUGGY]  parser  =  bucket.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  [CE]  cannot  find  symbol  [FE]                                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  parser  =  bucket.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	parser  =  bucket.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  cannot  find  symbol	29	None	replace
93	[BUG]  [BUGGY]  Integer  text  =  bucket.getText().intValue();  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Integer  text  =  bucket.getText().intValue();  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Integer  text  =  bucket.getText().intValue();	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
94	[BUG]  [BUGGY]  Integer  text  =  bucket.getText().length();  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Integer  text  =  bucket.getText().length();  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Integer  text  =  bucket.getText().length();	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
95	[BUG]  [BUGGY]  Integer  text  =  bucket.getText().substring(0,  newPos);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Integer  text  =  bucket.getText().substring(0,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Integer  text  =  bucket.getText().substring(0,  newPos);	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
96	[BUG]  [BUGGY]  Integer  text  =  bucket.getTextInt();  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Integer  text  =  bucket.getTextInt();  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Integer  text  =  bucket.getTextInt();	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
97	[BUG]  [BUGGY]  Integer  text  =  bucket.getText()  +  newPos;  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Integer  text  =  bucket.getText()  +  newPos;  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Integer  text  =  bucket.getText()  +  newPos;	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
98	[BUG]  [BUGGY]  Integer  text  =  bucket.getText().substring(newPos);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Integer  text  =  bucket.getText().substring(newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Integer  text  =  bucket.getText().substring(newPos);	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
99	[BUG]  [BUGGY]  Integer  text  =  bucket.getText(),  newPos);  [CE]  ';'  expected  [FE]                                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Integer  text  =  bucket.getText(),  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Integer  text  =  bucket.getText(),  newPos);	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  ';'  expected	12	None	replace
100	[BUG]  [BUGGY]  Integer  text  =  bucket.getTextBytes(newPos);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Integer  text  =  bucket.getTextBytes(newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Integer  text  =  bucket.getTextBytes(newPos);	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
101	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [CE]  incompatible  types  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant    =    bucket.getOffsetInteger();    }    	non-compiled	[CE]  incompatible  types	35	None	replace
102	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [CE]  no  suitable  method  found  for  computeMillis(int,int)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant    =    bucket.getOffsetInteger();    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,int)	35	None	replace
103	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant    =    bucket.getOffsetInteger();    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	35	None	replace
104	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [CE]  no  suitable  method  found  for  computeMillis(int,String)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant    =    bucket.getOffsetInteger();    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,String)	35	None	replace
105	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [CE]  not  a  statement  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant    =    bucket.getOffsetInteger();    }    	non-compiled	[CE]  not  a  statement	35	None	replace
106	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(newPos,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [CE]  no  suitable  method  found  for  computeMillis(int,String)  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(newPos,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(newPos,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant    =    bucket.getOffsetInteger();    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,String)	35	None	replace
107	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [CE]  not  a  statement  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant    =    bucket.getOffsetInteger();    }    	non-compiled	[CE]  not  a  statement	35	None	replace
108	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	30	None	add
109	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  if  (iOffsetParsed  &&  bucket.getOffsetInteger()!=  0)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  if  (iOffsetParsed  &&  bucket.getOffsetInteger()!=  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    if  (iOffsetParsed  &&  bucket.getOffsetInteger()!=  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	30	None	add
110	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iParser.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iParser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  illegal  start  of  expression	30	None	add
111	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iChrono.forOffsetMillis(parsedOffset);  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iChrono.forOffsetMillis(parsedOffset);  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iChrono.forOffsetMillis(parsedOffset);	  	non-compiled	[CE]  illegal  start  of  expression	30	None	add
112	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iChrono.computeMillis(false,  text));  [CE]  ';'  expected  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iChrono.computeMillis(false,  text));  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iChrono.computeMillis(false,  text));	  	non-compiled	[CE]  ';'  expected	30	None	add
113	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iChrono.computeMillis(false,  text);  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iChrono.computeMillis(false,  text);  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  iChrono.computeMillis(false,  text);	  	non-compiled	[CE]  illegal  start  of  expression	30	None	add
114	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  If  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  [CE]  ';'  expected  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  If  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    If  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {	  	non-compiled	[CE]  ';'  expected	30	None	add
115	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  >=  0)  {  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  >=  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  >=  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	30	None	add
116	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  textPos));  [CE]  cannot  find  symbol  textPos  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  textPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  textPos));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    textPos));    	non-compiled	[CE]  cannot  find  symbol  textPos	25	None	replace
117	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textPos);  instant.setMillis(bucket.computeMillis(false,  textPos));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textPos);  instant.setMillis(bucket.computeMillis(false,  textPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  textPos);  instant.setMillis(bucket.computeMillis(false,  textPos));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    textPos));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	25	None	replace
118	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  textPos));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  textPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  textPos));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    textPos));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	25	None	replace
119	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  textPos));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  textPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  textPos));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    textPos));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	25	None	replace
120	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textLocal);  instant.setMillis(bucket.computeMillis(false,  textPos));  [CE]  cannot  find  symbol  textLocal  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textLocal);  instant.setMillis(bucket.computeMillis(false,  textPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  textLocal);  instant.setMillis(bucket.computeMillis(false,  textPos));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    textPos));    	non-compiled	[CE]  cannot  find  symbol  textLocal	25	None	replace
121	[BUG]  [BUGGY]  parser.parseInto(bucket,  position,  textPos);  instant.setMillis(bucket.computeMillis(false,  textPos));  [CE]  cannot  find  symbol  textPos  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  parser.parseInto(bucket,  position,  textPos);  instant.setMillis(bucket.computeMillis(false,  textPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	parser.parseInto(bucket,  position,  textPos);  instant.setMillis(bucket.computeMillis(false,  textPos));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    textPos));    	non-compiled	[CE]  cannot  find  symbol  textPos	25	None	replace
122	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  textPos));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  textPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  textPos));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    textPos));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	25	None	replace
123	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  textPos));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  textPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  textPos));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    textPos));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	25	None	replace
124	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocale(instantLocal);    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	36	None	replace
125	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocale(instantLocal);    }    	non-compiled	[CE]  cannot  find  symbol	36	None	replace
126	[BUG]  [BUGGY]  instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocale(instantLocal);    }    	non-compiled	[CE]  cannot  find  symbol	36	None	replace
127	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLo  [CE]  ')'  expected  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLo  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLo	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocale(instantLocal);    }    	non-compiled	[CE]  ')'  expected	36	None	replace
128	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }  [CE]  not  a  statement  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocale(instantLocal);    }    	non-compiled	[CE]  not  a  statement	36	None	replace
129	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getChronology().getOffset(instantLocal);    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	10	None	replace
130	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getChronology().getOffset(instantLocal);    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
131	[BUG]  [BUGGY]  iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getChronology().getOffset(instantLocal);    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	10	None	replace
132	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  instant.setPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  instant.setPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  instant.setPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getChronology().getOffset(instantLocal);    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	10	None	replace
133	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]                              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getChronology().getOffset(instantLocal);    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	10	None	replace
134	[BUG]  [BUGGY]  instant.setMillis(computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [CE]  cannot  find  symbol  [FE]                                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getChronology().getOffset(instantLocal);    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
135	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iPivotYear  =  newPos  +  chrono.getChronology().getOffset(instantLocal);  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]                                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iPivotYear  =  newPos  +  chrono.getChronology().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  iPivotYear  =  newPos  +  chrono.getChronology().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getChronology().getOffset(instantLocal);    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	10	None	replace
136	[BUG]  [BUGGY]  timeout  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	add	int  textPos  =  iParser.parseInto(bucket,  text,  position);	      int    textPos    =    parser.parseInto(bucket,    text,    position);    	compilable	timeout	4	1	replace
137	[BUG]  [BUGGY]  int  textPos  =  iParser.parseInto(bucket,  text,  position);  timeout  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  iParser.parseInto(bucket,  text,  position);	      int    textPos    =    parser.parseInto(bucket,    text,    position);    	compilable	timeout	4	1	replace
138	[BUG]  [BUGGY]  timeout  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  position  -  1);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	add	int  textPos  =  parser.parseInto(bucket,  text,  position  -  1);	      int    textPos    =    parser.parseInto(bucket,    text,    position);    	compilable	timeout	4	1	replace
139	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  position  -  1);  timeout  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  position  -  1);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  text,  position  -  1);	      int    textPos    =    parser.parseInto(bucket,    text,    position);    	compilable	timeout	4	1	replace
140	[BUG]  [BUGGY]  timeout  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  position  +  1);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	add	int  textPos  =  parser.parseInto(bucket,  text,  position  +  1);	      int    textPos    =    parser.parseInto(bucket,    text,    position);    	compilable	timeout	4	1	replace
141	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  position  +  1);  timeout  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  position  +  1);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  text,  position  +  1);	      int    textPos    =    parser.parseInto(bucket,    text,    position);    	compilable	timeout	4	1	replace
142	[BUG]  [BUGGY]  timeout  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	add	int  textPos  =  parser.parseInto(bucket,  text,  newPos);	      int    textPos    =    parser.parseInto(bucket,    text,    position);    	compilable	timeout	4	1	replace
143	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  newPos);  timeout  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  text,  newPos);	      int    textPos    =    parser.parseInto(bucket,    text,    position);    	compilable	timeout	4	1	replace
144	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  instantLocal,  position);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  instantLocal,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  instantLocal,  position);	      int    textPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	4	None	replace
145	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  newPos,  text);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  newPos,  text);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  newPos,  text);	      int    textPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	4	None	replace
146	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  iLocale,  position);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  iLocale,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  iLocale,  position);	      int    textPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	4	None	replace
147	[BUG]  [BUGGY]  timeout  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  iDefaultYear);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	add	int  textPos  =  parser.parseInto(bucket,  text,  iDefaultYear);	      int    textPos    =    parser.parseInto(bucket,    text,    position);    	compilable	timeout	4	1	replace
148	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  iDefaultYear);  timeout  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  iDefaultYear);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  text,  iDefaultYear);	      int    textPos    =    parser.parseInto(bucket,    text,    position);    	compilable	timeout	4	1	replace
149	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  0)  {	  if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    	compilable	  [FE]  AssertionFailedError  	17	8	replace
150	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  0)  {	  if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    	compilable	  [FE]  AssertionFailedError  	17	8	replace
151	[BUG]  [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()  ==  null)  {  [timeout]  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  ||  bucket.getOffsetInteger()  ==  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    	non-compiled	[timeout]	17	None	replace
152	[BUG]  [BUGGY]  if(!iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  [timeout]  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(!iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(!iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    	non-compiled	[timeout]	17	None	replace
153	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetLocal()  ==  null)  {  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetLocal()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffsetLocal()  ==  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
154	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetMinute()  ==  null)  {  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetMinute()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffsetMinute()  ==  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
155	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(instantLocal!=  instantLocal  ||  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	if(instantLocal!=  instantLocal  ||  bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	15	12	replace
156	[BUG]  [BUGGY]  if(instantLocal!=  instantLocal  ||  bucket.getOffsetInteger()!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(instantLocal!=  instantLocal  ||  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(instantLocal!=  instantLocal  ||  bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	15	12	replace
157	[BUG]  [BUGGY]  if(instantLocal  ==  instantLocal  ||  bucket.getOffsetInteger()!=  null)  {  [timeout]  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(instantLocal  ==  instantLocal  ||  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(instantLocal  ==  instantLocal  ||  bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    	non-compiled	[timeout]	15	None	replace
158	[BUG]  [BUGGY]  if(newPos  >=  iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	15	None	replace
159	[BUG]  [BUGGY]  if(bucket.getOffsetParsed()!=  null  ||  bucket.getOffsetInteger()!=  null)  {  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(bucket.getOffsetParsed()!=  null  ||  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(bucket.getOffsetParsed()!=  null  ||  bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	15	None	replace
160	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0  &&  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	if(newPos  >=  0  &&  bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	15	12	replace
161	[BUG]  [BUGGY]  if(newPos  >=  0  &&  bucket.getOffsetInteger()!=  null)  {  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0  &&  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0  &&  bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	15	12	replace
162	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0  ||  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	if(newPos  >=  0  ||  bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    	compilable	  [FE]  NullPointerException  	15	13	replace
163	[BUG]  [BUGGY]  if(newPos  >=  0  ||  bucket.getOffsetInteger()!=  null)  {  [FE]  NullPointerException  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0  ||  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0  ||  bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    	compilable	  [FE]  NullPointerException  	15	13	replace
164	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser(newPos);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.getParser(newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.getParser(newPos);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
165	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser(),  newPos);  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.getParser(),  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.getParser(),  newPos);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  ';'  expected	20	None	replace
166	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.parse(text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.parse(text,  position);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
167	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instantLocal);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.getParser(instantLocal);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
168	[BUG]  [BUGGY]  DateTimeParser  parser  =  iChrono.getParser();  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iChrono.getParser();  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iChrono.getParser();	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
169	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parseDateTimeParser(newPos);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.parseDateTimeParser(newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.parseDateTimeParser(newPos);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
170	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(text,  newPos);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.parse(text,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.parse(text,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
171	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instantLocal,  newPos);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instantLocal,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.getParser(instantLocal,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
172	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  position));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }  [CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  position));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text,  position));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setOffset(instantLocal    +    newPos);    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)	34	None	replace
173	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setOffset(instantLocal    +    newPos);    }    	non-compiled	[CE]  cannot  find  symbol	34	None	replace
174	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  position);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setOffset(instantLocal    +    newPos);    }    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	34	None	replace
175	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setOffset(instantLocal    +    newPos);    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	34	None	replace
176	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	16	None	add
177	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	16	None	add
178	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  If(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  If(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    If(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {	  	non-compiled	[CE]  ';'  expected	16	None	add
179	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  if(iOffsetParsed  &&  bucket.getOffsetInteger()  >=  null)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  if(iOffsetParsed  &&  bucket.getOffsetInteger()  >=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    if(iOffsetParsed  &&  bucket.getOffsetInteger()  >=  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	16	None	add
180	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  if(iOffsetParsed  &&  bucket.getOffsetInteger()  [BUGGY]  null)  {  [CE]  ')'  expected  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  if(iOffsetParsed  &&  bucket.getOffsetInteger()  [BUGGY]  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    if(iOffsetParsed  &&  bucket.getOffsetInteger()  [BUGGY]  null)  {	  	non-compiled	[CE]  ')'  expected	16	None	add
181	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  if(iOffsetParsed  &&  bucket.getOffsetInteger()  >>  null)  {  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  if(iOffsetParsed  &&  bucket.getOffsetInteger()  >>  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    if(iOffsetParsed  &&  bucket.getOffsetInteger()  >>  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	16	None	add
182	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  null;  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  null;  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  null;	  	non-compiled	[CE]  illegal  start  of  expression	16	None	add
183	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);  [CE]  not  a  statement  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);	      instant.setMillis(bucket.computeMillis(false,    text));    iOffsetParsed    &&    bucket.getOffsetInteger()!=    null);    	non-compiled	[CE]  not  a  statement	6	None	replace
184	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);  [CE]  not  a  statement  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);	      instant.setMillis(bucket.computeMillis(false,    text));    iOffsetParsed    &&    bucket.getOffsetInteger()!=    null);    	non-compiled	[CE]  not  a  statement	6	None	replace
185	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);  [CE]  not  a  statement  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);	      instant.setMillis(bucket.computeMillis(false,    text));    iOffsetParsed    &&    bucket.getOffsetInteger()!=    null);    	non-compiled	[CE]  not  a  statement	6	None	replace
186	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(newPos,  text));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);  [CE]  not  a  statement  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(newPos,  text));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(newPos,  text));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);	      instant.setMillis(bucket.computeMillis(false,    text));    iOffsetParsed    &&    bucket.getOffsetInteger()!=    null);    	non-compiled	[CE]  not  a  statement	6	None	replace
187	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);  [CE]  not  a  statement  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  text));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);	      instant.setMillis(bucket.computeMillis(false,    text));    iOffsetParsed    &&    bucket.getOffsetInteger()!=    null);    	non-compiled	[CE]  not  a  statement	6	None	replace
188	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	5	None	replace
189	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
190	[BUG]  [BUGGY]  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	5	None	replace
191	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  instant.setPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  instant.setPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  instant.setPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	5	None	replace
192	[BUG]  [BUGGY]  instant.setMillis(iDefaultYear.computeMillis(false,  text));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [CE]  int  cannot  be  dereferenced  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(iDefaultYear.computeMillis(false,  text));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(iDefaultYear.computeMillis(false,  text));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  int  cannot  be  dereferenced	5	None	replace
193	[BUG]  [BUGGY]  instant.setMillis(computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(computeMillis(false,  newPos));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
194	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	5	None	replace
195	[BUG]  [BUGGY]  if(iOffsetParsed  ||  bucket.getOffset()  ==  null)  {  [CE]  incomparable  types:  int  and  <null>  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  ||  bucket.getOffset()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  ||  bucket.getOffset()  ==  null)  {	  if(iOffsetParsed    &&    bucket.getOffset()    ==    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	33	None	replace
196	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  newPos  ==  instant.getOffsetInteger())  {  [CE]  incomparable  types:  int  and  <null>  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  newPos  ==  instant.getOffsetInteger())  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  newPos  ==  instant.getOffsetInteger())  {	  if(iOffsetParsed    &&    bucket.getOffset()    ==    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	33	None	replace
197	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  newPos  >=  instant.getOffsetInteger())  {  [CE]  incomparable  types:  int  and  <null>  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  newPos  >=  instant.getOffsetInteger())  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  newPos  >=  instant.getOffsetInteger())  {	  if(iOffsetParsed    &&    bucket.getOffset()    ==    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	33	None	replace
198	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetNumber()  ==  null)  {  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetNumber()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffsetNumber()  ==  null)  {	  if(iOffsetParsed    &&    bucket.getOffset()    ==    null)    {    	non-compiled	[CE]  cannot  find  symbol	33	None	replace
199	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iOffsetParsed  &&  bucket.getZone()!=  null);  [CE]  not  a  statement  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iOffsetParsed  &&  bucket.getZone()!=  null);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  iOffsetParsed  &&  bucket.getZone()!=  null);	      instant.setMillis(bucket.computeMillis(false,    text));    iOffsetParsed    &&    bucket.getZone()!=    null);    	non-compiled	[CE]  not  a  statement	9	None	replace
200	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getZone()!=  null);  [CE]  not  a  statement  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getZone()!=  null);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getZone()!=  null);	      instant.setMillis(bucket.computeMillis(false,    text));    iOffsetParsed    &&    bucket.getZone()!=    null);    	non-compiled	[CE]  not  a  statement	9	None	replace
201	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(newPos,  text));  iOffsetParsed  &&  bucket.getZone()!=  null);  [CE]  not  a  statement  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(newPos,  text));  iOffsetParsed  &&  bucket.getZone()!=  null);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(newPos,  text));  iOffsetParsed  &&  bucket.getZone()!=  null);	      instant.setMillis(bucket.computeMillis(false,    text));    iOffsetParsed    &&    bucket.getZone()!=    null);    	non-compiled	[CE]  not  a  statement	9	None	replace
202	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos));  iOffsetParsed  &&  bucket.getZone()!=  null);  [CE]  not  a  statement  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos));  iOffsetParsed  &&  bucket.getZone()!=  null);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  newPos));  iOffsetParsed  &&  bucket.getZone()!=  null);	      instant.setMillis(bucket.computeMillis(false,    text));    iOffsetParsed    &&    bucket.getZone()!=    null);    	non-compiled	[CE]  not  a  statement	9	None	replace
203	[BUG]  [BUGGY]  iOffsetParsed  &&  bucket.getZone()!=  null);  [CE]  not  a  statement  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  iOffsetParsed  &&  bucket.getZone()!=  null);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	iOffsetParsed  &&  bucket.getZone()!=  null);	      instant.setMillis(bucket.computeMillis(false,    text));    iOffsetParsed    &&    bucket.getZone()!=    null);    	non-compiled	[CE]  not  a  statement	9	None	replace
204	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocal(instantLocal);    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	43	None	replace
205	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocal(instantLocal);    }    	non-compiled	[CE]  cannot  find  symbol	43	None	replace
206	[BUG]  [BUGGY]  instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocal(instantLocal);    }    	non-compiled	[CE]  cannot  find  symbol	43	None	replace
207	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }  [CE]  not  a  statement  [FE]                              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocal(instantLocal);    }    	non-compiled	[CE]  not  a  statement	43	None	replace
208	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }  [CE]  cannot  find  symbol  [FE]                                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocal(instantLocal);    }    	non-compiled	[CE]  cannot  find  symbol	43	None	replace
209	[BUG]  [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  parser.parseInto(bucket,  text,  position);  [CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        int    textPos    =    parser.parseInto(bucket,    text,    position);    int  textPos  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	add
210	[BUG]  [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  iParser.parseInto(bucket,  text,  position);  [CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        int    textPos    =    parser.parseInto(bucket,    text,    position);    int  textPos  =  iParser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	add
211	[BUG]  [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  iChrono.parseInto(bucket,  text,  position);  [CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  iChrono.parseInto(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        int    textPos    =    parser.parseInto(bucket,    text,    position);    int  textPos  =  iChrono.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	add
212	[BUG]  [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  parser.parseInto(bucket,  text,  iDefaultYear);  [CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  parser.parseInto(bucket,  text,  iDefaultYear);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        int    textPos    =    parser.parseInto(bucket,    text,    position);    int  textPos  =  parser.parseInto(bucket,  text,  iDefaultYear);	  	non-compiled	[CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	add
213	[BUG]  [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  Integer  textPos  =  parser.parseInto(bucket,  text,  position);  [CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  Integer  textPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        int    textPos    =    parser.parseInto(bucket,    text,    position);    Integer  textPos  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	add
214	[BUG]  [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  parser.parseInto(bucket,  text,  location);  [CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  parser.parseInto(bucket,  text,  location);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        int    textPos    =    parser.parseInto(bucket,    text,    position);    int  textPos  =  parser.parseInto(bucket,  text,  location);	  	non-compiled	[CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	add
215	[BUG]  [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  parser.parseInto(bucket,  text,  position  -  1);  [CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  parser.parseInto(bucket,  text,  position  -  1);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        int    textPos    =    parser.parseInto(bucket,    text,    position);    int  textPos  =  parser.parseInto(bucket,  text,  position  -  1);	  	non-compiled	[CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	add
216	[BUG]  [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  parser.parseInto(bucket,  text,  iLocale);  [CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  parser.parseInto(bucket,  text,  iLocale);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        int    textPos    =    parser.parseInto(bucket,    text,    position);    int  textPos  =  parser.parseInto(bucket,  text,  iLocale);	  	non-compiled	[CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	add
217	[BUG]  [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  Parser.parseInto(bucket,  text,  position);  [CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  Parser.parseInto(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        int    textPos    =    parser.parseInto(bucket,    text,    position);    int  textPos  =  Parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	add
218	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  newPos);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	iChrono  =  parser.parseInto(bucket,  text,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	23	None	replace
219	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	iChrono  =  parser.parseInto(bucket,  text,  position);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	23	None	replace
220	[BUG]  [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  newPos);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
221	[BUG]  [BUGGY]  Parser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  newPos);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Parser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Parser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
222	[BUG]  [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
223	[BUG]  [BUGGY]  int  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
224	[BUG]  [BUGGY]  iChrono  =  chrono.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  iChrono  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	iChrono  =  chrono.parseInto(bucket,  text,  position);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	23	None	replace
225	[BUG]  [BUGGY]  Parser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Parser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Parser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
226	[BUG]  [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  newPos,  text);  [CE]  cannot  find  symbol  [FE]                              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  newPos,  text);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  newPos,  text);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
227	[BUG]  [BUGGY]  if(newPos!=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos!=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos!=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
228	[BUG]  [BUGGY]  if(newPos  ==  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos  ==  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos  ==  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
229	[BUG]  [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
230	[BUG]  [BUGGY]  InstantParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  newPos));  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  InstantParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  newPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	InstantParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  newPos));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	22	None	replace
231	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  newPos));  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  newPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  newPos));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
232	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
233	[BUG]  [BUGGY]  if(newPos!=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }  else  {  instant.set  [CE]  not  a  statement  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos!=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }  else  {  instant.set  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos!=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }  else  {  instant.set	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  not  a  statement	22	None	replace
234	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(int,int)  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  newPos));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,int)	2	None	replace
235	[BUG]  [BUGGY]  instant.setPos(newPos);  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setPos(newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setPos(newPos);	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
236	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(newPos,  text));  [CE]  no  suitable  method  found  for  computeMillis(int,String)  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(newPos,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(newPos,  text));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,String)	2	None	replace
237	[BUG]  [BUGGY]  int  textLocal  =  chrono.getTextLocal(instantLocal,  newPos);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textLocal  =  chrono.getTextLocal(instantLocal,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textLocal  =  chrono.getTextLocal(instantLocal,  newPos);	      int    textLocal    =    iChrono.getTextLocal(instantLocal,    newPos);    	non-compiled	[CE]  cannot  find  symbol	41	None	replace
238	[BUG]  [BUGGY]  int  textLocal  =  newPos.getTextLocal(instantLocal,  iChrono);  [CE]  int  cannot  be  dereferenced  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textLocal  =  newPos.getTextLocal(instantLocal,  iChrono);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textLocal  =  newPos.getTextLocal(instantLocal,  iChrono);	      int    textLocal    =    iChrono.getTextLocal(instantLocal,    newPos);    	non-compiled	[CE]  int  cannot  be  dereferenced	41	None	replace
239	[BUG]  [BUGGY]  int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  position);  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  position);	      int    textLocal    =    iChrono.getTextLocal(instantLocal,    newPos);    	non-compiled	[CE]  cannot  find  symbol	41	None	replace
240	[BUG]  [BUGGY]  int  textLocal  =  instantLocal.getTextLocal(iChrono,  newPos);  [CE]  long  cannot  be  dereferenced  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textLocal  =  instantLocal.getTextLocal(iChrono,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textLocal  =  instantLocal.getTextLocal(iChrono,  newPos);	      int    textLocal    =    iChrono.getTextLocal(instantLocal,    newPos);    	non-compiled	[CE]  long  cannot  be  dereferenced	41	None	replace
241	[BUG]  [BUGGY]  int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  instantLocal);  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  instantLocal);	      int    textLocal    =    iChrono.getTextLocal(instantLocal,    newPos);    	non-compiled	[CE]  cannot  find  symbol	41	None	replace
242	[BUG]  [BUGGY]  int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  context);  [CE]  cannot  find  symbol  context  [FE]                              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  context);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  context);	      int    textLocal    =    iChrono.getTextLocal(instantLocal,    newPos);    	non-compiled	[CE]  cannot  find  symbol  context	41	None	replace
243	[BUG]  [BUGGY]  int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  timeZone);  [CE]  cannot  find  symbol  timeZone  [FE]                                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  timeZone);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  timeZone);	      int    textLocal    =    iChrono.getTextLocal(instantLocal,    newPos);    	non-compiled	[CE]  cannot  find  symbol  timeZone	41	None	replace
244	[BUG]  [BUGGY]  int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  iLocale);  [CE]  cannot  find  symbol  [FE]                                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  iLocale);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  iLocale);	      int    textLocal    =    iChrono.getTextLocal(instantLocal,    newPos);    	non-compiled	[CE]  cannot  find  symbol	41	None	replace
245	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iPivotYear  =  pivotYear;  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iPivotYear  =  pivotYear;  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  iPivotYear  =  pivotYear;	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear;    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	8	None	replace
246	[BUG]  [BUGGY]  iPivotYear  =  pivotYear;  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  iPivotYear  =  pivotYear;  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	iPivotYear  =  pivotYear;	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear;    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	8	None	replace
247	[BUG]  [BUGGY]  moment.setMillis(bucket.computeMillis(false,  newPos));  iPivotYear  =  pivotYear;  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  moment.setMillis(bucket.computeMillis(false,  newPos));  iPivotYear  =  pivotYear;  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	moment.setMillis(bucket.computeMillis(false,  newPos));  iPivotYear  =  pivotYear;	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear;    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	8	None	replace
248	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iPivotYear  =  newPos;  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iPivotYear  =  newPos;  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  iPivotYear  =  newPos;	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear;    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	8	None	replace
249	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos));  iPivotYear  =  pivotYear;  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos));  iPivotYear  =  pivotYear;  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  newPos));  iPivotYear  =  pivotYear;	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear;    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	8	None	replace
250	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	add	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
251	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
252	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	add	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
253	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
254	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  newPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  newPos));	  	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	1	None	add
255	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  Instant  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  Instant  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    Instant  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  ';'  expected	1	None	add
256	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(parser.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(parser.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	1	None	add
257	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  Text));  [CE]  cannot  find  symbol  Text  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  Text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  Text));	  	non-compiled	[CE]  cannot  find  symbol  Text	1	None	add
258	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  moment.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  moment  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  moment.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    moment.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  moment	1	None	add
259	[BUG]  [BUGGY]  if(bucket.getOffsetLocal()!=  null)  {  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(bucket.getOffsetLocal()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(bucket.getOffsetLocal()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetLocal()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	18	None	replace
260	[BUG]  [BUGGY]  if(instantLocal  &&  bucket.getOffsetLocal()!=  null)  {  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(instantLocal  &&  bucket.getOffsetLocal()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(instantLocal  &&  bucket.getOffsetLocal()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetLocal()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	18	None	replace
261	[BUG]  [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetLocal()!=  null)  {  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetLocal()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  ||  bucket.getOffsetLocal()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetLocal()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	18	None	replace
262	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetLocal()  >=  null)  {  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetLocal()  >=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffsetLocal()  >=  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetLocal()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	18	None	replace
263	[BUG]  [BUGGY]  if(newPos  &&  bucket.getOffsetLocal()!=  null)  {  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  &&  bucket.getOffsetLocal()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  &&  bucket.getOffsetLocal()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetLocal()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	18	None	replace
264	[BUG]  [BUGGY]  if(shape.getOffsetLocal()!=  null)  {  [CE]  cannot  find  symbol  shape  [FE]                        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(shape.getOffsetLocal()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(shape.getOffsetLocal()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetLocal()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  shape	18	None	replace
265	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetLocal()  >>  null)  {  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetLocal()  >>  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffsetLocal()  >>  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetLocal()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	18	None	replace
266	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetMillis()  ==  0)  {  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetMillis()  ==  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if  (iOffsetParsed  &&  bucket.getOffsetMillis()  ==  0)  {	  if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    	non-compiled	[CE]  cannot  find  symbol	31	None	replace
267	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  >  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	if  (iOffsetParsed  &&  bucket.getOffsetInteger()  >  0)  {	  if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    	compilable	  [FE]  AssertionFailedError  	31	8	replace
268	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  >  0)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  >  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if  (iOffsetParsed  &&  bucket.getOffsetInteger()  >  0)  {	  if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    	compilable	  [FE]  AssertionFailedError  	31	8	replace
269	[BUG]  [BUGGY]  if  (iOffsetParsed  ||  bucket.getOffsetInteger()  ==  0)  {  [timeout]  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  ||  bucket.getOffsetInteger()  ==  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if  (iOffsetParsed  ||  bucket.getOffsetInteger()  ==  0)  {	  if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    	non-compiled	[timeout]	31	None	replace
270	[BUG]  [BUGGY]  instant.setChronology(bucket.computeChronology(true,  newPos));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setChronology(bucket.computeChronology(true,  newPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setChronology(bucket.computeChronology(true,  newPos));	      instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  cannot  find  symbol	39	None	replace
271	[BUG]  [BUGGY]  instant.setTime(bucket.computeMillis(true,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setTime(bucket.computeMillis(true,  newPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setTime(bucket.computeMillis(true,  newPos));	      instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	39	None	replace
272	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos),  text);  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos),  text);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  newPos),  text);	      instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	39	None	replace
273	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	add	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	38	7	add
274	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	38	7	add
275	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	add	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	38	7	add
276	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	38	7	add
277	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  Instant  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  Instant  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    Instant  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  ';'  expected	38	None	add
278	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  moment.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  moment  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  moment.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    moment.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol  moment	38	None	add
279	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(True,  text));  [CE]  cannot  find  symbol  True  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(True,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(True,  text));	  	non-compiled	[CE]  cannot  find  symbol  True	38	None	add
280	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  minute.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  minute  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  minute.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    minute.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol  minute	38	None	add
281	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  Text));  [CE]  cannot  find  symbol  Text  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  Text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(true,  Text));	  	non-compiled	[CE]  cannot  find  symbol  Text	38	None	add
282	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iLocale  =  locale;  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  iLocale  =  locale;  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  iLocale  =  locale;	      instant.setMillis(bucket.computeMillis(false,    text));    iLocale    =    locale;    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	11	None	replace
283	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  instant.setLocale(locale);  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  instant.setLocale(locale);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  instant.setLocale(locale);	      instant.setMillis(bucket.computeMillis(false,    text));    iLocale    =    locale;    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	11	None	replace
284	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iLocale  =  locale;  [CE]  cannot  assign  a  value  to  final  variable  iLocale  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iLocale  =  locale;  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  iLocale  =  locale;	      instant.setMillis(bucket.computeMillis(false,    text));    iLocale    =    locale;    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iLocale	11	None	replace
285	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  locale  =  locale;  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  locale  =  locale;  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));  locale  =  locale;	      instant.setMillis(bucket.computeMillis(false,    text));    iLocale    =    locale;    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	11	None	replace
286	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  newPos,  text);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  newPos,  text);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  newPos,  text);  instant.setMillis(parser.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
287	[BUG]  [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }  else  {  instant.set  [CE]  not  a  statement  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }  else  {  instant.set  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }  else  {  instant.set	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  not  a  statement	22	None	replace
288	[BUG]  [BUGGY]  Integer  newPos  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  newPos));  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Integer  newPos  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  newPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Integer  newPos  =  iPrinter.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  newPos));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
289	[BUG]  [BUGGY]  InstantParser  parser  =  iPrinter.createChronology(bucket,  newPos,  text);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  InstantParser  parser  =  iPrinter.createChronology(bucket,  newPos,  text);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	InstantParser  parser  =  iPrinter.createChronology(bucket,  newPos,  text);  instant.setMillis(parser.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	22	None	replace
290	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textPos);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  textPos);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	24	None	replace
291	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  index,  textPos);  [CE]  cannot  find  symbol  index  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  index,  textPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  index,  textPos);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  cannot  find  symbol  index	24	None	replace
292	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  0,  textPos);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  0,  textPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  0,  textPos);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	24	None	replace
293	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  index,  textPos,  position);  [CE]  cannot  find  symbol  index  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  index,  textPos,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  index,  textPos,  position);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  cannot  find  symbol  index	24	None	replace
294	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  iLocale,  textPos,  position);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  iLocale,  textPos,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  iLocale,  textPos,  position);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	24	None	replace
295	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  horizontal,  textPos,  position);  [CE]  cannot  find  symbol  horizontal  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  horizontal,  textPos,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  horizontal,  textPos,  position);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  cannot  find  symbol  horizontal	24	None	replace
296	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  context,  textPos,  position);  [CE]  cannot  find  symbol  context  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  context,  textPos,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  context,  textPos,  position);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  cannot  find  symbol  context	24	None	replace
297	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textPos);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  position,  textPos);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  position,  textPos);  instant.setMillis(bucket.computeMillis(false,  text));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	26	None	replace
298	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  index,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  index  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  index,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  index,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol  index	26	None	replace
299	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  long  textPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	add	long  textPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	compilable	  [FE]  AssertionFailedError  	26	7	replace
300	[BUG]  [BUGGY]  long  textPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  long  textPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	long  textPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	compilable	  [FE]  AssertionFailedError  	26	7	replace
301	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  iOffsetParsed  &&  bucket.getZone()!=  null);  [CE]  not  a  statement  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  iOffsetParsed  &&  bucket.getZone()!=  null);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  text));  iOffsetParsed  &&  bucket.getZone()!=  null);	      instant.setMillis(bucket.computeMillis(false,    text));    iOffsetParsed    &&    bucket.getZone()!=    null);    	non-compiled	[CE]  not  a  statement	9	None	replace
302	[BUG]  [BUGGY]  if(newPos  >=  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	15	None	replace
303	[BUG]  [BUGGY]  if(newPos  >=  0  &&  bucket.getOffsetParsed()!=  null)  {  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0  &&  bucket.getOffsetParsed()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0  &&  bucket.getOffsetParsed()!=  null)  {	  if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	15	None	replace
304	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	if(bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	15	12	replace
305	[BUG]  [BUGGY]  if(bucket.getOffsetInteger()!=  null)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	15	12	replace
306	[BUG]  [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  }  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  }	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
307	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  newPos,  text);  instant.setLocale(parser.getLocale());  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  newPos,  text);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  newPos,  text);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
308	[BUG]  [BUGGY]  if(newPos!=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  }  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos!=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos!=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  }	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
309	[BUG]  [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  }  else  {  instant.setLocale(  [CE]  illegal  start  of  expression  [FE]                                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  }  else  {  instant.setLocale(  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  }  else  {  instant.setLocale(	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  illegal  start  of  expression	29	None	replace
310	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetMethod()!=  null)  {  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetMethod()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if  (iOffsetParsed  &&  bucket.getOffsetMethod()!=  null)  {	  if    (iOffsetParsed    &&    bucket.getOffsetMillis()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
311	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.isOffsetMillis()!=  null)  {  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.isOffsetMillis()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if  (iOffsetParsed  &&  bucket.isOffsetMillis()!=  null)  {	  if    (iOffsetParsed    &&    bucket.getOffsetMillis()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
312	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetPosition()!=  null)  {  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetPosition()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if  (iOffsetParsed  &&  bucket.getOffsetPosition()!=  null)  {	  if    (iOffsetParsed    &&    bucket.getOffsetMillis()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
313	[BUG]  [BUGGY]  if(newPos  >=  iOffsetParsed  &&  bucket.getOffset()!=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  iOffsetParsed  &&  bucket.getOffset()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  iOffsetParsed  &&  bucket.getOffset()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffset()!=    null)    {    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	32	None	replace
314	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetNumber()!=  null)  {  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetNumber()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffsetNumber()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffset()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	32	None	replace
315	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()  >=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()  >=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffset()  >=  null)  {	  if(iOffsetParsed    &&    bucket.getOffset()!=    null)    {    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	32	None	replace
316	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetType()!=  Token.NAME)  {  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetType()!=  Token.NAME)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffsetType()!=  Token.NAME)  {	  if(iOffsetParsed    &&    bucket.getOffset()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	32	None	replace
317	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [CE]  cannot  find  symbol  pivotYear  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  cannot  find  symbol  pivotYear	5	None	replace
318	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [CE]  no  suitable  method  found  for  computeMillis(int,String)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  text));  iPivotYear  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,String)	5	None	replace
319	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [CE]  cannot  find  symbol  pivotYear  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  pivotYear  +  chrono.getZone().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  cannot  find  symbol  pivotYear	5	None	replace
320	[BUG]  [BUGGY]  instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setOffset(instantLocal    +    newPos);    }    	non-compiled	[CE]  cannot  find  symbol	34	None	replace
321	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setOffset(instantLocal    +    newPos);    }    	non-compiled	[CE]  cannot  find  symbol	34	None	replace
322	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }  [CE]  no  suitable  method  found  for  computeMillis(int,String)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setOffset(instantLocal    +    newPos);    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,String)	34	None	replace
323	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setPos(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setPos(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setPos(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	1	None	add
324	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(FALSE,  text));  [CE]  cannot  find  symbol  FALSE  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(FALSE,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(FALSE,  text));	  	non-compiled	[CE]  cannot  find  symbol  FALSE	1	None	add
325	[BUG]  [BUGGY]  if(newPos  >=  iOffsetParsed  &&  bucket.getOffset()  ==  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  iOffsetParsed  &&  bucket.getOffset()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  iOffsetParsed  &&  bucket.getOffset()  ==  null)  {	  if(iOffsetParsed    &&    bucket.getOffset()    ==    null)    {    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	33	None	replace
326	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetType()  ==  Token.NAME)  {  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetType()  ==  Token.NAME)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffsetType()  ==  Token.NAME)  {	  if(iOffsetParsed    &&    bucket.getOffset()    ==    null)    {    	non-compiled	[CE]  cannot  find  symbol	33	None	replace
327	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iZone);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iZone);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iZone);	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
328	[BUG]  [BUGGY]  instant.setInteger(bucket.computeInteger(instantMillis,  newPos));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setInteger(bucket.computeInteger(instantMillis,  newPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setInteger(bucket.computeInteger(instantMillis,  newPos));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
329	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocale(instantLocal);    }    	non-compiled	[CE]  cannot  find  symbol	36	None	replace
330	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }  [CE]  no  suitable  method  found  for  computeMillis(int,String)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocale(instantLocal);    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,String)	36	None	replace
331	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iPivotYear  =  pivotYear;  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iPivotYear  =  pivotYear;  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  iPivotYear  =  pivotYear;	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear;    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	8	None	replace
332	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [CE]  no  suitable  method  found  for  computeMillis(int,String)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  text));  iPivotYear  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getChronology().getOffset(instantLocal);    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,String)	10	None	replace
333	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [CE]  cannot  find  symbol  pivotYear  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getChronology().getOffset(instantLocal);    	non-compiled	[CE]  cannot  find  symbol  pivotYear	10	None	replace
334	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocale(iLocale);    }    	non-compiled	[CE]  cannot  find  symbol	42	None	replace
335	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [CE]  no  suitable  method  found  for  computeMillis(int,String)  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocale(iLocale);    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,String)	42	None	replace
336	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  index,  textPos);  instant.setMillis(bucket.computeMillis(false,  textPos));  [CE]  cannot  find  symbol  index  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  index,  textPos);  instant.setMillis(bucket.computeMillis(false,  textPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  index,  textPos);  instant.setMillis(bucket.computeMillis(false,  textPos));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    textPos));    	non-compiled	[CE]  cannot  find  symbol  index	25	None	replace
337	[BUG]  [BUGGY]  long  textPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  textPos));  [CE]  no  suitable  method  found  for  computeMillis(boolean,long)  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  long  textPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  textPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	long  textPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  textPos));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    textPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,long)	25	None	replace
338	[BUG]  [BUGGY]  boolean  textPos  =  parser.parseInto(bucket,  position,  textPos);  instant.setMillis(bucket.computeMillis(false,  textPos));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  boolean  textPos  =  parser.parseInto(bucket,  position,  textPos);  instant.setMillis(bucket.computeMillis(false,  textPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	boolean  textPos  =  parser.parseInto(bucket,  position,  textPos);  instant.setMillis(bucket.computeMillis(false,  textPos));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    textPos));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	25	None	replace
339	[BUG]  [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  byser.parseInto(bucket,  text,  position);  [CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  byser.parseInto(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        int    textPos    =    parser.parseInto(bucket,    text,    position);    int  textPos  =  byser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	add
340	[BUG]  [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());  }  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());  }	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
341	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos  +  1);  instant.setLocale(parser.getLocale());  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos  +  1);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos  +  1);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
342	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  chrono);  instant.setLocale(parser.getLocale());  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  chrono);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  chrono);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
343	[BUG]  [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());  }  else  {  instant.set  [CE]  not  a  statement  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());  }  else  {  instant.set  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos  >=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());  }  else  {  instant.set	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  not  a  statement	27	None	replace
344	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setOffset(instantLocal);    }    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
345	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }  [CE]  no  suitable  method  found  for  computeMillis(int,String)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setOffset(instantLocal);    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,String)	37	None	replace
346	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  >=  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	if(iOffsetParsed  &&  bucket.getOffsetInteger()  >=  0)  {	  if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    	compilable	  [FE]  AssertionFailedError  	31	8	replace
347	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  >=  0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  >=  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffsetInteger()  >=  0)  {	  if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    	compilable	  [FE]  AssertionFailedError  	31	8	replace
348	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.getParser();	      	non-compiled	[CE]  illegal  start  of  type	19	None	replace
349	[BUG]  [BUGGY]  Integer  parsedOffset  =  bucket.getOffsetInteger();  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  Integer  parsedOffset  =  bucket.getOffsetInteger();  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	Integer  parsedOffset  =  bucket.getOffsetInteger();	      	non-compiled	[CE]  illegal  start  of  type	19	None	replace
350	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(true,  text));	      	non-compiled	[CE]  illegal  start  of  type	19	None	replace
351	[BUG]  [BUGGY]  Integer  parsedOffset  =  instant.getOffsetInteger();  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  Integer  parsedOffset  =  instant.getOffsetInteger();  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	Integer  parsedOffset  =  instant.getOffsetInteger();	      	non-compiled	[CE]  illegal  start  of  type	19	None	replace
352	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));	      	non-compiled	[CE]  illegal  start  of  type	19	None	replace
353	[BUG]  [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  if(iOffsetParsed  ||  bucket.getOffsetInteger()  >>  null)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  if(iOffsetParsed  ||  bucket.getOffsetInteger()  >>  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    if(iOffsetParsed  ||  bucket.getOffsetInteger()  >>  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	14	None	add
354	[BUG]  [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  int  iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  int  iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    int  iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {	  	non-compiled	[CE]  ';'  expected	14	None	add
355	[BUG]  [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  if(iOffsetParsed  ||  bucket.getOffsetInteger()  [BUGGY]  null)  {  [CE]  ')'  expected  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  if(iOffsetParsed  ||  bucket.getOffsetInteger()  [BUGGY]  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    if(iOffsetParsed  ||  bucket.getOffsetInteger()  [BUGGY]  null)  {	  	non-compiled	[CE]  ')'  expected	14	None	add
356	[BUG]  [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    int  parsedOffset  =  bucket.getOffsetInteger();	  	non-compiled	[CE]  illegal  start  of  expression	14	None	add
357	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos),  iLocale);  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos),  iLocale);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos),  iLocale);	      instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	7	None	replace
358	[BUG]  [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetIn  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetIn  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetIn	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant    =    bucket.getOffsetInteger();    }    	non-compiled	[CE]  ';'  expected	35	None	replace
359	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant    =    bucket.getOffsetInteger();    }    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
360	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant    =    bucket.getOffsetInteger();    }    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
361	[BUG]  [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOff  [CE]  ';'  expected  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOff  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOff	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant    =    bucket.getOffsetInteger();    }    	non-compiled	[CE]  ';'  expected	35	None	replace
362	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(false,  newPos));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetInteger();  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant    =    bucket.getOffsetInteger();    }    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
363	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    int  parsedOffset  =  bucket.getOffsetInteger();	  	non-compiled	[CE]  illegal  start  of  expression	30	None	add
364	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  [CE]  not  a  statement  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {	  	non-compiled	[CE]  not  a  statement	30	None	add
365	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  Integer  iOffsetParsed  =  bucket.getOffsetInteger();  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  Integer  iOffsetParsed  =  bucket.getOffsetInteger();  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    Integer  iOffsetParsed  =  bucket.getOffsetInteger();	  	non-compiled	[CE]  illegal  start  of  expression	30	None	add
366	[BUG]  [BUGGY]  Integer  text  =  bucket.getText().trim();  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Integer  text  =  bucket.getText().trim();  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Integer  text  =  bucket.getText().trim();	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
367	[BUG]  [BUGGY]  Integer  text  =  bucket.getText(newPos);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Integer  text  =  bucket.getText(newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Integer  text  =  bucket.getText(newPos);	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
368	[BUG]  [BUGGY]  Integer  text  =  iChrono.getText();  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Integer  text  =  iChrono.getText();  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Integer  text  =  iChrono.getText();	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
369	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(newPos,  text);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.parse(newPos,  text);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.parse(newPos,  text);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
370	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(newPos);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.parse(newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.parse(newPos);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
371	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parseInto(bucket,  newPos);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.parseInto(bucket,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.parseInto(bucket,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
372	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parseInto(bucket,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.parseInto(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.parseInto(bucket,  text,  position);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
373	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parseInstant(newPos);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.parseInstant(newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.parseInstant(newPos);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
374	[BUG]  [BUGGY]  if(newPos  >=  iOffsetParsed  &&  bucket.getOffsetLocal()!=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  iOffsetParsed  &&  bucket.getOffsetLocal()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  iOffsetParsed  &&  bucket.getOffsetLocal()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetLocal()!=    null)    {    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	18	None	replace
375	[BUG]  [BUGGY]  if(segment.getOffsetLocal()!=  null)  {  [CE]  cannot  find  symbol  segment  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(segment.getOffsetLocal()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(segment.getOffsetLocal()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetLocal()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  segment	18	None	replace
376	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  index,  text);  [CE]  cannot  find  symbol  index  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  index,  text);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  index,  text);	      int    textPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol  index	4	None	replace
377	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  position,  newPos);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  position,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  text,  position,  newPos);	      int    textPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	4	None	replace
378	[BUG]  [BUGGY]  instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(iLocale.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocal(instantLocal    +    newPos);    }    	non-compiled	[CE]  cannot  find  symbol	40	None	replace
379	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }  [CE]  no  suitable  method  found  for  computeMillis(int,String)  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocal(instantLocal    +    newPos);    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,String)	40	None	replace
380	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newPos);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocal(instantLocal    +    newPos);    }    	non-compiled	[CE]  cannot  find  symbol	40	None	replace
381	[BUG]  [BUGGY]  instant.setParser(bucket.computeParser(true,  newPos));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setParser(bucket.computeParser(true,  newPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setParser(bucket.computeParser(true,  newPos));	      instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  cannot  find  symbol	39	None	replace
382	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  0));  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  0));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  0));	      instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	39	None	replace
383	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text),  newPos);  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text),  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text),  newPos);	      instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	39	None	replace
384	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  newPos);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
385	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
386	[BUG]  [BUGGY]  parser  =  iParser.parseInto(bucket,  text,  position);  [CE]  incompatible  types  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  parser  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	parser  =  iParser.parseInto(bucket,  text,  position);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  incompatible  types	23	None	replace
387	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  Instant  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  Instant  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    Instant  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  ';'  expected	38	None	add
388	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  int  iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  int  iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    int  iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {	  	non-compiled	[CE]  ';'  expected	16	None	add
389	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  for(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  [CE]  not  a  statement  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  for(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    for(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {	  	non-compiled	[CE]  not  a  statement	16	None	add
390	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetMinutes()  ==  null)  {  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetMinutes()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffsetMinutes()  ==  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
391	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetTime()!=  null)  {  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetTime()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffsetTime()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
392	[BUG]  [BUGGY]  int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos  +  1);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos  +  1);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos  +  1);	      int    textLocal    =    iChrono.getTextLocal(instantLocal,    newPos);    	non-compiled	[CE]  cannot  find  symbol	41	None	replace
393	[BUG]  [BUGGY]  int  textLocal  =  this.iChrono.getTextLocal(instantLocal,  newPos);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textLocal  =  this.iChrono.getTextLocal(instantLocal,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textLocal  =  this.iChrono.getTextLocal(instantLocal,  newPos);	      int    textLocal    =    iChrono.getTextLocal(instantLocal,    newPos);    	non-compiled	[CE]  cannot  find  symbol	41	None	replace
394	[BUG]  [BUGGY]  int  textLocal  =  iChrono.getTextLocal(instantLocal,  position);  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textLocal  =  iChrono.getTextLocal(instantLocal,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textLocal  =  iChrono.getTextLocal(instantLocal,  position);	      int    textLocal    =    iChrono.getTextLocal(instantLocal,    newPos);    	non-compiled	[CE]  cannot  find  symbol	41	None	replace
395	[BUG]  [BUGGY]  int  textLocal  =  chrono.getTextLocal(iChrono,  newPos);  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textLocal  =  chrono.getTextLocal(iChrono,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textLocal  =  chrono.getTextLocal(iChrono,  newPos);	      int    textLocal    =    iChrono.getTextLocal(instantLocal,    newPos);    	non-compiled	[CE]  cannot  find  symbol	41	None	replace
396	[BUG]  [BUGGY]  if(newPos!=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  }  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos!=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos!=  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  }	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	21	None	replace
397	[BUG]  [BUGGY]  if(newPos  <  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  }  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos  <  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos  <  0)  {  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  }	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	21	None	replace
398	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iLocale);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iLocale);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iLocale);  instant.setMillis(parser.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	21	None	replace
399	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos  +  1);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos  +  1);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos  +  1);  instant.setMillis(parser.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	21	None	replace
400	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocal(instantLocal);    }    	non-compiled	[CE]  cannot  find  symbol	43	None	replace
401	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }  [CE]  no  suitable  method  found  for  computeMillis(int,String)  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocal(instantLocal);    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,String)	43	None	replace
402	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  chrono.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  chrono.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	21	None	replace
403	[BUG]  [BUGGY]  InstantParser  parser  =  chrono.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  InstantParser  parser  =  chrono.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	InstantParser  parser  =  chrono.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	21	None	replace
404	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.createChronology(bucket,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  chrono.createChronology(bucket,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  chrono.createChronology(bucket,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	21	None	replace
405	[BUG]  [BUGGY]  parser  =  chrono.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  parser  =  chrono.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	parser  =  chrono.createChronology(bucket,  text,  position,  newPos);  instant.setMillis(parser.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	21	None	replace
406	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  chrono);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  chrono);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  chrono);  instant.setMillis(parser.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	21	None	replace
407	[BUG]  [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  if(iOffsetParsed  ||  bucket.getOffsetInteger()  [Delete]  null)  {  [CE]  ')'  expected  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  ||  bucket.getOffsetInteger()!=  null)  {  if(iOffsetParsed  ||  bucket.getOffsetInteger()  [Delete]  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    if(iOffsetParsed  ||  bucket.getOffsetInteger()  [Delete]  null)  {	  	non-compiled	[CE]  ')'  expected	14	None	add
408	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  chrono.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  chrono.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
409	[BUG]  [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  printer.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  printer.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos  >=  0)  {  DateTimeParser  parser  =  printer.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  }	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
410	[BUG]  [BUGGY]  InstantParser  parser  =  chrono.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  InstantParser  parser  =  chrono.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	InstantParser  parser  =  chrono.createChronology(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setMillis(parser.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	22	None	replace
411	[BUG]  [BUGGY]  Parser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Parser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Parser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
412	[BUG]  [BUGGY]  Node  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Node  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Node  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
413	[BUG]  [BUGGY]  instant.setMillis(instantLocal.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }  [CE]  long  cannot  be  dereferenced  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instantLocal.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instantLocal.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newPos);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setOffset(instantLocal    +    newPos);    }    	non-compiled	[CE]  long  cannot  be  dereferenced	34	None	replace
414	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newP  [CE]  ')'  expected  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newP  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal  +  newP	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setOffset(instantLocal    +    newPos);    }    	non-compiled	[CE]  ')'  expected	34	None	replace
415	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      	non-compiled	[CE]  illegal  start  of  type	19	None	replace
416	[BUG]  [BUGGY]  int  newPos  =  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  newPos  =  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  newPos  =  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      	non-compiled	[CE]  illegal  start  of  type	19	None	replace
417	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));	      	non-compiled	[CE]  illegal  start  of  type	19	None	replace
418	[BUG]  [BUGGY]  int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  iDefaultYear);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  iDefaultYear);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textLocal  =  iChrono.getTextLocal(instantLocal,  newPos,  iDefaultYear);	      int    textLocal    =    iChrono.getTextLocal(instantLocal,    newPos);    	non-compiled	[CE]  cannot  find  symbol	41	None	replace
419	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  iOffsetParsed  &&  bucket.getZone()!=  null);  [CE]  no  suitable  method  found  for  setMillis(long,boolean)  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  iOffsetParsed  &&  bucket.getZone()!=  null);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  iOffsetParsed  &&  bucket.getZone()!=  null);	      instant.setMillis(bucket.computeMillis(false,    text));    iOffsetParsed    &&    bucket.getZone()!=    null);    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,boolean)	9	None	replace
420	[BUG]  [BUGGY]  instant.setPos(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setPos(bucket.computeMillis(true,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setPos(bucket.computeMillis(true,  text));	      instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  cannot  find  symbol	39	None	replace
421	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instantLocal,  text);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instantLocal,  text);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.getParser(instantLocal,  text);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
422	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parseInstant(text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.parseInstant(text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.parseInstant(text,  position);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
423	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(text,  position,  newPos);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  bucket.parse(text,  position,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  bucket.parse(text,  position,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
424	[BUG]  [BUGGY]  Integer  text  =  bucket.getText().substring(position  +  newPos);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Integer  text  =  bucket.getText().substring(position  +  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Integer  text  =  bucket.getText().substring(position  +  newPos);	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
425	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()  ==  null  ||  bucket.getOffsetInteger()  ==  null)  {  [CE]  incomparable  types:  int  and  <null>  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()  ==  null  ||  bucket.getOffsetInteger()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffset()  ==  null  ||  bucket.getOffsetInteger()  ==  null)  {	  if(iOffsetParsed    &&    bucket.getOffset()    ==    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	33	None	replace
426	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()  ==  null  &&  bucket.getOffsetInteger()  ==  null)  {  [CE]  incomparable  types:  int  and  <null>  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()  ==  null  &&  bucket.getOffsetInteger()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffset()  ==  null  &&  bucket.getOffsetInteger()  ==  null)  {	  if(iOffsetParsed    &&    bucket.getOffset()    ==    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	33	None	replace
427	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()  ==  null  &&  bucket.getOffsetInteger()  >  0)  {  [CE]  incomparable  types:  int  and  <null>  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()  ==  null  &&  bucket.getOffsetInteger()  >  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffset()  ==  null  &&  bucket.getOffsetInteger()  >  0)  {	  if(iOffsetParsed    &&    bucket.getOffset()    ==    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	33	None	replace
428	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()  ==  null  &&  bucket.getOffsetInteger()!=  null)  {  [CE]  incomparable  types:  int  and  <null>  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()  ==  null  &&  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffset()  ==  null  &&  bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffset()    ==    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	33	None	replace
429	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()  ==  null  &&  bucket.getOffsetInteger()  <  newPos)  {  [CE]  incomparable  types:  int  and  <null>  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()  ==  null  &&  bucket.getOffsetInteger()  <  newPos)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffset()  ==  null  &&  bucket.getOffsetInteger()  <  newPos)  {	  if(iOffsetParsed    &&    bucket.getOffset()    ==    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	33	None	replace
430	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setPos(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setPos(bucket.computeMillis(true,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setPos(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol	1	None	add
431	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setPos(bucket.computePosition(newPos));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setPos(bucket.computePosition(newPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setPos(bucket.computePosition(newPos));	  	non-compiled	[CE]  cannot  find  symbol	1	None	add
432	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setPos(bucket.computePos(0,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setPos(bucket.computePos(0,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setPos(bucket.computePos(0,  text));	  	non-compiled	[CE]  cannot  find  symbol	1	None	add
433	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text),  position);  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text),  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  text),  position);	  	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	1	None	add
434	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  chrono.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  chrono.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
435	[BUG]  [BUGGY]  DateTimeParser  parser  =  instant.getParser();  instant.setLocale(parser.getLocale());  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  instant.getParser();  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  instant.getParser();  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
436	[BUG]  [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  printer.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  }  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos  >=  0)  {  DateTimeParser  parser  =  printer.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos  >=  0)  {  DateTimeParser  parser  =  printer.createChronology(bucket,  text,  position);  instant.setLocale(parser.getLocale());  }	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
437	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(chrono,  text,  position);  instant.setLocale(parser.getLocale());  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(chrono,  text,  position);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(chrono,  text,  position);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
438	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  index,  text,  position);  [CE]  cannot  find  symbol  index  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  index,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  index,  text,  position);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  cannot  find  symbol  index	24	None	replace
439	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  iLocale,  text,  position);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  iLocale,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  iLocale,  text,  position);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	24	None	replace
440	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  text,  position,  iLocale);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	24	None	replace
441	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  start,  position);  [CE]  cannot  find  symbol  start  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  start,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  start,  position);	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    	non-compiled	[CE]  cannot  find  symbol  start	24	None	replace
442	[BUG]  [BUGGY]  instant.setInteger(bucket.computeInteger(instantLocal,  newPos));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setInteger(bucket.computeInteger(instantLocal,  newPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setInteger(bucket.computeInteger(instantLocal,  newPos));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
443	[BUG]  [BUGGY]  instant.setPos(bucket.computePosition(instantMillis,  newPos));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setPos(bucket.computePosition(instantMillis,  newPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setPos(bucket.computePosition(instantMillis,  newPos));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
444	[BUG]  [BUGGY]  instant.setInteger(bucket.computeInteger(instantLocal),  newPos);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setInteger(bucket.computeInteger(instantLocal),  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setInteger(bucket.computeInteger(instantLocal),  newPos);	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
445	[BUG]  [BUGGY]  if(offsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  [CE]  cannot  find  symbol  offsetParsed  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(offsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(offsetParsed  &&  bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  offsetParsed	15	None	replace
446	[BUG]  [BUGGY]  if(isOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  [CE]  cannot  find  symbol  isOffsetParsed  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(isOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(isOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  isOffsetParsed	15	None	replace
447	[BUG]  [BUGGY]  if(bucket.getOffset()!=  null  ||  bucket.getOffsetInteger()!=  null)  {  [CE]  incomparable  types:  int  and  <null>  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(bucket.getOffset()!=  null  ||  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(bucket.getOffset()!=  null  ||  bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    ||    bucket.getOffsetInteger()!=    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	15	None	replace
448	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);	      int    textPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	4	None	replace
449	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  iLocale);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  text,  iLocale);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  text,  iLocale);	      int    textPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	4	None	replace
450	[BUG]  [BUGGY]  instant  =  bucket.getOffsetInteger();  [CE]  incompatible  types  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant  =  bucket.getOffsetInteger();  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant  =  bucket.getOffsetInteger();	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant    =    bucket.getOffsetInteger();    }    	non-compiled	[CE]  incompatible  types	35	None	replace
451	[BUG]  [BUGGY]  if(newPos!=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetIn  [CE]  ';'  expected  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos!=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetIn  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos!=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetIn	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant    =    bucket.getOffsetInteger();    }    	non-compiled	[CE]  ';'  expected	35	None	replace
452	[BUG]  [BUGGY]  if(newPos  >=  text.length())  {  instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetIn  [CE]  ';'  expected  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos  >=  text.length())  {  instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetIn  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos  >=  text.length())  {  instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOffsetIn	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant    =    bucket.getOffsetInteger();    }    	non-compiled	[CE]  ';'  expected	35	None	replace
453	[BUG]  [BUGGY]  if(newPos  >=  text.length())  {  instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOff  [CE]  ';'  expected  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos  >=  text.length())  {  instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOff  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos  >=  text.length())  {  instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant  =  bucket.getOff	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant    =    bucket.getOffsetInteger();    }    	non-compiled	[CE]  ';'  expected	35	None	replace
454	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newP  [CE]  ')'  expected  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newP  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newP	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocal(instantLocal    +    newPos);    }    	non-compiled	[CE]  ')'  expected	40	None	replace
455	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newP  [CE]  ')'  expected  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newP  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text));  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal  +  newP	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocal(instantLocal    +    newPos);    }    	non-compiled	[CE]  ')'  expected	40	None	replace
456	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  newPos);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  newPos);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  newPos);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocal(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocal(instantLocal);    }    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	43	None	replace
457	[BUG]  [BUGGY]  if(iOffsetParsed  &&  instant.getOffsetLocal()!=  null)  {  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  instant.getOffsetLocal()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  instant.getOffsetLocal()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetLocal()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	18	None	replace
458	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.isOffset()!=  null)  {  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.isOffset()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.isOffset()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetLocal()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	18	None	replace
459	[BUG]  [BUGGY]  if(offsetParsed  &&  bucket.getOffsetLocal()!=  null)  {  [CE]  cannot  find  symbol  offsetParsed  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(offsetParsed  &&  bucket.getOffsetLocal()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(offsetParsed  &&  bucket.getOffsetLocal()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetLocal()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  offsetParsed	18	None	replace
460	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()  ==  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	if(iOffsetParsed  &&  bucket.getOffset()  ==  0)  {	  if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    	compilable	  [FE]  AssertionFailedError  	31	8	replace
461	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()  ==  0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()  ==  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffset()  ==  0)  {	  if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    	compilable	  [FE]  AssertionFailedError  	31	8	replace
462	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  if(iOffsetParsed  &&  bucket.getOffsetInteger()  {  null)  {  [CE]  ')'  expected  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  if(iOffsetParsed  &&  bucket.getOffsetInteger()  {  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    if(iOffsetParsed  &&  bucket.getOffsetInteger()  {  null)  {	  	non-compiled	[CE]  ')'  expected	16	None	add
463	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  if(iOffsetParsed)&&  bucket.getOffsetInteger()  ==  null)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()  ==  null)  {  if(iOffsetParsed)&&  bucket.getOffsetInteger()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    if(iOffsetParsed)&&  bucket.getOffsetInteger()  ==  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	16	None	add
464	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  {  0)  {  [CE]  ')'  expected  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  ==  0)  {  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  {  0)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if    (iOffsetParsed    &&    bucket.getOffsetInteger()    ==    0)    {    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  {  0)  {	  	non-compiled	[CE]  ')'  expected	30	None	add
465	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  start,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  start  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  start,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  start,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol  start	26	None	replace
466	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  context,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  context  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  context,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  context,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol  context	26	None	replace
467	[BUG]  [BUGGY]  if(textPos!=  position)  {  int  textPos  =  parser.parseInto(bucket,  textPos,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  textPos  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(textPos!=  position)  {  int  textPos  =  parser.parseInto(bucket,  textPos,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(textPos!=  position)  {  int  textPos  =  parser.parseInto(bucket,  textPos,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol  textPos	26	None	replace
468	[BUG]  [BUGGY]  if(textPos  >=  position)  {  int  textPos  =  parser.parseInto(bucket,  textPos,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  textPos  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(textPos  >=  position)  {  int  textPos  =  parser.parseInto(bucket,  textPos,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(textPos  >=  position)  {  int  textPos  =  parser.parseInto(bucket,  textPos,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol  textPos	26	None	replace
469	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(null,  text));  [CE]  no  suitable  method  found  for  computeMillis(<null>,String)  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(null,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(null,  text));	  	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(<null>,String)	38	None	add
470	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setPos(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setPos(bucket.computeMillis(true,  text));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setPos(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol	38	None	add
471	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  newPos);  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  newPos);	      instant.setMillis(bucket.computeMillis(false,    text));    iLocale    =    locale;    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	11	None	replace
472	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [CE]  cannot  find  symbol  pivotYear  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  pivotYear  +  chrono.getChronology().getOffset(instantLocal);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear    +    chrono.getChronology().getOffset(instantLocal);    	non-compiled	[CE]  cannot  find  symbol  pivotYear	10	None	replace
473	[BUG]  [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);  }  [CE]  not  a  statement  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);  }	      instant.setMillis(bucket.computeMillis(false,    text));    iOffsetParsed    &&    bucket.getOffsetInteger()!=    null);    	non-compiled	[CE]  not  a  statement	6	None	replace
474	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);  [CE]  no  suitable  method  found  for  setMillis(long,boolean)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  iOffsetParsed  &&  bucket.getOffsetInteger()!=  null);	      instant.setMillis(bucket.computeMillis(false,    text));    iOffsetParsed    &&    bucket.getOffsetInteger()!=    null);    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,boolean)	6	None	replace
475	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetLong()  ==  null)  {  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetLong()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffsetLong()  ==  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
476	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetSecond()  ==  null)  {  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetSecond()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffsetSecond()  ==  null)  {	  if(iOffsetParsed    &&    bucket.getOffsetInteger()    ==    null)    {    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
477	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.createChronology(bucket,  text,  position,  newPos);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  chrono.createChronology(bucket,  text,  position,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  chrono.createChronology(bucket,  text,  position,  newPos);	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
478	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(chrono,  text,  position,  newPos);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(chrono,  text,  position,  newPos);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(chrono,  text,  position,  newPos);	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
479	[BUG]  [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetOutset()!=  null)  {  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if  (iOffsetParsed  &&  bucket.getOffsetOutset()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if  (iOffsetParsed  &&  bucket.getOffsetOutset()!=  null)  {	  if    (iOffsetParsed    &&    bucket.getOffsetMillis()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
480	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  newPos);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  newPos);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  newPos);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(iLocale);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocale(iLocale);    }    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	42	None	replace
481	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  newPos);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  newPos);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  newPos);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setLocale(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setLocale(instantLocal);    }    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	36	None	replace
482	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()!=  null  ||  bucket.getOffsetInteger()!=  null)  {  [CE]  incomparable  types:  int  and  <null>  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()!=  null  ||  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffset()!=  null  ||  bucket.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffset()!=    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	32	None	replace
483	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  bucket.getOffsetInteger()  >=  null)  {  [CE]  incomparable  types:  int  and  <null>  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  bucket.getOffsetInteger()  >=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  bucket.getOffsetInteger()  >=  null)  {	  if(iOffsetParsed    &&    bucket.getOffset()!=    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	32	None	replace
484	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  instant.getOffsetInteger()!=  null)  {  [CE]  incomparable  types:  int  and  <null>  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  instant.getOffsetInteger()!=  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  instant.getOffsetInteger()!=  null)  {	  if(iOffsetParsed    &&    bucket.getOffset()!=    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	32	None	replace
485	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  bucket.getOffsetInteger()  ==  null)  {  [CE]  incomparable  types:  int  and  <null>  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  bucket.getOffsetInteger()  ==  null)  {  [BUGGY]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed  &&  bucket.getOffset()!=  null  &&  bucket.getOffsetInteger()  ==  null)  {	  if(iOffsetParsed    &&    bucket.getOffset()!=    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	32	None	replace
486	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  iPivotYear  =  newPos;  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  iPivotYear  =  newPos;  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text));  iPivotYear  =  newPos;	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    pivotYear;    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	8	None	replace
487	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  position));  [CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  position));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text,  position));	      instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)	7	None	replace
488	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text,  position));  [CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text,  position));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text,  position));	      instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)	7	None	replace
489	[BUG]  [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  chrono.parseInto(bucket,  text,  position);  [CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        int    textPos    =    parser.parseInto(bucket,    text,    position);    int  textPos  =  chrono.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	add
490	[BUG]  [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  parser.parseTo(bucket,  text,  position);  [CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  parser.parseTo(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        int    textPos    =    parser.parseInto(bucket,    text,    position);    int  textPos  =  parser.parseTo(bucket,  text,  position);	  	non-compiled	[CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	add
491	[BUG]  [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  parser.parseFrom(bucket,  text,  position);  [CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  textPos  =  parser.parseInto(bucket,  text,  position);  int  textPos  =  parser.parseFrom(bucket,  text,  position);  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        int    textPos    =    parser.parseInto(bucket,    text,    position);    int  textPos  =  parser.parseFrom(bucket,  text,  position);	  	non-compiled	[CE]  variable  textPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	add
492	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  chrono.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  chrono.createChronology(bucket,  text,  position,  newPos);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
493	[BUG]  [BUGGY]  instant.setLocale(parser.getLocale());  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
494	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iDefaultYear);  instant.setLocale(parser.getLocale());  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iDefaultYear);  instant.setLocale(parser.getLocale());  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position,  newPos,  iDefaultYear);  instant.setLocale(parser.getLocale());	      DateTimeParser    parser    =    iPrinter.createChronology(bucket,    text,    position,    newPos);    instant.setLocale(parser.getLocale());    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
495	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  newPos);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  newPos);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  newPos);  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setOffset(instantLocal);  }	      instant.setMillis(bucket.computeMillis(false,    text));    if(iOffsetParsed    &&    bucket.getOffsetInteger()!=    null)    {    instant.setOffset(instantLocal);    }    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	37	None	replace
496	[BUG]  [BUGGY]  if(textPos!=  position)  {  int  textPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  textPos));  }  [CE]  cannot  find  symbol  textPos  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(textPos!=  position)  {  int  textPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  textPos));  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(textPos!=  position)  {  int  textPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  textPos));  }	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    textPos));    	non-compiled	[CE]  cannot  find  symbol  textPos	25	None	replace
497	[BUG]  [BUGGY]  if(textPos  >=  position)  {  int  textPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  textPos));  }  [CE]  cannot  find  symbol  textPos  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  if(textPos  >=  position)  {  int  textPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  textPos));  }  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	if(textPos  >=  position)  {  int  textPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  textPos));  }	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    textPos));    	non-compiled	[CE]  cannot  find  symbol  textPos	25	None	replace
498	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  start,  position);  instant.setMillis(bucket.computeMillis(false,  textPos));  [CE]  cannot  find  symbol  start  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  start,  position);  instant.setMillis(bucket.computeMillis(false,  textPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  start,  position);  instant.setMillis(bucket.computeMillis(false,  textPos));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    textPos));    	non-compiled	[CE]  cannot  find  symbol  start	25	None	replace
499	[BUG]  [BUGGY]  int  textPos  =  parser.parseInto(bucket,  context,  position);  instant.setMillis(bucket.computeMillis(false,  textPos));  [CE]  cannot  find  symbol  context  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  textPos  =  parser.parseInto(bucket,  context,  position);  instant.setMillis(bucket.computeMillis(false,  textPos));  [BUGGY]    instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  textPos  =  parser.parseInto(bucket,  context,  position);  instant.setMillis(bucket.computeMillis(false,  textPos));	      int    textPos    =    parser.parseInto(bucket,    textPos,    position);    instant.setMillis(bucket.computeMillis(false,    textPos));    	non-compiled	[CE]  cannot  find  symbol  context	25	None	replace
