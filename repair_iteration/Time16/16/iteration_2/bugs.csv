bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	5	7	add
2	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	5	7	add
3	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  assign  a  value  to  final  variable  iParser  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iParser	5	None	add
4	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	5	7	add
5	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	5	7	add
6	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	5	7	add
7	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	5	7	add
8	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	5	None	add
9	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	5	7	add
10	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	5	7	add
11	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	5	None	add
12	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseFrom(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseFrom(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseFrom(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	5	None	add
13	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  Text));  [CE]  cannot  find  symbol  Text  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  Text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  Text));	  	non-compiled	[CE]  cannot  find  symbol  Text	5	None	add
14	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  newPos  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol  newPos	30	None	replace
15	[BUG]  [BUGGY]  int  text  =  parser.parseInstant(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInstant(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInstant(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
16	[BUG]  [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInstant(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
17	[BUG]  [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInstant(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
18	[BUG]  [BUGGY]  int  text  =  parser.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
19	[BUG]  [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
20	[BUG]  [BUGGY]  int  text  =  parser.parseInstant(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInstant(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInstant(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
21	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        parser.parseInto(bucket,    text,    position);    parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	10	7	add
22	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	10	7	add
23	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        parser.parseInto(bucket,    text,    position);    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	10	7	add
24	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	10	7	add
25	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    parser.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	10	None	add
26	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    parser.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	10	None	add
27	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));	  	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)	10	None	add
28	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iPivotYear  =  pivotYear;  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iPivotYear  =  pivotYear;  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iPivotYear  =  pivotYear;	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	10	None	add
29	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        parser.parseInto(bucket,    text,    position);    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	10	7	add
30	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	10	7	add
31	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        parser.parseInto(bucket,    text,    position);    iParser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	10	7	add
32	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    iParser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	10	7	add
33	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iPivotYear));  [CE]  no  suitable  method  found  for  computeMillis(boolean,Integer)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iPivotYear));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iPivotYear));	  	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,Integer)	10	None	add
34	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	32	7	add
35	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	32	7	add
36	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	32	7	add
37	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	32	7	add
38	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	32	7	add
39	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	32	7	add
40	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	32	None	add
41	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	32	7	add
42	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	32	7	add
43	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    parser.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol	32	None	add
44	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	32	7	add
45	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	32	7	add
46	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	32	None	add
47	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	32	7	add
48	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	32	7	add
49	[BUG]  [BUGGY]  parser.parseInto(bucket,  instantLocal,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  instantLocal,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  instantLocal,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	34	None	replace
50	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position,  iLocale,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	34	None	replace
51	[BUG]  [BUGGY]  parser.parseInto(bucket,  iLocale,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  iLocale,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  iLocale,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	34	None	replace
52	[BUG]  [BUGGY]  parser.parseInto(bucket,  instantLocal,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  instantLocal,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  instantLocal,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	34	None	replace
53	[BUG]  [BUGGY]  parser.parseInto(bucket,  instantMillis,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  instantMillis,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  instantMillis,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	34	None	replace
54	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  instantMillis);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  instantMillis);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position,  iLocale,  instantMillis);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	34	None	replace
55	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position,  chrono,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	34	None	replace
56	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  instantLocal);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  instantLocal);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position,  iLocale,  instantLocal);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	34	None	replace
57	[BUG]  [BUGGY]  parser.parseInto(bucket,  position,  text,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  position,  text,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  position,  text,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	34	None	replace
58	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  text,  instantLocal);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  text,  instantLocal);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  position,  text,  instantLocal);	      int    text    =    parser.parseInto(bucket,    instantMillis,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
59	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  text,  instantMillis);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  text,  instantMillis);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  position,  text,  instantMillis);	      int    text    =    parser.parseInto(bucket,    instantMillis,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
60	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  instantLocal,  text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  instantLocal,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  instantLocal,  text,  position);	      int    text    =    parser.parseInto(bucket,    instantMillis,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
61	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  text);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  text);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  position,  text);	      int    text    =    parser.parseInto(bucket,    instantMillis,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
62	[BUG]  [BUGGY]  int  text  =  iParser.parseInto(bucket,  instantMillis,  text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iParser.parseInto(bucket,  instantMillis,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iParser.parseInto(bucket,  instantMillis,  text,  position);	      int    text    =    parser.parseInto(bucket,    instantMillis,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
63	[BUG]  [BUGGY]  int  text  =  iParser.parseInto(bucket,  position,  text,  instantMillis);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iParser.parseInto(bucket,  position,  text,  instantMillis);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iParser.parseInto(bucket,  position,  text,  instantMillis);	      int    text    =    parser.parseInto(bucket,    instantMillis,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
64	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  text,  iLocale);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  text,  iLocale);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  position,  text,  iLocale);	      int    text    =    parser.parseInto(bucket,    instantMillis,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
65	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  instantMillis);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  instantMillis);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  position,  instantMillis);	      int    text    =    parser.parseInto(bucket,    instantMillis,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
66	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  iLocale,  text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  iLocale,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  iLocale,  text,  position);	      int    text    =    parser.parseInto(bucket,    instantMillis,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
67	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instantLocal);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instantLocal);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	DateTimeParser  parser  =  bucket.getParser(instantLocal);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
68	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser(),  text,  position);  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  DateTimeParser  parser  =  bucket.getParser(),  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	DateTimeParser  parser  =  bucket.getParser(),  text,  position);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  ';'  expected	24	None	replace
69	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(instantLocal,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  DateTimeParser  parser  =  bucket.parse(instantLocal,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	DateTimeParser  parser  =  bucket.parse(instantLocal,  text,  position);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
70	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser(0);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  DateTimeParser  parser  =  bucket.getParser(0);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	DateTimeParser  parser  =  bucket.getParser(0);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
71	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser(),  instantLocal);  [CE]  ';'  expected  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  DateTimeParser  parser  =  bucket.getParser(),  instantLocal);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	DateTimeParser  parser  =  bucket.getParser(),  instantLocal);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  ';'  expected	24	None	replace
72	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  DateTimeParser  parser  =  bucket.parse(text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	DateTimeParser  parser  =  bucket.parse(text,  position);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
73	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(instantLocal,  text);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  DateTimeParser  parser  =  bucket.parse(instantLocal,  text);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	DateTimeParser  parser  =  bucket.parse(instantLocal,  text);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
74	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parseInto(instantLocal,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  DateTimeParser  parser  =  bucket.parseInto(instantLocal,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	DateTimeParser  parser  =  bucket.parseInto(instantLocal,  text,  position);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
75	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
76	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
77	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
78	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
79	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.setParseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.setParseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.setParseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	1	None	add
80	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
81	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
82	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
83	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
84	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	1	None	add
85	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	1	7	add
86	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	1	7	add
87	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.setChronology(bucket.getChronology());  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.setChronology(bucket.getChronology());  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.setChronology(bucket.getChronology());  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	1	None	add
88	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  Text));  [CE]  cannot  find  symbol  Text  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  Text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  Text));	  	non-compiled	[CE]  cannot  find  symbol  Text	1	None	add
89	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  instantLocal));  [CE]  no  suitable  method  found  for  computeMillis(boolean,long)  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  instantLocal));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	instant.setMillis(bucket.computeMillis(false,  instantLocal));	      int    text    =    iChrono.parseInstant(instantLocal,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,long)	12	None	replace
90	[BUG]  [BUGGY]  int  text  =  parser.parseInstant(instantLocal,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInstant(instantLocal,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInstant(instantLocal,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(instantLocal,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
91	[BUG]  [BUGGY]  long  text  =  iChrono.parseInstant(instantLocal,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  long  text  =  iChrono.parseInstant(instantLocal,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	long  text  =  iChrono.parseInstant(instantLocal,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(instantLocal,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
92	[BUG]  [BUGGY]  int  text  =  iChrono.parseInstant(instantLocal,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInstant(instantLocal,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInstant(instantLocal,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(instantLocal,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
93	[BUG]  [BUGGY]  Integer  text  =  chrono.getText(instantLocal);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  chrono.getText(instantLocal);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  chrono.getText(instantLocal);	      Integer    text    =    iChrono.getText(instantLocal);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
94	[BUG]  [BUGGY]  Integer  text  =  bucket.getText(instantLocal);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  bucket.getText(instantLocal);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  bucket.getText(instantLocal);	      Integer    text    =    iChrono.getText(instantLocal);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
95	[BUG]  [BUGGY]  Integer  text  =  iChrono.getText(instantLocal,  chrono);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  iChrono.getText(instantLocal,  chrono);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  iChrono.getText(instantLocal,  chrono);	      Integer    text    =    iChrono.getText(instantLocal);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
96	[BUG]  [BUGGY]  Integer  text  =  iChrono.getText(instantLocal,  iPivotYear);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  iChrono.getText(instantLocal,  iPivotYear);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  iChrono.getText(instantLocal,  iPivotYear);	      Integer    text    =    iChrono.getText(instantLocal);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
97	[BUG]  [BUGGY]  Integer  text  =  instantLocal.getText(iChrono);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  instantLocal.getText(iChrono);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  instantLocal.getText(iChrono);	      Integer    text    =    iChrono.getText(instantLocal);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
98	[BUG]  [BUGGY]  Integer  text  =  iChrono.getText(instantLocal,  instantMillis);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  iChrono.getText(instantLocal,  instantMillis);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  iChrono.getText(instantLocal,  instantMillis);	      Integer    text    =    iChrono.getText(instantLocal);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
99	[BUG]  [BUGGY]  Integer  text  =  iChrono.getText(instantLocal,  instantPivotYear);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  iChrono.getText(instantLocal,  instantPivotYear);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  iChrono.getText(instantLocal,  instantPivotYear);	      Integer    text    =    iChrono.getText(instantLocal);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
100	[BUG]  [BUGGY]  Integer  text  =  parser.getText(instantLocal);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  parser.getText(instantLocal);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  parser.getText(instantLocal);	      Integer    text    =    iChrono.getText(instantLocal);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
101	[BUG]  [BUGGY]  Integer  text  =  iChrono.getText(instantLocal,  iDefaultYear);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  iChrono.getText(instantLocal,  iDefaultYear);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  iChrono.getText(instantLocal,  iDefaultYear);	      Integer    text    =    iChrono.getText(instantLocal);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
102	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos,  text));  [CE]  no  suitable  method  found  for  computeMillis(int,int,String)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  newPos,  text));	  instant.setMillis(bucket.computeMillis(0,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,int,String)	19	None	replace
103	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos,  text.length()));  [CE]  no  suitable  method  found  for  computeMillis(int,int,int)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos,  text.length()));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  newPos,  text.length()));	  instant.setMillis(bucket.computeMillis(0,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,int,int)	19	None	replace
104	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(int,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  text,  newPos));	  instant.setMillis(bucket.computeMillis(0,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,String,int)	19	None	replace
105	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0L,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(long,int)  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0L,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0L,  newPos));	  instant.setMillis(bucket.computeMillis(0,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(long,int)	19	None	replace
106	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos),  text);  [CE]  no  suitable  method  found  for  computeMillis(int,int)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos),  text);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  newPos),  text);	  instant.setMillis(bucket.computeMillis(0,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,int)	19	None	replace
107	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos),  text,  position);  [CE]  no  suitable  method  found  for  computeMillis(int,int)  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos),  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  newPos),  text,  position);	  instant.setMillis(bucket.computeMillis(0,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,int)	19	None	replace
108	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos,  textLength));  [CE]  cannot  find  symbol  textLength  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos,  textLength));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  newPos,  textLength));	  instant.setMillis(bucket.computeMillis(0,    newPos));    	non-compiled	[CE]  cannot  find  symbol  textLength	19	None	replace
109	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position  -  1);  [CE]  cannot  find  symbol  newPos  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position  -  1);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position  -  1);	      parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol  newPos	11	None	replace
110	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iDefaultYear);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iDefaultYear);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position,  iDefaultYear);	      parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	11	None	replace
111	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iPivotYear);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iPivotYear);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position,  iPivotYear);	      parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	11	None	replace
112	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position  +  1);  [CE]  cannot  find  symbol  newPos  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position  +  1);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position  +  1);	      parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol  newPos	11	None	replace
113	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  instantLocal);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position,  instantLocal);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position,  instantLocal);	      parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	11	None	replace
114	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position,  iLocale);	      parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	11	None	replace
115	[BUG]  [BUGGY]  parser.parseInto(bucket,  instantLocal,  position);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  instantLocal,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  instantLocal,  position);	      parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	11	None	replace
116	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position,  chrono);	      parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	11	None	replace
117	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iChrono);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iChrono);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position,  iChrono);	      parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	11	None	replace
118	[BUG]  [BUGGY]  int  text  =  parser.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parse(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	35	None	replace
119	[BUG]  [BUGGY]  int  text  =  iChrono.parse(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parse(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parse(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parse(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	35	None	replace
120	[BUG]  [BUGGY]  int  text  =  iChrono.parse(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parse(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parse(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parse(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	35	None	replace
121	[BUG]  [BUGGY]  int  text  =  parser.parse(bucket,  position,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parse(bucket,  position,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parse(bucket,  position,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parse(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	35	None	replace
122	[BUG]  [BUGGY]  int  text  =  iChrono.parse(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parse(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parse(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parse(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	35	None	replace
123	[BUG]  [BUGGY]  int  text  =  parser.parse(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parse(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parse(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parse(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	35	None	replace
124	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(text,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(String,int)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(text,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(text,  newPos));	  instant.setMillis(bucket.computeMillis(newPos,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(String,int)	20	None	replace
125	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(instantLocal,  text,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(long,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(instantLocal,  text,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(instantLocal,  text,  newPos));	  instant.setMillis(bucket.computeMillis(newPos,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(long,String,int)	20	None	replace
126	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(instantLocal,  newPos,  text));  [CE]  no  suitable  method  found  for  computeMillis(long,int,String)  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(instantLocal,  newPos,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(instantLocal,  newPos,  text));	  instant.setMillis(bucket.computeMillis(newPos,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(long,int,String)	20	None	replace
127	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(newPos,  text,  position));  [CE]  no  suitable  method  found  for  computeMillis(int,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(newPos,  text,  position));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(newPos,  text,  position));	  instant.setMillis(bucket.computeMillis(newPos,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,String,int)	20	None	replace
128	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(instantLocal,  text,  position));  [CE]  no  suitable  method  found  for  computeMillis(long,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(instantLocal,  text,  position));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(instantLocal,  text,  position));	  instant.setMillis(bucket.computeMillis(newPos,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(long,String,int)	20	None	replace
129	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(lang,  newPos,  text));  [CE]  cannot  find  symbol  lang  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(lang,  newPos,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(lang,  newPos,  text));	  instant.setMillis(bucket.computeMillis(newPos,    text));    	non-compiled	[CE]  cannot  find  symbol  lang	20	None	replace
130	[BUG]  [BUGGY]  iParser.parseInto(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser.parseInto(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser.parseInto(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	6	None	replace
131	[BUG]  [BUGGY]  parser.parseInto(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	6	None	replace
132	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  instantLocal));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  instantLocal));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  instantLocal));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	6	None	replace
133	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  instantLocal));  [CE]  no  suitable  method  found  for  computeMillis(boolean,long)  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  instantLocal));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  instantLocal));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,long)	6	None	replace
134	[BUG]  [BUGGY]  int  text  =  parser.parseInstant(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInstant(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInstant(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	9	None	replace
135	[BUG]  [BUGGY]  int  text  =  parser.parseInstant(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInstant(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInstant(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	9	None	replace
136	[BUG]  [BUGGY]  int  text  =  parser.parseInstant(bucket,  position,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInstant(bucket,  position,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInstant(bucket,  position,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	9	None	replace
137	[BUG]  [BUGGY]  int  text  =  bucket.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  bucket.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  bucket.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	9	None	replace
138	[BUG]  [BUGGY]  int  text  =  parser.parseInstant(bucket,  position,  iLocale);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInstant(bucket,  position,  iLocale);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInstant(bucket,  position,  iLocale);	      int    text    =    parser.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	9	None	replace
139	[BUG]  [BUGGY]  parser.parseInto(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	33	None	replace
140	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  instantLocal));  [CE]  no  suitable  method  found  for  computeMillis(boolean,long)  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  instantLocal));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	instant.setMillis(bucket.computeMillis(true,  instantLocal));	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,long)	33	None	replace
141	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  newPos  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(true,  text));	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  cannot  find  symbol  newPos	33	None	replace
142	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  newPos  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	instant.setMillis(bucket.computeMillis(true,  text));	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  cannot  find  symbol  newPos	33	None	replace
143	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	compilable	  [FE]  AssertionFailedError  	33	7	replace
144	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	compilable	  [FE]  AssertionFailedError  	33	7	replace
145	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	33	None	replace
146	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	compilable	  [FE]  AssertionFailedError  	33	7	replace
147	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	compilable	  [FE]  AssertionFailedError  	33	7	replace
148	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	replace
149	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	replace
150	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	replace
151	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	replace
152	[BUG]  [BUGGY]  if(instantLocal!=  null)  {  int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  incomparable  types:  long  and  <null>  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(instantLocal!=  null)  {  int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(instantLocal!=  null)  {  int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    text    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  incomparable  types:  long  and  <null>	3	None	replace
153	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  position,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	replace
154	[BUG]  [BUGGY]  if(instantLocal!=  null)  {  int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  throw  new  IllegalArgumentException( " ");  }  [CE]  incomparable  types:  long  and  <null>  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(instantLocal!=  null)  {  int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(instantLocal!=  null)  {  int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  throw  new  IllegalArgumentException( " ");  }	      int    text    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  incomparable  types:  long  and  <null>	3	None	replace
155	[BUG]  [BUGGY]  Integer  text  =  bucket.getText().intValue();  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  bucket.getText().intValue();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  bucket.getText().intValue();	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	14	None	replace
156	[BUG]  [BUGGY]  Integer  text  =  bucket.getText().length();  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  bucket.getText().length();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  bucket.getText().length();	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	14	None	replace
157	[BUG]  [BUGGY]  Integer  text  =  bucket.getTextInt();  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  bucket.getTextInt();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  bucket.getTextInt();	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	14	None	replace
158	[BUG]  [BUGGY]  Integer  text  =  bucket.getText().substring(0,  instantLocal);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  bucket.getText().substring(0,  instantLocal);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  bucket.getText().substring(0,  instantLocal);	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	14	None	replace
159	[BUG]  [BUGGY]  Integer  text  =  bucket.getText().toLowerCase();  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  bucket.getText().toLowerCase();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  bucket.getText().toLowerCase();	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	14	None	replace
160	[BUG]  [BUGGY]  Integer  text  =  bucket.getText()  +  1;  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  bucket.getText()  +  1;  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  bucket.getText()  +  1;	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	14	None	replace
161	[BUG]  [BUGGY]  Integer  text  =  bucket.getText().substring(0,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  bucket.getText().substring(0,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  bucket.getText().substring(0,  position);	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	14	None	replace
162	[BUG]  [BUGGY]  Integer  text  =  bucket.getText().trim();  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  bucket.getText().trim();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  bucket.getText().trim();	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	14	None	replace
163	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position  +  1);  [CE]  cannot  find  symbol  newPos  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser.parseInto(bucket,  text,  position  +  1);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser.parseInto(bucket,  text,  position  +  1);	      iParser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol  newPos	8	None	replace
164	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position,  iPivotYear);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser.parseInto(bucket,  text,  position,  iPivotYear);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser.parseInto(bucket,  text,  position,  iPivotYear);	      iParser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	8	None	replace
165	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position,  instantLocal);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser.parseInto(bucket,  text,  position,  instantLocal);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser.parseInto(bucket,  text,  position,  instantLocal);	      iParser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	8	None	replace
166	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position,  iDefaultYear);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser.parseInto(bucket,  text,  position,  iDefaultYear);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser.parseInto(bucket,  text,  position,  iDefaultYear);	      iParser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	8	None	replace
167	[BUG]  [BUGGY]  iParser.parseInto(bucket,  instantLocal,  position);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser.parseInto(bucket,  instantLocal,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser.parseInto(bucket,  instantLocal,  position);	      iParser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	8	None	replace
168	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position,  chrono);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser.parseInto(bucket,  text,  position,  chrono);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser.parseInto(bucket,  text,  position,  chrono);	      iParser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	8	None	replace
169	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position,  iLocale);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser.parseInto(bucket,  text,  position,  iLocale);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser.parseInto(bucket,  text,  position,  iLocale);	      iParser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	8	None	replace
170	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position  -  1);  [CE]  cannot  find  symbol  newPos  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser.parseInto(bucket,  text,  position  -  1);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser.parseInto(bucket,  text,  position  -  1);	      iParser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol  newPos	8	None	replace
171	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position,  parsedOffset);  [CE]  cannot  find  symbol  parsedOffset  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser.parseInto(bucket,  text,  position,  parsedOffset);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser.parseInto(bucket,  text,  position,  parsedOffset);	      iParser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol  parsedOffset	8	None	replace
172	[BUG]  [BUGGY]  int  text  =  parser.parseInstant(bucket,  text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInstant(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInstant(bucket,  text,  position);	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	replace
173	[BUG]  [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  instantLocal,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  instantLocal,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInstant(bucket,  instantLocal,  position);	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	replace
174	[BUG]  [BUGGY]  int  text  =  chrono.parseInstant(bucket,  text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  chrono.parseInstant(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  chrono.parseInstant(bucket,  text,  position);	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	replace
175	[BUG]  [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  text,  position,  iPivotYear);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  text,  position,  iPivotYear);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInstant(bucket,  text,  position,  iPivotYear);	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	replace
176	[BUG]  [BUGGY]  int  text  =  bucket.parseInstant(bucket,  text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  bucket.parseInstant(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  bucket.parseInstant(bucket,  text,  position);	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	replace
177	[BUG]  [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  text,  position  +  1);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  text,  position  +  1);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInstant(bucket,  text,  position  +  1);	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	replace
178	[BUG]  [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  text,  position,  iDefaultYear);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  text,  position,  iDefaultYear);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInstant(bucket,  text,  position,  iDefaultYear);	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	replace
179	[BUG]  [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  text,  position,  iLocale);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  text,  position,  iLocale);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInstant(bucket,  text,  position,  iLocale);	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	replace
180	[BUG]  [BUGGY]  Integer  text  =  iChrono.parseInstant(bucket,  instantLocal,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  iChrono.parseInstant(bucket,  instantLocal,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  iChrono.parseInstant(bucket,  instantLocal,  position);	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	replace
181	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text,  position));  [CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text,  position));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text,  position));	  instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)	15	None	replace
182	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text,  newPos));	  instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)	15	None	replace
183	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  position,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(boolean,int,int)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  position,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  position,  newPos));	  instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int,int)	15	None	replace
184	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos,  text));  [CE]  no  suitable  method  found  for  computeMillis(boolean,int,String)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  newPos,  text));	  instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int,String)	15	None	replace
185	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(true,  text,  newPos));  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(true,  text,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(true,  text,  newPos));	  instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  cannot  find  symbol	15	None	replace
186	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position);	      timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
187	[BUG]  [BUGGY]  int  parsedOffset  =  iParser.parseInto(bucket,  text,  position);  [CE]  variable  parsedOffset  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  parsedOffset  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  parsedOffset  =  iParser.parseInto(bucket,  text,  position);	      timeout    	non-compiled	[CE]  variable  parsedOffset  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
188	[BUG]  [BUGGY]  Integer  parsedOffset  =  bucket.getOffsetInteger();  [CE]  variable  parsedOffset  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  Integer  parsedOffset  =  bucket.getOffsetInteger();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	Integer  parsedOffset  =  bucket.getOffsetInteger();	      timeout    	non-compiled	[CE]  variable  parsedOffset  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
189	[BUG]  [BUGGY]  timeout  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  iParser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	add	iParser.parseInto(bucket,  text,  position);	      timeout    	compilable	timeout	22	1	replace
190	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position);  timeout  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  iParser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	iParser.parseInto(bucket,  text,  position);	      timeout    	compilable	timeout	22	1	replace
191	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  [CE]  variable  parsedOffset  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  parsedOffset  =  bucket.getOffsetInteger();	      timeout    	non-compiled	[CE]  variable  parsedOffset  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
192	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffset(instantLocal);  [CE]  method  getOffset  in  class  DateTimeParserBucket  cannot  be  applied  to  given  types;  [FE]                            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  parsedOffset  =  bucket.getOffset(instantLocal);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  parsedOffset  =  bucket.getOffset(instantLocal);	      timeout    	non-compiled	[CE]  method  getOffset  in  class  DateTimeParserBucket  cannot  be  applied  to  given  types;	22	None	replace
193	[BUG]  [BUGGY]  int  parsedOffset  =  iParser.parseInstant(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]                              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  parsedOffset  =  iParser.parseInstant(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  parsedOffset  =  iParser.parseInstant(bucket,  text,  position);	      timeout    	non-compiled	[CE]  cannot  find  symbol	22	None	replace
194	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffset();  [CE]  variable  parsedOffset  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  int  parsedOffset  =  bucket.getOffset();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	int  parsedOffset  =  bucket.getOffset();	      timeout    	non-compiled	[CE]  variable  parsedOffset  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
195	[BUG]  [BUGGY]  iParser  =  bucket.getParser();  [CE]  cannot  assign  a  value  to  final  variable  iParser  [FE]                                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  iParser  =  bucket.getParser();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	iParser  =  bucket.getParser();	      timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iParser	22	None	replace
196	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  instantLocal,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  instantLocal,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  instantLocal,  position);	      int    text    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	4	None	replace
197	[BUG]  [BUGGY]  int  text  =  iParser.parseInto(bucket,  text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iParser.parseInto(bucket,  text,  position);	      int    text    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	4	None	replace
198	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  iLocale);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  iLocale);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  position,  iLocale);	      int    text    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	4	None	replace
199	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  instantLocal);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  instantLocal);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  position,  instantLocal);	      int    text    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	4	None	replace
200	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  iPivotYear);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  iPivotYear);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  position,  iPivotYear);	      int    text    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	4	None	replace
201	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  iLocale,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  iLocale,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  iLocale,  position);	      int    text    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	4	None	replace
202	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  chrono);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  chrono);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  position,  chrono);	      int    text    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	4	None	replace
203	[BUG]  [BUGGY]  int  text  =  iParser.parseInto(bucket,  instantLocal,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iParser.parseInto(bucket,  instantLocal,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iParser.parseInto(bucket,  instantLocal,  position);	      int    text    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	4	None	replace
204	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  clip,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  clip,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  clip,  position);	      int    text    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	4	None	replace
205	[BUG]  [BUGGY]  int  text  =  bucket.getText().length();  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  bucket.getText().length();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  bucket.getText().length();	      int    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	replace
206	[BUG]  [BUGGY]  int  text  =  bucket.getText()  +  1;  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  bucket.getText()  +  1;  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  bucket.getText()  +  1;	      int    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	replace
207	[BUG]  [BUGGY]  int  text  =  bucket.getText()  &  0xff;  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  bucket.getText()  &  0xff;  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  bucket.getText()  &  0xff;	      int    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	replace
208	[BUG]  [BUGGY]  int  text  =  bucket.getText()  +  position;  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  bucket.getText()  +  position;  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  bucket.getText()  +  position;	      int    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	replace
209	[BUG]  [BUGGY]  int  text  =  bucket.getText()  +  iPivotYear;  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  bucket.getText()  +  iPivotYear;  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  bucket.getText()  +  iPivotYear;	      int    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	replace
210	[BUG]  [BUGGY]  int  text  =  bucket.getText()  -  position;  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  bucket.getText()  -  position;  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  bucket.getText()  -  position;	      int    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	replace
211	[BUG]  [BUGGY]  int  text  =  iChrono.getText();  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.getText();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.getText();	      int    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	replace
212	[BUG]  [BUGGY]  int  text  =  bucket.getText()  &  iPivotYear;  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  bucket.getText()  &  iPivotYear;  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  bucket.getText()  &  iPivotYear;	      int    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	replace
213	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text,  newPos));	  instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)	18	None	replace
214	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(text,  position,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(String,int,int)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(text,  position,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(text,  position,  newPos));	  instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(String,int,int)	18	None	replace
215	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(text,  false,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(String,boolean,int)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(text,  false,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(text,  false,  newPos));	  instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(String,boolean,int)	18	None	replace
216	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  position));  [CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  position));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  text,  position));	  instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,String,int)	18	None	replace
217	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos,  text));  [CE]  no  suitable  method  found  for  computeMillis(boolean,int,String)  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos,  text));	  instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int,String)	18	None	replace
218	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	add	instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	16	7	add
219	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	16	7	add
220	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	add	instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	16	7	add
221	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	16	7	add
222	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  Instant  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  Instant  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,    text));    Instant  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  ';'  expected	16	None	add
223	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  moment.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  moment  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  moment.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,    text));    moment.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol  moment	16	None	add
224	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  minute.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  minute  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  minute.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,    text));    minute.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol  minute	16	None	add
225	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  int  instantMillis  =  bucket.computeMillis(true,  text));  [CE]  ';'  expected  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  int  instantMillis  =  bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,    text));    int  instantMillis  =  bucket.computeMillis(true,  text));	  	non-compiled	[CE]  ';'  expected	16	None	add
226	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(True,  text));  [CE]  cannot  find  symbol  True  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(True,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(True,  text));	  	non-compiled	[CE]  cannot  find  symbol  True	16	None	add
227	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  Text));  [CE]  cannot  find  symbol  Text  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  Text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(true,  Text));	  	non-compiled	[CE]  cannot  find  symbol  Text	16	None	add
228	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	31	None	replace
229	[BUG]  [BUGGY]  int  text  =  iChrono.parseInto(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInto(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInto(bucket,  instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	31	None	replace
230	[BUG]  [BUGGY]  int  text  =  iChrono.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	31	None	replace
231	[BUG]  [BUGGY]  int  text  =  iChrono.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	31	None	replace
232	[BUG]  [BUGGY]      int  parsedOffset  =  bucket.getOffset(instantLocal,  newPos);  [CE]  method  getOffset  in  class  DateTimeParserBucket  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  parsedOffset  =  bucket.getOffset(instantLocal,  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        int  parsedOffset  =  bucket.getOffset(instantLocal,  newPos);	  timeout    	non-compiled	[CE]  method  getOffset  in  class  DateTimeParserBucket  cannot  be  applied  to  given  types;	21	None	add
233	[BUG]  [BUGGY]  int  text  =  iChrono.parseInto(bucket,  instantLocal,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInto(bucket,  instantLocal,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInto(bucket,  instantLocal,  position);	      int    text    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	25	None	replace
234	[BUG]  [BUGGY]  int  text  =  bucket.parseInto(bucket,  text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  bucket.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  bucket.parseInto(bucket,  text,  position);	      int    text    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	25	None	replace
235	[BUG]  [BUGGY]  int  text  =  chrono.parseInto(bucket,  text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  chrono.parseInto(bucket,  text,  position);	      int    text    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	25	None	replace
236	[BUG]  [BUGGY]  Integer  text  =  iChrono.parseInto(bucket,  instantLocal,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  iChrono.parseInto(bucket,  instantLocal,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  iChrono.parseInto(bucket,  instantLocal,  position);	      int    text    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	25	None	replace
237	[BUG]  [BUGGY]  int  text  =  iChrono.parseInto(bucket,  position,  text);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInto(bucket,  position,  text);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInto(bucket,  position,  text);	      int    text    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	25	None	replace
238	[BUG]  [BUGGY]  int  text  =  iChrono.parseInto(bucket,  position,  instantLocal);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInto(bucket,  position,  instantLocal);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInto(bucket,  position,  instantLocal);	      int    text    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	25	None	replace
239	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        iParser.parseInto(bucket,    text,    position);    iParser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	7	7	add
240	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    iParser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	7	7	add
241	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        iParser.parseInto(bucket,    text,    position);    iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	7	7	add
242	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	7	7	add
243	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    iParser.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	7	None	add
244	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    iParser.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	7	None	add
245	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  super.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  super.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    iParser.parseInto(bucket,  text,  position);  super.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	7	None	add
246	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    iParser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	7	None	add
247	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        iParser.parseInto(bucket,    text,    position);    iParser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	7	7	add
248	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    iParser.parseInto(bucket,  text,  position);  parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	7	7	add
249	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        iParser.parseInto(bucket,    text,    position);    iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	7	7	add
250	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	7	7	add
251	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	        iParser.parseInto(bucket,    text,    position);    iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));	  	compilable	  [FE]  AssertionFailedError  	7	7	add
252	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [FE]  AssertionFailedError  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));	  	compilable	  [FE]  AssertionFailedError  	7	7	add
253	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  iDefaultYear  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iDefaultYear  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    iDefaultYear  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	7	None	add
254	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(true,  newPos));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(true,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(true,  newPos));	  instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
255	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  iLocale));  [CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  iLocale));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  iLocale));	  instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)	17	None	replace
256	[BUG]  [BUGGY]  parser  =  bucket.getParser();  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser  =  bucket.getParser();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser  =  bucket.getParser();	      iParser    =    bucket.getParser();    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
257	[BUG]  [BUGGY]  iParser  =  bucket.getParser(instantLocal);  [CE]  cannot  assign  a  value  to  final  variable  iParser  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser  =  bucket.getParser(instantLocal);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser  =  bucket.getParser(instantLocal);	      iParser    =    bucket.getParser();    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iParser	27	None	replace
258	[BUG]  [BUGGY]  Parser  parser  =  bucket.getParser();  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Parser  parser  =  bucket.getParser();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Parser  parser  =  bucket.getParser();	      iParser    =    bucket.getParser();    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
259	[BUG]  [BUGGY]  parsedOffset  =  bucket.getParser();  [CE]  cannot  find  symbol  parsedOffset  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parsedOffset  =  bucket.getParser();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parsedOffset  =  bucket.getParser();	      iParser    =    bucket.getParser();    	non-compiled	[CE]  cannot  find  symbol  parsedOffset	27	None	replace
260	[BUG]  [BUGGY]  iParser  =  bucket.getParserWithZone(instantLocal);  [CE]  cannot  assign  a  value  to  final  variable  iParser  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser  =  bucket.getParserWithZone(instantLocal);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser  =  bucket.getParserWithZone(instantLocal);	      iParser    =    bucket.getParser();    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iParser	27	None	replace
261	[BUG]  [BUGGY]  iParser  =  bucket.getParserInstance(instantLocal);  [CE]  cannot  assign  a  value  to  final  variable  iParser  [FE]                        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser  =  bucket.getParserInstance(instantLocal);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser  =  bucket.getParserInstance(instantLocal);	      iParser    =    bucket.getParser();    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iParser	27	None	replace
262	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  newPos  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol  newPos	2	None	replace
263	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  instantLocal));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  instantLocal));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  instantLocal));	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	2	None	replace
264	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  newPos));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(false,  newPos));	  instant.setMillis(instant.computeMillis(true,    text));    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
265	[BUG]  [BUGGY]  instant.setMillis(computeMillis(true,  newPos));  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(computeMillis(true,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(computeMillis(true,  newPos));	  instant.setMillis(instant.computeMillis(true,    text));    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
266	[BUG]  [BUGGY]  instant.setMillis(instant,  bucket.computeMillis(true,  text));  [CE]  no  suitable  method  found  for  setMillis(ReadWritableInstant,long)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant,  bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant,  bucket.computeMillis(true,  text));	  instant.setMillis(instant.computeMillis(true,    text));    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(ReadWritableInstant,long)	23	None	replace
267	[BUG]  [BUGGY]  instant.setMillis(instant,  chrono.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant,  chrono.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant,  chrono.computeMillis(true,  text));	  instant.setMillis(instant.computeMillis(true,    text));    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
268	[BUG]  [BUGGY]  int  text  =  bucket.getText()  &  position;  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  bucket.getText()  &  position;  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  bucket.getText()  &  position;	      int    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	replace
269	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parseInto(bucket,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  DateTimeParser  parser  =  bucket.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	DateTimeParser  parser  =  bucket.parseInto(bucket,  text,  position);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
270	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parseInstant(text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  DateTimeParser  parser  =  bucket.parseInstant(text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	DateTimeParser  parser  =  bucket.parseInstant(text,  position);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
271	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parseInto(bucket,  text);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  DateTimeParser  parser  =  bucket.parseInto(bucket,  text);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	DateTimeParser  parser  =  bucket.parseInto(bucket,  text);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
272	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(false,  text),  position);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(false,  text),  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    parser.setMillis(bucket.computeMillis(false,  text),  position);	  	non-compiled	[CE]  cannot  find  symbol	10	None	add
273	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    parser.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol	10	None	add
274	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    parser.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol	10	None	add
275	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(false,  iLocale));  [CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(false,  iLocale));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    parser.setMillis(bucket.computeMillis(false,  iLocale));	  	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)	10	None	add
276	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  iLocale));  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  iLocale));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    parser.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  iLocale));	  	non-compiled	[CE]  cannot  find  symbol	10	None	add
277	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(false,  text));  iPivotYear  =  pivotYear;  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setMillis(bucket.computeMillis(false,  text));  iPivotYear  =  pivotYear;  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    parser.setMillis(bucket.computeMillis(false,  text));  iPivotYear  =  pivotYear;	  	non-compiled	[CE]  cannot  find  symbol	10	None	add
278	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  iLocale,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(boolean,Locale,int)  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  iLocale,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  iLocale,  newPos));	  instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,Locale,int)	15	None	replace
279	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos),  iLocale);  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos),  iLocale);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  newPos),  iLocale);	  instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	15	None	replace
280	[BUG]  [BUGGY]  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
281	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)	2	None	replace
282	[BUG]  [BUGGY]  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
283	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos),  iLocale);  [CE]  no  suitable  method  found  for  computeMillis(int,int)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos),  iLocale);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  newPos),  iLocale);	  instant.setMillis(bucket.computeMillis(0,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,int)	19	None	replace
284	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos)+  1);  [CE]  no  suitable  method  found  for  computeMillis(int,int)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos)+  1);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  newPos)+  1);	  instant.setMillis(bucket.computeMillis(0,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,int)	19	None	replace
285	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos),  iDefaultYear);  [CE]  no  suitable  method  found  for  computeMillis(int,int)  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos),  iDefaultYear);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  newPos),  iDefaultYear);	  instant.setMillis(bucket.computeMillis(0,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,int)	19	None	replace
286	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos  -  1));  [CE]  no  suitable  method  found  for  computeMillis(int,int)  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos  -  1));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  newPos  -  1));	  instant.setMillis(bucket.computeMillis(0,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,int)	19	None	replace
287	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos),  iOffsetParsed);  [CE]  no  suitable  method  found  for  computeMillis(int,int)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos),  iOffsetParsed);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  newPos),  iOffsetParsed);	  instant.setMillis(bucket.computeMillis(0,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,int)	19	None	replace
288	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.setParseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.setParseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    parser.setParseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol	32	None	add
289	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    parser.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	32	None	add
290	[BUG]  [BUGGY]  if(iChrono!=  null)  {  int  text  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(iChrono!=  null)  {  int  text  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(iChrono!=  null)  {  int  text  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    text    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	31	None	replace
291	[BUG]  [BUGGY]  if(instantLocal!=  null)  {  int  text  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  incomparable  types:  long  and  <null>  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(instantLocal!=  null)  {  int  text  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(instantLocal!=  null)  {  int  text  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    text    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  incomparable  types:  long  and  <null>	31	None	replace
292	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  position,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  position,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	31	None	replace
293	[BUG]  [BUGGY]  long  text  =  iChrono.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  long  text  =  iChrono.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	long  text  =  iChrono.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	31	None	replace
294	[BUG]  [BUGGY]  int  text  =  parser.parse(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parse(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parse(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parse(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	35	None	replace
295	[BUG]  [BUGGY]  if(iChrono!=  null)  {  int  text  =  iChrono.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(iChrono!=  null)  {  int  text  =  iChrono.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(iChrono!=  null)  {  int  text  =  iChrono.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    text    =    iChrono.parse(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	35	None	replace
296	[BUG]  [BUGGY]  int  text  =  parser.parse(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parse(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parse(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parse(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	35	None	replace
297	[BUG]  [BUGGY]  int  text  =  parser.parse(bucket,  0,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parse(bucket,  0,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parse(bucket,  0,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parse(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	35	None	replace
298	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iZone);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iZone);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position,  iZone);	      parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	11	None	replace
299	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(instantMillis,  text));  [CE]  no  suitable  method  found  for  computeMillis(long,String)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(instantMillis,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(instantMillis,  text));	  instant.setMillis(bucket.computeMillis(newPos,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(long,String)	20	None	replace
300	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(instant,  text));  [CE]  no  suitable  method  found  for  computeMillis(ReadWritableInstant,String)  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(instant,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(instant,  text));	  instant.setMillis(bucket.computeMillis(newPos,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(ReadWritableInstant,String)	20	None	replace
301	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(newPos,  text));  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(newPos,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(newPos,  text));	  instant.setMillis(bucket.computeMillis(newPos,    text));    	non-compiled	[CE]  cannot  find  symbol	20	None	replace
302	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(instantLocal,  text));  [CE]  no  suitable  method  found  for  computeMillis(long,String)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(instantLocal,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(instantLocal,  text));	  instant.setMillis(bucket.computeMillis(newPos,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(long,String)	20	None	replace
303	[BUG]  [BUGGY]  parsedParser  =  bucket.getParser();  [CE]  cannot  find  symbol  parsedParser  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parsedParser  =  bucket.getParser();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parsedParser  =  bucket.getParser();	      iParser    =    bucket.getParser();    	non-compiled	[CE]  cannot  find  symbol  parsedParser	27	None	replace
304	[BUG]  [BUGGY]  int  parser  =  bucket.getParser();  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  parser  =  bucket.getParser();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  parser  =  bucket.getParser();	      iParser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
305	[BUG]  [BUGGY]  if(instantLocal  ==  null)  {  int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  incomparable  types:  long  and  <null>  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(instantLocal  ==  null)  {  int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(instantLocal  ==  null)  {  int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    text    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  incomparable  types:  long  and  <null>	3	None	replace
306	[BUG]  [BUGGY]  long  text  =  parser.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  long  text  =  parser.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	long  text  =  parser.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	replace
307	[BUG]  [BUGGY]  int  text  =  bucket.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  bucket.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  bucket.parseInto(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	replace
308	[BUG]  [BUGGY]  Integer  text  =  bucket.parseInteger(instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  bucket.parseInteger(instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  bucket.parseInteger(instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	replace
309	[BUG]  [BUGGY]  Integer  text  =  iChrono.getText(instantLocal,  index);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  iChrono.getText(instantLocal,  index);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  iChrono.getText(instantLocal,  index);	      Integer    text    =    iChrono.getText(instantLocal);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
310	[BUG]  [BUGGY]  Integer  text  =  iChrono.getText(instantLocal,  context);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  iChrono.getText(instantLocal,  context);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  iChrono.getText(instantLocal,  context);	      Integer    text    =    iChrono.getText(instantLocal);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
311	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iParser  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    iParser  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iParser	7	None	add
312	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  int  text  =  parser.parseInto(bucket,  text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  int  text  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    int  text  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	7	None	add
313	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.setMillis(bucket.computeMillis(false,  text));  int  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.setMillis(bucket.computeMillis(false,  text));  int  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    iParser.setMillis(bucket.computeMillis(false,  text));  int  newPos  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  find  symbol	7	None	add
314	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  int  text  =  parser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  int  text  =  parser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    int  text  =  parser.parseInto(bucket,  text,  position);  iParser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	7	None	add
315	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseTo(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseTo(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    iParser.parseTo(bucket,  text,  position);	  	non-compiled	[CE]  cannot  find  symbol	7	None	add
316	[BUG]  [BUGGY]  instant.setMillis(instantMillis.computeMillis(true,  newPos));  [CE]  long  cannot  be  dereferenced  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instantMillis.computeMillis(true,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instantMillis.computeMillis(true,  newPos));	  instant.setMillis(instant.computeMillis(true,    text));    	non-compiled	[CE]  long  cannot  be  dereferenced	23	None	replace
317	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(true,  text),  newPos);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(true,  text),  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(true,  text),  newPos);	  instant.setMillis(instant.computeMillis(true,    text));    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
318	[BUG]  [BUGGY]  instant.setMillis(instantMillis.computeMillis(true,  text));  [CE]  long  cannot  be  dereferenced  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instantMillis.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instantMillis.computeMillis(true,  text));	  instant.setMillis(instant.computeMillis(true,    text));    	non-compiled	[CE]  long  cannot  be  dereferenced	23	None	replace
319	[BUG]  [BUGGY]      Integer  parsedOffset  =  iParser.parseInstant(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      Integer  parsedOffset  =  iParser.parseInstant(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        Integer  parsedOffset  =  iParser.parseInstant(bucket,  text,  position);	  timeout    	non-compiled	[CE]  cannot  find  symbol	21	None	add
320	[BUG]  [BUGGY]      Integer  parsedOffset  =  iParser.parseInto(bucket,  text,  position);  [CE]  variable  parsedOffset  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      Integer  parsedOffset  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        Integer  parsedOffset  =  iParser.parseInto(bucket,  text,  position);	  timeout    	non-compiled	[CE]  variable  parsedOffset  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	21	None	add
321	[BUG]  [BUGGY]      DateTimeParser  parser  =  bucket.getParser();  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      DateTimeParser  parser  =  bucket.getParser();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        DateTimeParser  parser  =  bucket.getParser();	  timeout    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	21	None	add
322	[BUG]  [BUGGY]      int  parsedOffset  =  bucket.getOffset(newPos);  [CE]  method  getOffset  in  class  DateTimeParserBucket  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  parsedOffset  =  bucket.getOffset(newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        int  parsedOffset  =  bucket.getOffset(newPos);	  timeout    	non-compiled	[CE]  method  getOffset  in  class  DateTimeParserBucket  cannot  be  applied  to  given  types;	21	None	add
323	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  0,  text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  0,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  0,  text,  position);	      int    text    =    parser.parseInto(bucket,    instantMillis,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
324	[BUG]  [BUGGY]  int  text  =  iParser.parseInto(bucket,  instantLocal,  text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iParser.parseInto(bucket,  instantLocal,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iParser.parseInto(bucket,  instantLocal,  text,  position);	      int    text    =    parser.parseInto(bucket,    instantMillis,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
325	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  instantMillis,  chrono,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  instantMillis,  chrono,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  instantMillis,  chrono,  position);	      int    text    =    parser.parseInto(bucket,    instantMillis,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
326	[BUG]  [BUGGY]  float  text  =  parser.parseInto(bucket,  instantMillis,  text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  float  text  =  parser.parseInto(bucket,  instantMillis,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	float  text  =  parser.parseInto(bucket,  instantMillis,  text,  position);	      int    text    =    parser.parseInto(bucket,    instantMillis,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
327	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  0,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  0,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  0,  position);	      int    text    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	4	None	replace
328	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  text,  position,  iPivotYear);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  text,  position,  iPivotYear);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  text,  position,  iPivotYear);	      int    text    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	4	None	replace
329	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  text,  position  -  1);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  text,  position  -  1);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  text,  position  -  1);	      int    text    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	4	None	replace
330	[BUG]  [BUGGY]  int  text  =  iChronology.parseInto(bucket,  text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChronology.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChronology.parseInto(bucket,  text,  position);	      int    text    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	4	None	replace
331	[BUG]  [BUGGY]  if(iChrono!=  null)  {  int  text  =  iChrono.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(iChrono!=  null)  {  int  text  =  iChrono.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(iChrono!=  null)  {  int  text  =  iChrono.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
332	[BUG]  [BUGGY]  int  text  =  parser.parseInstant(bucket,  position,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInstant(bucket,  position,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInstant(bucket,  position,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
333	[BUG]  [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInstant(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
334	[BUG]  [BUGGY]  int  text  =  parser.parseInstant(bucket,  0,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInstant(bucket,  0,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInstant(bucket,  0,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
335	[BUG]  [BUGGY]  long  text  =  iChrono.parseInstant(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  long  text  =  iChrono.parseInstant(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	long  text  =  iChrono.parseInstant(bucket,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
336	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  Instant  instant  =  bucket.computeMillis(true,  text));  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  Instant  instant  =  bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,    text));    Instant  instant  =  bucket.computeMillis(true,  text));	  	non-compiled	[CE]  ';'  expected	16	None	add
337	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  newPos  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol  newPos	6	None	replace
338	[BUG]  [BUGGY]  iParser  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  assign  a  value  to  final  variable  iParser  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iParser	6	None	replace
339	[BUG]  [BUGGY]  Integer  text  =  iChrono.getText();  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  iChrono.getText();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  iChrono.getText();	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	14	None	replace
340	[BUG]  [BUGGY]  Integer  text  =  bucket.getText().toString();  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  bucket.getText().toString();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  bucket.getText().toString();	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	14	None	replace
341	[BUG]  [BUGGY]  Integer  text  =  bucket.getText()  +  position;  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  bucket.getText()  +  position;  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  bucket.getText()  +  position;	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	14	None	replace
342	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position,  iZone);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser.parseInto(bucket,  text,  position,  iZone);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser.parseInto(bucket,  text,  position,  iZone);	      iParser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	8	None	replace
343	[BUG]  [BUGGY]  long  text  =  iChrono.parseInstant(instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  long  text  =  iChrono.parseInstant(instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	long  text  =  iChrono.parseInstant(instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(instantLocal,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
344	[BUG]  [BUGGY]  int  text  =  parser.parseInstant(instantLocal,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInstant(instantLocal,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInstant(instantLocal,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(instantLocal,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
345	[BUG]  [BUGGY]  int  text  =  iChrono.parseInstant(instantLocal,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInstant(instantLocal,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInstant(instantLocal,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(instantLocal,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
346	[BUG]  [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInstant(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(instantLocal,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
347	[BUG]  [BUGGY]  int  text  =  iChrono.parseInstant(instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInstant(instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInstant(instantLocal,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(instantLocal,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
348	[BUG]  [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  text,  position  -  1);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  text,  position  -  1);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInstant(bucket,  text,  position  -  1);	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	replace
349	[BUG]  [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  text,  position,  chrono);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInstant(bucket,  text,  position,  chrono);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInstant(bucket,  text,  position,  chrono);	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	replace
350	[BUG]  [BUGGY]  if(instantLocal!=  null)  {  int  text  =  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  incomparable  types:  long  and  <null>  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(instantLocal!=  null)  {  int  text  =  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(instantLocal!=  null)  {  int  text  =  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    text    =    parser.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  incomparable  types:  long  and  <null>	9	None	replace
351	[BUG]  [BUGGY]  if(instantLocal  ==  null)  {  int  text  =  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  incomparable  types:  long  and  <null>  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(instantLocal  ==  null)  {  int  text  =  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(instantLocal  ==  null)  {  int  text  =  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    text    =    parser.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  incomparable  types:  long  and  <null>	9	None	replace
352	[BUG]  [BUGGY]  long  text  =  parser.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  long  text  =  parser.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	long  text  =  parser.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	9	None	replace
353	[BUG]  [BUGGY]  Integer  text  =  bucket.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  bucket.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  bucket.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	9	None	replace
354	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    int  text  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	1	None	add
355	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.setParse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.setParse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.setParse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	1	None	add
356	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  text  =  parser.parseInto(bucket,  text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  text  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    int  text  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	1	None	add
357	[BUG]  [BUGGY]  int  text  =  iChrono.parseInto(bucket,  text,  position,  iPivotYear);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInto(bucket,  text,  position,  iPivotYear);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInto(bucket,  text,  position,  iPivotYear);	      int    text    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	25	None	replace
358	[BUG]  [BUGGY]  int  text  =  iChrono.parseInto(bucket,  text,  position  +  1);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInto(bucket,  text,  position  +  1);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInto(bucket,  text,  position  +  1);	      int    text    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	25	None	replace
359	[BUG]  [BUGGY]  int  text  =  iChrono.parseInto(bucket,  text,  position,  iLocale);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInto(bucket,  text,  position,  iLocale);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInto(bucket,  text,  position,  iLocale);	      int    text    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	25	None	replace
360	[BUG]  [BUGGY]  int  text  =  iChrono.parseInto(bucket,  text,  position  -  1);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInto(bucket,  text,  position  -  1);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInto(bucket,  text,  position  -  1);	      int    text    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	25	None	replace
361	[BUG]  [BUGGY]  int  text  =  iChrono.parseInto(bucket,  text,  position,  chrono);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInto(bucket,  text,  position,  chrono);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInto(bucket,  text,  position,  chrono);	      int    text    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	25	None	replace
362	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	5	None	add
363	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	5	None	add
364	[BUG]  [BUGGY]  parseInto(bucket,  text,  position,  iLocale,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parseInto(bucket,  text,  position,  iLocale,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parseInto(bucket,  text,  position,  iLocale,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	34	None	replace
365	[BUG]  [BUGGY]  parser.parseInto(bucket,  iLocale,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  iLocale,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  iLocale,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	34	None	replace
366	[BUG]  [BUGGY]  if(iDefaultYear!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  incomparable  types:  int  and  <null>  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(iDefaultYear!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(iDefaultYear!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  incomparable  types:  int  and  <null>	6	None	replace
367	[BUG]  [BUGGY]  if(iDefaultYear!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  throw  new  IllegalArgumentException( " ");  }  [CE]  incomparable  types:  int  and  <null>  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(iDefaultYear!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(iDefaultYear!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  throw  new  IllegalArgumentException( " ");  }	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  incomparable  types:  int  and  <null>	6	None	replace
368	[BUG]  [BUGGY]  if(iDefaultYear!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  DateTimeParser  parser  =  bucket.getParser();  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(iDefaultYear!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  DateTimeParser  parser  =  bucket.getParser();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(iDefaultYear!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  DateTimeParser  parser  =  bucket.getParser();	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  expression	6	None	replace
369	[BUG]  [BUGGY]  iParser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	6	None	replace
370	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(null,  text));  [CE]  no  suitable  method  found  for  computeMillis(<null>,String)  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(null,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(null,  text));	  	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(<null>,String)	16	None	add
371	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  Instant  instant  =  chrono.computeMillis(true,  text));  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  Instant  instant  =  chrono.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,    text));    Instant  instant  =  chrono.computeMillis(true,  text));	  	non-compiled	[CE]  ';'  expected	16	None	add
372	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position,  iChrono);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  iParser.parseInto(bucket,  text,  position,  iChrono);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	iParser.parseInto(bucket,  text,  position,  iChrono);	      iParser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	8	None	replace
373	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  instantMillis,  text,  position,  iPivotYear);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  instantMillis,  text,  position,  iPivotYear);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  instantMillis,  text,  position,  iPivotYear);	      int    text    =    parser.parseInto(bucket,    instantMillis,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
374	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  instantMillis,  text,  position,  iLocale);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  instantMillis,  text,  position,  iLocale);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  instantMillis,  text,  position,  iLocale);	      int    text    =    parser.parseInto(bucket,    instantMillis,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
375	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  instantMillis,  text,  position,  iDefaultYear);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  instantMillis,  text,  position,  iDefaultYear);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  instantMillis,  text,  position,  iDefaultYear);	      int    text    =    parser.parseInto(bucket,    instantMillis,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
376	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  instantMillis,  text,  position  -  1);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  instantMillis,  text,  position  -  1);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  instantMillis,  text,  position  -  1);	      int    text    =    parser.parseInto(bucket,    instantMillis,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
377	[BUG]  [BUGGY]  int  text  =  iChrono.parseInto(bucket,  text,  position,  iDefaultYear);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  iChrono.parseInto(bucket,  text,  position,  iDefaultYear);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  iChrono.parseInto(bucket,  text,  position,  iDefaultYear);	      int    text    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	25	None	replace
378	[BUG]  [BUGGY]  timeZone  =  bucket.getParser();  [CE]  cannot  find  symbol  timeZone  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  timeZone  =  bucket.getParser();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	timeZone  =  bucket.getParser();	      iParser    =    bucket.getParser();    	non-compiled	[CE]  cannot  find  symbol  timeZone	27	None	replace
379	[BUG]  [BUGGY]  parsed  =  bucket.getParser();  [CE]  cannot  find  symbol  parsed  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parsed  =  bucket.getParser();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parsed  =  bucket.getParser();	      iParser    =    bucket.getParser();    	non-compiled	[CE]  cannot  find  symbol  parsed	27	None	replace
380	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	5	None	add
381	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.setChronology(bucket.getChronology());  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.setChronology(bucket.getChronology());  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.setChronology(bucket.getChronology());  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	5	None	add
382	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.setIndex(bucket.computeIndex(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.setIndex(bucket.computeIndex(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.setIndex(bucket.computeIndex(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	5	None	add
383	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.setIndex(bucket.computeIndex(false,  text));  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.setIndex(bucket.computeIndex(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.setIndex(bucket.computeIndex(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	5	None	add
384	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	add	        int  iLocale  =  iParser.parseInto(bucket,  text,  position);	  timeout    	compilable	  [FE]  AssertionFailedError  	21	7	add
385	[BUG]  [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        int  iLocale  =  iParser.parseInto(bucket,  text,  position);	  timeout    	compilable	  [FE]  AssertionFailedError  	21	7	add
386	[BUG]  [BUGGY]      int  parsedOffset  =  chrono.getOffset(instantLocal);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      int  parsedOffset  =  chrono.getOffset(instantLocal);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        int  parsedOffset  =  chrono.getOffset(instantLocal);	  timeout    	non-compiled	[CE]  cannot  find  symbol	21	None	add
387	[BUG]  [BUGGY]      Integer  parsedOffset  =  iParser.parseInt(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]      Integer  parsedOffset  =  iParser.parseInt(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	        Integer  parsedOffset  =  iParser.parseInt(bucket,  text,  position);	  timeout    	non-compiled	[CE]  cannot  find  symbol	21	None	add
388	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(true,  text,  position));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(true,  text,  position));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(true,  text,  position));	  instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  cannot  find  symbol	15	None	replace
389	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(true,  newPos,  text));  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(true,  newPos,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(true,  newPos,  text));	  instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  cannot  find  symbol	15	None	replace
390	[BUG]  [BUGGY]  instant.setMillis(chrono.computeMillis(true,  newPos));  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(chrono.computeMillis(true,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(chrono.computeMillis(true,  newPos));	  instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  cannot  find  symbol	15	None	replace
391	[BUG]  [BUGGY]  if(iLocale!=  null)  {  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(iLocale!=  null)  {  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(iLocale!=  null)  {  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  }	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	34	None	replace
392	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position,  iLocale,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	34	None	replace
393	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position,  iLocale,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	34	None	replace
394	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text),  iLocale);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text),  iLocale);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parseInto(bucket,  text,  position,  iLocale,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text),  iLocale);	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	34	None	replace
395	[BUG]  [BUGGY]  Integer  text  =  bucket.getText(),  position);  [CE]  ';'  expected  [FE]                          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  bucket.getText(),  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  bucket.getText(),  position);	      Integer    text    =    bucket.getText();    	non-compiled	[CE]  ';'  expected	14	None	replace
396	[BUG]  [BUGGY]  int  text  =  bucket.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  bucket.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  bucket.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	9	None	replace
397	[BUG]  [BUGGY]  int  text  =  chrono.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  chrono.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  chrono.parseInstant(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	9	None	replace
398	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(text,  position));  [CE]  no  suitable  method  found  for  computeMillis(String,int)  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(text,  position));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(text,  position));	  instant.setMillis(bucket.computeMillis(newPos,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(String,int)	20	None	replace
399	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(instantMillis,  text,  position));  [CE]  no  suitable  method  found  for  computeMillis(long,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(instantMillis,  text,  position));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(instantMillis,  text,  position));	  instant.setMillis(bucket.computeMillis(newPos,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(long,String,int)	20	None	replace
400	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(newPos,  text,  position));  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(newPos,  text,  position));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(newPos,  text,  position));	  instant.setMillis(bucket.computeMillis(newPos,    text));    	non-compiled	[CE]  cannot  find  symbol	20	None	replace
401	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.parseTo(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.parseTo(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    parser.parseTo(bucket,  text,  position);	  	non-compiled	[CE]  cannot  find  symbol	10	None	add
402	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    parser.setChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	10	None	add
403	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setChronology(iChrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  parser.setChronology(iChrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    parser.setChronology(iChrono);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	10	None	add
404	[BUG]  [BUGGY]  int  text  =  bucket.getText().trim();  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  bucket.getText().trim();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  bucket.getText().trim();	      int    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	replace
405	[BUG]  [BUGGY]  int  text  =  bucket.getText()  &  0xFFFF;  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  bucket.getText()  &  0xFFFF;  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  bucket.getText()  &  0xFFFF;	      int    text    =    bucket.getText();    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	replace
406	[BUG]  [BUGGY]  if(instantLocal!=  iLocale)  {  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [CE]  incomparable  types:  long  and  Locale  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(instantLocal!=  iLocale)  {  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(instantLocal!=  iLocale)  {  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  incomparable  types:  long  and  Locale	33	None	replace
407	[BUG]  [BUGGY]  int  text  =  bucket.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  bucket.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  bucket.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	replace
408	[BUG]  [BUGGY]  int  text  =  bucket.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  bucket.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  bucket.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	replace
409	[BUG]  [BUGGY]  long  text  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  long  text  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	long  text  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	3	None	replace
410	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	1	None	add
411	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	1	None	add
412	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.setParsed(true);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.setParsed(true);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.setParsed(true);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	1	None	add
413	[BUG]  [BUGGY]  long  text  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  long  text  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	long  text  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	31	None	replace
414	[BUG]  [BUGGY]  float  text  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  float  text  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	float  text  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	31	None	replace
415	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(instantMillis,  false,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(long,boolean,int)  [FE]            AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(instantMillis,  false,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(instantMillis,  false,  newPos));	  instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(long,boolean,int)	18	None	replace
416	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  newPos),  text);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  newPos),  text);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(false,  newPos),  text);	  instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  cannot  find  symbol	18	None	replace
417	[BUG]  [BUGGY]  if(instantLocal!=  null)  {  int  text  =  iChrono.parseInstant(instantLocal,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  incomparable  types:  long  and  <null>  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(instantLocal!=  null)  {  int  text  =  iChrono.parseInstant(instantLocal,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(instantLocal!=  null)  {  int  text  =  iChrono.parseInstant(instantLocal,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    text    =    iChrono.parseInstant(instantLocal,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  incomparable  types:  long  and  <null>	12	None	replace
418	[BUG]  [BUGGY]  int  text  =  chrono.parseInstant(instantLocal,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  chrono.parseInstant(instantLocal,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  chrono.parseInstant(instantLocal,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(instantLocal,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
419	[BUG]  [BUGGY]  int  text  =  chrono.parseInstant(instantLocal,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  chrono.parseInstant(instantLocal,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  chrono.parseInstant(instantLocal,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(instantLocal,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	12	None	replace
420	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instantLocal,  text);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instantLocal,  text);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	DateTimeParser  parser  =  bucket.getParser(instantLocal,  text);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
421	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(text,  position,  iLocale);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  DateTimeParser  parser  =  bucket.parse(text,  position,  iLocale);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	DateTimeParser  parser  =  bucket.parse(text,  position,  iLocale);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
422	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parseDateTimeParser(instantLocal,  text);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  DateTimeParser  parser  =  bucket.parseDateTimeParser(instantLocal,  text);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	DateTimeParser  parser  =  bucket.parseDateTimeParser(instantLocal,  text);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
423	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  text,  position,  iLocale);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  text,  position,  iLocale);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  text,  position,  iLocale);	      int    text    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	4	None	replace
424	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);	      int    text    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	4	None	replace
425	[BUG]  [BUGGY]  int  text  =  parser.parseInto(bucket,  text,  position  +  1);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  parser.parseInto(bucket,  text,  position  +  1);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  parser.parseInto(bucket,  text,  position  +  1);	      int    text    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	4	None	replace
426	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text,  position));  [CE]  no  suitable  method  found  for  computeMillis(int,String,int)  [FE]              AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text,  position));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(0,  text,  position));	  instant.setMillis(bucket.computeMillis(0,    newPos));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(int,String,int)	19	None	replace
427	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(0,  newPos));  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(0,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(0,  newPos));	  instant.setMillis(bucket.computeMillis(0,    newPos));    	non-compiled	[CE]  cannot  find  symbol	19	None	replace
428	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(0,  newPos),  text);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(0,  newPos),  text);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(0,  newPos),  text);	  instant.setMillis(bucket.computeMillis(0,    newPos));    	non-compiled	[CE]  cannot  find  symbol	19	None	replace
429	[BUG]  [BUGGY]  if(instantLocal!=  null)  {  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  incomparable  types:  long  and  <null>  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(instantLocal!=  null)  {  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(instantLocal!=  null)  {  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  incomparable  types:  long  and  <null>	2	None	replace
430	[BUG]  [BUGGY]  if(instantLocal!=  null)  {  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  throw  new  IllegalArgumentException( " ");  }  [CE]  incomparable  types:  long  and  <null>  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(instantLocal!=  null)  {  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(instantLocal!=  null)  {  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  throw  new  IllegalArgumentException( " ");  }	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  incomparable  types:  long  and  <null>	2	None	replace
431	[BUG]  [BUGGY]  parser.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  parser.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	parser.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
432	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    parser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol	32	None	add
433	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol	32	None	add
434	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    parser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	32	None	add
435	[BUG]  [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    parser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	32	None	add
436	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text),  newPos);  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]    AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text),  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(bucket.computeMillis(true,  text),  newPos);	  instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	17	None	replace
437	[BUG]  [BUGGY]  if(instantLocal!=  null)  {  int  text  =  iChrono.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  incomparable  types:  long  and  <null>  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  if(instantLocal!=  null)  {  int  text  =  iChrono.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	if(instantLocal!=  null)  {  int  text  =  iChrono.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  incomparable  types:  long  and  <null>	30	None	replace
438	[BUG]  [BUGGY]  float  text  =  iChrono.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  float  text  =  iChrono.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	float  text  =  iChrono.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
439	[BUG]  [BUGGY]  long  text  =  iChrono.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  long  text  =  iChrono.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	long  text  =  iChrono.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
440	[BUG]  [BUGGY]  int  text  =  chrono.parseInstant(bucket,  position,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  chrono.parseInstant(bucket,  position,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  chrono.parseInstant(bucket,  position,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parseInstant(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
441	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInstant(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.parseInstant(bucket,  text,  position);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    iParser.parseInstant(bucket,  text,  position);	  	non-compiled	[CE]  cannot  find  symbol	7	None	add
442	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.setMillis(bucket.computeMillis(false,  text),  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.setMillis(bucket.computeMillis(false,  text),  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    iParser.setMillis(bucket.computeMillis(false,  text),  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	7	None	add
443	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    iParser.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol	7	None	add
444	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.setCrc(bucket.computeChronology(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  iParser.setCrc(bucket.computeChronology(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	        iParser.parseInto(bucket,    text,    position);    iParser.setCrc(bucket.computeChronology(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	7	None	add
445	[BUG]  [BUGGY]  Integer  text  =  iChrono.getText(chrono);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  iChrono.getText(chrono);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  iChrono.getText(chrono);	      Integer    text    =    iChrono.getText(instantLocal);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
446	[BUG]  [BUGGY]  Integer  text  =  instantLocal.getText();  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  instantLocal.getText();  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  instantLocal.getText();	      Integer    text    =    iChrono.getText(instantLocal);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
447	[BUG]  [BUGGY]  Integer  text  =  iChrono.getText(instantLocal,  instantLocal);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  Integer  text  =  iChrono.getText(instantLocal,  instantLocal);  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	Integer  text  =  iChrono.getText(instantLocal,  instantLocal);	      Integer    text    =    iChrono.getText(instantLocal);    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	replace
448	[BUG]  [BUGGY]  long  text  =  iChrono.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  long  text  =  iChrono.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	long  text  =  iChrono.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parse(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	35	None	replace
449	[BUG]  [BUGGY]  float  text  =  iChrono.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  float  text  =  iChrono.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	float  text  =  iChrono.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parse(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	35	None	replace
450	[BUG]  [BUGGY]  int  text  =  chrono.parse(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  chrono.parse(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  chrono.parse(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parse(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	35	None	replace
451	[BUG]  [BUGGY]  int  text  =  chrono.parseInteger(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);    [BUGGY]  int  text  =  chrono.parseInteger(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  text  =  chrono.parseInteger(bucket,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    text    =    iChrono.parse(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	35	None	replace
452	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(instant.computeMillis(false,  text));	  instant.setMillis(instant.computeMillis(true,    text));    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
453	[BUG]  [BUGGY]  instant.setMillis(iChrono.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);    [BUGGY]  instant.setMillis(iChrono.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	711	711	7	replace	instant.setMillis(iChrono.computeMillis(true,  text));	  instant.setMillis(instant.computeMillis(true,    text));    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
