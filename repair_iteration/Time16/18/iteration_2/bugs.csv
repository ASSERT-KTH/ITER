bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetParsed();  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetParsed();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetParsed();	      int    parsedOffset    =    bucket.getOffsetInteger();    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
2	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetParsedInteger();  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetParsedInteger();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetParsedInteger();	      int    parsedOffset    =    bucket.getOffsetInteger();    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
3	[BUG]  [BUGGY]  long  parsedOffset  =  bucket.getOffsetInteger();  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  long  parsedOffset  =  bucket.getOffsetInteger();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	long  parsedOffset  =  bucket.getOffsetInteger();	      int    parsedOffset    =    bucket.getOffsetInteger();    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
4	[BUG]  [BUGGY]  Integer  parsedOffset  =  bucket.getOffsetInteger();  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  Integer  parsedOffset  =  bucket.getOffsetInteger();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	Integer  parsedOffset  =  bucket.getOffsetInteger();	      int    parsedOffset    =    bucket.getOffsetInteger();    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
5	[BUG]  [BUGGY]  int  parsedOffset  =  instant.getOffsetInteger();  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  instant.getOffsetInteger();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  instant.getOffsetInteger();	      int    parsedOffset    =    bucket.getOffsetInteger();    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
6	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetMillis();  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetMillis();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetMillis();	      int    parsedOffset    =    bucket.getOffsetInteger();    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
7	[BUG]  [BUGGY]  float  parsedOffset  =  bucket.getOffsetInteger();  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  float  parsedOffset  =  bucket.getOffsetInteger();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	float  parsedOffset  =  bucket.getOffsetInteger();	      int    parsedOffset    =    bucket.getOffsetInteger();    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
8	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffset(position);  [CE]  illegal  start  of  type  [FE]                              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffset(position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffset(position);	      int    parsedOffset    =    bucket.getOffsetInteger();    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
9	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iLocale!=  null  &&  bucket.getZone()  ==  null)  {	  }    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	4	7	replace
10	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()  ==  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  null  &&  bucket.getZone()  ==  null)  {	  }    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	4	7	replace
11	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale  ==  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iLocale  ==  null  &&  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	4	7	replace
12	[BUG]  [BUGGY]  }  else  if(iLocale  ==  null  &&  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale  ==  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale  ==  null  &&  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	4	7	replace
13	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iPivotYear!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iPivotYear!=  null  &&  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	4	7	replace
14	[BUG]  [BUGGY]  }  else  if(iPivotYear!=  null  &&  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iPivotYear!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iPivotYear!=  null  &&  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	4	7	replace
15	[BUG]  [BUGGY]  }  else  if(instantLocale!=  null  &&  bucket.getZone()!=  null)  {  [CE]  cannot  find  symbol  instantLocale  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instantLocale!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(instantLocale!=  null  &&  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  instantLocale	4	None	replace
16	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  ||  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iLocale!=  null  ||  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	4	7	replace
17	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  ||  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  ||  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  null  ||  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	4	7	replace
18	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iZone!=  null  &&  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	4	7	replace
19	[BUG]  [BUGGY]  }  else  if(iZone!=  null  &&  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iZone!=  null  &&  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	4	7	replace
20	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	8	7	add
21	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	8	7	add
22	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	8	7	add
23	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()  ==  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	8	7	add
24	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null  ||  instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null  ||  instant.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	8	7	add
25	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null  ||  instant.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null  ||  instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null  ||  instant.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	8	7	add
26	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(instant.getZone()!=    null)    {    }  else  if(bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	8	7	add
27	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	8	7	add
28	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());	  	compilable	  [FE]  AssertionFailedError  	8	7	add
29	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());	  	compilable	  [FE]  AssertionFailedError  	8	7	add
30	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null  ||  instant.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null  ||  instant.getZone()  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	8	7	add
31	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null  ||  instant.getZone()  ==  null)  {  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null  ||  instant.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null  ||  instant.getZone()  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	8	7	add
32	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()  >=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()  >=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()  >=  null)  {	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	8	None	add
33	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null  ||  parsedZone.getZone()!=  null)  {  [CE]  cannot  find  symbol  parsedZone  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null  ||  parsedZone.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null  ||  parsedZone.getZone()!=  null)  {	  	non-compiled	[CE]  cannot  find  symbol  parsedZone	8	None	add
34	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(parsedZone.getZone()!=  null)  {  [CE]  cannot  find  symbol  parsedZone  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(parsedZone.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(parsedZone.getZone()!=  null)  {	  	non-compiled	[CE]  cannot  find  symbol  parsedZone	8	None	add
35	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
36	[BUG]  [BUGGY]  iChrono  =  chrono.parseInto(bucket,  text,  position,  newPos);  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  iChrono  =  chrono.parseInto(bucket,  text,  position,  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	iChrono  =  chrono.parseInto(bucket,  text,  position,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
37	[BUG]  [BUGGY]  if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  }  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  }	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
38	[BUG]  [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos,  instantLocal);  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos,  instantLocal);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos,  instantLocal);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
39	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position,  instantLocal);  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position,  instantLocal);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	iChrono  =  parser.parseInto(bucket,  text,  position,  instantLocal);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
40	[BUG]  [BUGGY]  if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  }  else  {  instant.setMillis(bucket.computeMillis(false,  [CE]  '.class'  expected  [FE]                        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  }  else  {  instant.setMillis(bucket.computeMillis(false,  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  }  else  {  instant.setMillis(bucket.computeMillis(false,	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  '.class'  expected	29	None	replace
41	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos,  instantLocal);  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos,  instantLocal);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos,  instantLocal);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
42	[BUG]  [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos  +  1);  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos  +  1);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos  +  1);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
43	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  instantLocal);  [CE]  illegal  start  of  type  [FE]                              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  instantLocal);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  instantLocal);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
44	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }	  	compilable	  [FE]  NullPointerException  	43	8	add
45	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [FE]  NullPointerException  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }	  	compilable	  [FE]  NullPointerException  	43	8	add
46	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.set  [CE]  not  a  statement  [FE]      NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.set  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.set	  	non-compiled	[CE]  not  a  statement	43	None	add
47	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.  [CE]  <identifier>  expected  [FE]        NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.	  	non-compiled	[CE]  <identifier>  expected	43	None	add
48	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]          NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }	  	compilable	  [FE]  NullPointerException  	43	8	add
49	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [FE]  NullPointerException  [FE]          NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }	  	compilable	  [FE]  NullPointerException  	43	8	add
50	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [timeout]  [FE]            NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }	  	non-compiled	[timeout]	43	None	add
51	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  else  {  instant.setChronology(iChrono);  }  [timeout]  [FE]              NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  else  {  instant.setChronology(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  else  {  instant.setChronology(iChrono);  }	  	non-compiled	[timeout]	43	None	add
52	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setCh  [CE]  not  a  statement  [FE]                NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setCh  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setCh	  	non-compiled	[CE]  not  a  statement	43	None	add
53	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(iChrono);  }  [CE]  method  setZone  in  interface  ReadWritableInstant  cannot  be  applied  to  given  types;  [FE]                  NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(iChrono);  }	  	non-compiled	[CE]  method  setZone  in  interface  ReadWritableInstant  cannot  be  applied  to  given  types;	43	None	add
54	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]                    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  NullPointerException  	43	8	add
55	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [FE]  NullPointerException  [FE]                    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  NullPointerException  	43	8	add
56	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	newPos  =  parser.parseInto(bucket,  text,  position  -  1);	      newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
57	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	newPos  =  parser.parseInto(bucket,  text,  position  +  1);	      newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
58	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	newPos  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);	      newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
59	[BUG]  [BUGGY]  newPos  =  iParser.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  newPos  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	newPos  =  iParser.parseInto(bucket,  text,  position);	      newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
60	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);	      newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
61	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  instantLocal);  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  instantLocal);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	newPos  =  parser.parseInto(bucket,  text,  position,  instantLocal);	      newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
62	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  instantLocal,  position);  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  newPos  =  parser.parseInto(bucket,  instantLocal,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	newPos  =  parser.parseInto(bucket,  instantLocal,  position);	      newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
63	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position  -  2);  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position  -  2);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	newPos  =  parser.parseInto(bucket,  text,  position  -  2);	      newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
64	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iLocale!=  null  &&  chrono.getZone()  ==  null)  {	  }    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	35	7	replace
65	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()  ==  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  null  &&  chrono.getZone()  ==  null)  {	  }    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	35	7	replace
66	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iChrono!=  null  &&  chrono.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	35	7	replace
67	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  chrono.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iChrono!=  null  &&  chrono.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	35	7	replace
68	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale  ==  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iLocale  ==  null  &&  chrono.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	35	7	replace
69	[BUG]  [BUGGY]  }  else  if(iLocale  ==  null  &&  chrono.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale  ==  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale  ==  null  &&  chrono.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	35	7	replace
70	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iPivotYear!=  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iPivotYear!=  null  &&  chrono.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	35	7	replace
71	[BUG]  [BUGGY]  }  else  if(iPivotYear!=  null  &&  chrono.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iPivotYear!=  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iPivotYear!=  null  &&  chrono.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	35	7	replace
72	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getChronology()!=  null)  {  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getChronology()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  null  &&  chrono.getChronology()!=  null)  {	  }    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
73	[BUG]  [BUGGY]  }  else  if(instantLocale!=  null  &&  chrono.getZone()!=  null)  {  [CE]  cannot  find  symbol  instantLocale  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instantLocale!=  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(instantLocale!=  null  &&  chrono.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  instantLocale	35	None	replace
74	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iOffsetParsed  &&  chrono.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	35	7	replace
75	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  chrono.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  chrono.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	35	7	replace
76	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  ||  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iLocale!=  null  ||  chrono.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	35	7	replace
77	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  ||  chrono.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  ||  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  null  ||  chrono.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	35	7	replace
78	[BUG]  [BUGGY]  bucket.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  bucket.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	bucket.setMillis(bucket.computeMillis(false,  text));	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setParsed(true);    }    	non-compiled	[CE]  illegal  start  of  type	47	None	replace
79	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));  }  else  {  instant.setParsed(true);  }  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));  }  else  {  instant.setParsed(true);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));  }  else  {  instant.setParsed(true);  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setParsed(true);    }    	non-compiled	[CE]  illegal  start  of  type	47	None	replace
80	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setParsed(true);    }    	non-compiled	[CE]  illegal  start  of  type	47	None	replace
81	[BUG]  [BUGGY]  bucket.setMillis(bucket.computeMillis(false,  newPos));  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  bucket.setMillis(bucket.computeMillis(false,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	bucket.setMillis(bucket.computeMillis(false,  newPos));	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setParsed(true);    }    	non-compiled	[CE]  illegal  start  of  type	47	None	replace
82	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  else  {  instant.setParsed(true);  }  [CE]  illegal  start  of  type  [FE]                              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  else  {  instant.setParsed(true);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  else  {  instant.setParsed(true);  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setParsed(true);    }    	non-compiled	[CE]  illegal  start  of  type	47	None	replace
83	[BUG]  [BUGGY]  if(iLocale!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iLocale!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iLocale!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
84	[BUG]  [BUGGY]  if(iLocale  ==  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iLocale  ==  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iLocale  ==  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
85	[BUG]  [BUGGY]  if(instantLocal!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(instantLocal!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(instantLocal!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
86	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
87	[BUG]  [BUGGY]  if(iDefaultYear!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iDefaultYear!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iDefaultYear!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
88	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
89	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
90	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));  }  else  {  instant.setChronology(chrono);  }  [CE]  illegal  start  of  type  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));  }  else  {  instant.setChronology(chrono);  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    	non-compiled	[CE]  illegal  start  of  type	46	None	replace
91	[BUG]  [BUGGY]  Integer  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]      NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  Integer  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	Integer  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    	non-compiled	[CE]  illegal  start  of  type	46	None	replace
92	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));  }  else  {  instant.setChronology(iChrono);  }  [CE]  illegal  start  of  type  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));  }  else  {  instant.setChronology(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));  }  else  {  instant.setChronology(iChrono);  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
93	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iOffsetParsed  &&  instant.getZone()!=  null)  {	  }    else    if(instant.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	9	7	replace
94	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  instant.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  instant.getZone()!=  null)  {	  }    else    if(instant.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	9	7	replace
95	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iLocale!=  null  &&  instant.getZone()!=  null)  {	  }    else    if(instant.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	9	7	replace
96	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  instant.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  null  &&  instant.getZone()!=  null)  {	  }    else    if(instant.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	9	7	replace
97	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  parsedZone.getZone()!=  null)  {  [CE]  cannot  find  symbol  parsedZone  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  parsedZone.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  parsedZone.getZone()!=  null)  {	  }    else    if(instant.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  parsedZone	9	None	replace
98	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iPivotYear!=  null  &&  instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iPivotYear!=  null  &&  instant.getZone()!=  null)  {	  }    else    if(instant.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	9	7	replace
99	[BUG]  [BUGGY]  }  else  if(iPivotYear!=  null  &&  instant.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iPivotYear!=  null  &&  instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iPivotYear!=  null  &&  instant.getZone()!=  null)  {	  }    else    if(instant.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	9	7	replace
100	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(instant.getZone()  ==  null)  {	  }    else    if(instant.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	9	7	replace
101	[BUG]  [BUGGY]  }  else  if(instant.getZone()  ==  null)  {  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(instant.getZone()  ==  null)  {	  }    else    if(instant.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	9	7	replace
102	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  message));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  message));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(false,  message));	      instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
103	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  oldPos));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  oldPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(false,  oldPos));	      instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
104	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  iLocale));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  iLocale));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(false,  iLocale));	      instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
105	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	instant.setMillis(bucket.computeMillis(false,  text));	      	compilable	  [FE]  AssertionFailedError  	12	8	replace
106	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text));	      	compilable	  [FE]  AssertionFailedError  	12	8	replace
107	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setChronology(chrono);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	instant.setChronology(chrono);	      	compilable	  [FE]  AssertionFailedError  	12	8	replace
108	[BUG]  [BUGGY]  instant.setChronology(chrono);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setChronology(chrono);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setChronology(chrono);	      	compilable	  [FE]  AssertionFailedError  	12	8	replace
109	[BUG]  [BUGGY]  parsedOffset  =  parsedZone.getOffset();  [CE]  no  suitable  method  found  for  getOffset()  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  parsedZone.getOffset();  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	parsedOffset  =  parsedZone.getOffset();	      	non-compiled	[CE]  no  suitable  method  found  for  getOffset()	12	None	replace
110	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);	      	compilable	  [FE]  AssertionFailedError  	12	8	replace
111	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);	      	compilable	  [FE]  AssertionFailedError  	12	8	replace
112	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  parsedOffset));  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  parsedOffset));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  parsedOffset));	      	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	12	None	replace
113	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setChronology(iChrono);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	instant.setChronology(iChrono);	      	compilable	  [FE]  AssertionFailedError  	12	8	replace
114	[BUG]  [BUGGY]  instant.setChronology(iChrono);  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setChronology(iChrono);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setChronology(iChrono);	      	compilable	  [FE]  AssertionFailedError  	12	8	replace
115	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);	      	non-compiled	[CE]  cannot  find  symbol	12	None	replace
116	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  iLocale  =  locale;  [CE]  cannot  assign  a  value  to  final  variable  iLocale  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  iLocale  =  locale;  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text));  iLocale  =  locale;	      	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iLocale	12	None	replace
117	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  iLocale));  [CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  iLocale));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  iLocale));	      	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)	12	None	replace
118	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  AssertionFailedError  	40	7	add
119	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  AssertionFailedError  	40	7	add
120	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  AssertionFailedError  	40	7	add
121	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  AssertionFailedError  	40	7	add
122	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  AssertionFailedError  	40	7	add
123	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  AssertionFailedError  	40	7	add
124	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  NullPointerException  	40	8	add
125	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [FE]  NullPointerException  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  NullPointerException  	40	8	add
126	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >>  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  incompatible  types  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >>  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >>  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	non-compiled	[CE]  incompatible  types	40	None	add
127	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(true,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(true,  text));  }	  	compilable	  [FE]  AssertionFailedError  	40	7	add
128	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(true,  text));  }  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(true,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(true,  text));  }	  	compilable	  [FE]  AssertionFailedError  	40	7	add
129	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  newPos  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  newPos  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  int  newPos  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	40	None	add
130	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  chrono.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  chrono.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  chrono.setMillis(bucket.computeMillis(false,  text));  }	  	non-compiled	[CE]  cannot  find  symbol	40	None	add
131	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	34	7	add
132	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	34	7	add
133	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  chrono.getZone()  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	34	7	add
134	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()  ==  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  chrono.getZone()  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	34	7	add
135	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale  ==  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale  ==  null  &&  chrono.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	34	7	add
136	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale  ==  null  &&  chrono.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale  ==  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale  ==  null  &&  chrono.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	34	7	add
137	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()  >=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()  >=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  chrono.getZone()  >=  null)  {	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	34	None	add
138	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale  >=  null  &&  chrono.getZone()!=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale  >=  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale  >=  null  &&  chrono.getZone()!=  null)  {	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	34	None	add
139	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getUpperZone()!=  null)  {  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getUpperZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  chrono.getUpperZone()!=  null)  {	  	non-compiled	[CE]  cannot  find  symbol	34	None	add
140	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getChronology()!=  null)  {  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getChronology()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  chrono.getChronology()!=  null)  {	  	non-compiled	[CE]  cannot  find  symbol	34	None	add
141	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getName()!=  null)  {  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getName()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  chrono.getName()!=  null)  {	  	non-compiled	[CE]  cannot  find  symbol	34	None	add
142	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()  >>  null)  {  [CE]  bad  operand  types  for  binary  operator  '>>'  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()  >>  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  chrono.getZone()  >>  null)  {	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>>'	34	None	add
143	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  ||  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale!=  null  ||  chrono.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	34	7	add
144	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  ||  chrono.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  ||  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale!=  null  ||  chrono.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	34	7	add
145	[BUG]  [BUGGY]  if(iLocale!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iLocale!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iLocale!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
146	[BUG]  [BUGGY]  if(iDefaultYear!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iDefaultYear!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iDefaultYear!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
147	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(true,  text));	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
148	[BUG]  [BUGGY]  if(iDefaultYear  ==  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iDefaultYear  ==  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iDefaultYear  ==  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
149	[BUG]  [BUGGY]  newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
150	[BUG]  [BUGGY]  newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
151	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(0,  newPos));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
152	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(newPos,  text));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(newPos,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(newPos,  text));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
153	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	48	7	add
154	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	48	7	add
155	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(chrono!=    null)    {    }  else  if(chrono  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	48	7	add
156	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono  ==  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	48	7	add
157	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());	  	compilable	  [FE]  AssertionFailedError  	48	7	add
158	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());	  	compilable	  [FE]  AssertionFailedError  	48	7	add
159	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono  >=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono  >=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono  >=  null)  {	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	48	None	add
160	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null  ||  instant.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	48	7	add
161	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  instant.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null  ||  instant.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	48	7	add
162	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  chrono.isZone(parsedZone))  {  [CE]  cannot  find  symbol  parsedZone  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  chrono.isZone(parsedZone))  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null  ||  chrono.isZone(parsedZone))  {	  	non-compiled	[CE]  cannot  find  symbol  parsedZone	48	None	add
163	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  instant.isChronology())  {  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  instant.isChronology())  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null  ||  instant.isChronology())  {	  	non-compiled	[CE]  cannot  find  symbol	48	None	add
164	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  iLocale!=  locale)  {  [CE]  cannot  find  symbol  locale  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  iLocale!=  locale)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null  ||  iLocale!=  locale)  {	  	non-compiled	[CE]  cannot  find  symbol  locale	48	None	add
165	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  instant.getZone()!=  parsedZone)  {  [CE]  cannot  find  symbol  parsedZone  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  instant.getZone()!=  parsedZone)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null  ||  instant.getZone()!=  parsedZone)  {	  	non-compiled	[CE]  cannot  find  symbol  parsedZone	48	None	add
166	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  instant.getChronology()  ==  chrono)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null  ||  instant.getChronology()  ==  chrono)  {	  	compilable	  [FE]  AssertionFailedError  	48	7	add
167	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  instant.getChronology()  ==  chrono)  {  [FE]  AssertionFailedError  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  instant.getChronology()  ==  chrono)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null  ||  instant.getChronology()  ==  chrono)  {	  	compilable	  [FE]  AssertionFailedError  	48	7	add
168	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instantLocal);  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instantLocal);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.getParser(instantLocal);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
169	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser(),  newPos);  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.getParser(),  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.getParser(),  newPos);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  ';'  expected	26	None	replace
170	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instantLocal,  newPos);  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instantLocal,  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.getParser(instantLocal,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
171	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(instantLocal,  newPos);  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.parse(instantLocal,  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.parse(instantLocal,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
172	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser(newPos);  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.getParser(newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.getParser(newPos);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
173	[BUG]  [BUGGY]  DateTimeParser  parser  =  iChrono.getParser();  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  iChrono.getParser();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  iChrono.getParser();	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
174	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parseDateTimeParser(instantLocal,  newPos);  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.parseDateTimeParser(instantLocal,  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.parseDateTimeParser(instantLocal,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
175	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(instantLocal,  text,  position);  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.parse(instantLocal,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.parse(instantLocal,  text,  position);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
176	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	20	7	add
177	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	20	7	add
178	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	20	7	add
179	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	20	7	add
180	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  Instant  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  Instant  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    Instant  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  ';'  expected	20	None	add
181	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  moment.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  moment  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  moment.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    moment.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol  moment	20	None	add
182	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(True,  text));  [CE]  cannot  find  symbol  True  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(True,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(True,  text));	  	non-compiled	[CE]  cannot  find  symbol  True	20	None	add
183	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  Text));  [CE]  cannot  find  symbol  Text  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  Text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(true,  Text));	  	non-compiled	[CE]  cannot  find  symbol  Text	20	None	add
184	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  minute.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  minute  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  minute.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    minute.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol  minute	20	None	add
185	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  message));  [CE]  cannot  find  symbol  message  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(true,  message));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(true,  message));	  	non-compiled	[CE]  cannot  find  symbol  message	20	None	add
186	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	13	7	add
187	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	13	7	add
188	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	13	7	add
189	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	13	7	add
190	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  newPos));	  	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	13	None	add
191	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  Instant  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  Instant  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    Instant  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  ';'  expected	13	None	add
192	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  iLocale));  [CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  iLocale));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  iLocale));	  	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)	13	None	add
193	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  iPivotYear));  [CE]  no  suitable  method  found  for  computeMillis(boolean,Integer)  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  iPivotYear));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  iPivotYear));	  	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,Integer)	13	None	add
194	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  message));  [CE]  cannot  find  symbol  message  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  message));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  message));	  	non-compiled	[CE]  cannot  find  symbol  message	13	None	add
195	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(chrono.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(chrono.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(chrono.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	13	None	add
196	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  parsedZone!=  null)  {  [CE]  cannot  find  symbol  parsedZone  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  parsedZone!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  parsedZone!=  null)  {	  }    else    if(iZone!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  parsedZone	31	None	replace
197	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iChrono!=  null)  {	  }    else    if(iZone!=    null)    {    	compilable	  [FE]  AssertionFailedError  	31	7	replace
198	[BUG]  [BUGGY]  }  else  if(iChrono!=  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iChrono!=  null)  {	  }    else    if(iZone!=    null)    {    	compilable	  [FE]  AssertionFailedError  	31	7	replace
199	[BUG]  [BUGGY]  }  else  if(iLocale!=  locale)  {  [CE]  cannot  find  symbol  locale  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  locale)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  locale)  {	  }    else    if(iZone!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  locale	31	None	replace
200	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iPivotYear!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iPivotYear!=  null)  {	  }    else    if(iZone!=    null)    {    	compilable	  [FE]  AssertionFailedError  	31	7	replace
201	[BUG]  [BUGGY]  }  else  if(iPivotYear!=  null)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iPivotYear!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iPivotYear!=  null)  {	  }    else    if(iZone!=    null)    {    	compilable	  [FE]  AssertionFailedError  	31	7	replace
202	[BUG]  [BUGGY]  }  else  if(parsedZone!=  null)  {  [CE]  cannot  find  symbol  parsedZone  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(parsedZone!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(parsedZone!=  null)  {	  }    else    if(iZone!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  parsedZone	31	None	replace
203	[BUG]  [BUGGY]  }  else  if(iDefaultYear!=  null)  {  [CE]  incomparable  types:  int  and  <null>  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iDefaultYear!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iDefaultYear!=  null)  {	  }    else    if(iZone!=    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	31	None	replace
204	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {	  }    else    if(iZone!=    null)    {    	compilable	  [FE]  AssertionFailedError  	31	7	replace
205	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {	  }    else    if(iZone!=    null)    {    	compilable	  [FE]  AssertionFailedError  	31	7	replace
206	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  parsedZone  ==  null)  {  [CE]  cannot  find  symbol  parsedZone  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  parsedZone  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  parsedZone  ==  null)  {	  }    else    if(iZone!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  parsedZone	31	None	replace
207	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text));	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    chrono    =    chrono.withZone(parsedOffset);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	38	None	replace
208	[BUG]  [BUGGY]  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text));  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    chrono    =    chrono.withZone(parsedOffset);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	38	None	replace
209	[BUG]  [BUGGY]  if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text));  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    chrono    =    chrono.withZone(parsedOffset);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	38	None	replace
210	[BUG]  [BUGGY]  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text));	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    chrono    =    chrono.withZone(parsedOffset);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	38	None	replace
211	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    chrono    =    chrono.withZone(parsedOffset);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	38	None	replace
212	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset,  text);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset,  text);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset,  text);  instant.setMillis(bucket.computeMillis(false,  text));  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    chrono    =    chrono.withZone(parsedOffset);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	38	None	replace
213	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	30	7	add
214	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	30	7	add
215	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iZone!=    null)    {    }  else  if(iZone  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	30	7	add
216	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone  ==  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(iZone  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	30	7	add
217	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());	  	compilable	  [FE]  AssertionFailedError  	30	7	add
218	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());	  	compilable	  [FE]  AssertionFailedError  	30	7	add
219	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone  >=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone  >=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(iZone  >=  null)  {	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	30	None	add
220	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null  ||  iZone!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null  ||  iZone!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	30	7	add
221	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null  ||  iZone!=  null)  {  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null  ||  iZone!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null  ||  iZone!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	30	7	add
222	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null  ||  iZone  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null  ||  iZone  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	30	7	add
223	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null  ||  iZone  ==  null)  {  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null  ||  iZone  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null  ||  iZone  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	30	7	add
224	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(selectChronology(iChrono))  {  [CE]  incompatible  types  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(selectChronology(iChrono))  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(selectChronology(iChrono))  {	  	non-compiled	[CE]  incompatible  types	30	None	add
225	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  chrono  =  chrono.withZone(parsedZone.getZone());  [CE]  cannot  find  symbol  parsedZone  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  chrono  =  chrono.withZone(parsedZone.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null)  {  chrono  =  chrono.withZone(parsedZone.getZone());	  	non-compiled	[CE]  cannot  find  symbol  parsedZone	30	None	add
226	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(selectChronology(iZone))  {  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(selectChronology(iZone))  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(selectChronology(iZone))  {	  	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	30	None	add
227	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null  ||  instant.getZone()!=  parsedZone)  {  [CE]  cannot  find  symbol  parsedZone  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null  ||  instant.getZone()!=  parsedZone)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null  ||  instant.getZone()!=  parsedZone)  {	  	non-compiled	[CE]  cannot  find  symbol  parsedZone	30	None	add
228	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getOffsetZone()!=  null)  {  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getOffsetZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  bucket.getOffsetZone()!=  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
229	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iOffsetParsed  &&  bucket.getZone()  ==  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	2	7	replace
230	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()  ==  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  bucket.getZone()  ==  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	2	7	replace
231	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getLocalMillis()!=  null)  {  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getLocalMillis()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  bucket.getLocalMillis()!=  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
232	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getChronology()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iOffsetParsed  &&  bucket.getChronology()!=  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	2	7	replace
233	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getChronology()!=  null)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getChronology()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  bucket.getChronology()!=  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	2	7	replace
234	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getInteger()!=  null)  {  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getInteger()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  bucket.getInteger()!=  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
235	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getPivotYear()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iOffsetParsed  &&  bucket.getPivotYear()!=  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	2	7	replace
236	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getPivotYear()!=  null)  {  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getPivotYear()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  bucket.getPivotYear()!=  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	2	7	replace
237	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  ||  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iOffsetParsed  ||  bucket.getZone()!=  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	2	7	replace
238	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  ||  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  ||  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  ||  bucket.getZone()!=  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	2	7	replace
239	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  newPos);  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  newPos);	      instant.setMillis(bucket.computeMillis(false,    newPos));    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
240	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  position));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  position));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(false,  text,  position));	      instant.setMillis(bucket.computeMillis(false,    newPos));    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
241	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos),  text);  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos),  text);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos),  text);	      instant.setMillis(bucket.computeMillis(false,    newPos));    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
242	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	iChrono  =  parser.parseInto(bucket,  text,  position);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
243	[BUG]  [BUGGY]  if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  }  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  }	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
244	[BUG]  [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
245	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  newPos);  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	iChrono  =  parser.parseInto(bucket,  text,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
246	[BUG]  [BUGGY]  Parser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  Parser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	Parser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
247	[BUG]  [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
248	[BUG]  [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  newPos);  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
249	[BUG]  [BUGGY]  iChrono  =  chrono.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  iChrono  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	iChrono  =  chrono.parseInto(bucket,  text,  position);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
250	[BUG]  [BUGGY]  }  else  if(iLocale!=  parsedOffset  &&  bucket.getZone()!=  null)  {  [CE]  cannot  find  symbol  parsedOffset  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  parsedOffset  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  parsedOffset  &&  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    locale    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  parsedOffset	7	None	replace
251	[BUG]  [BUGGY]  }  else  if(iLocale!=  text  &&  bucket.getZone()!=  null)  {  [CE]  incomparable  types:  Locale  and  String  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  text  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  text  &&  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    locale    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  incomparable  types:  Locale  and  String	7	None	replace
252	[BUG]  [BUGGY]  }  else  if(iLocale!=  instantLocale  &&  bucket.getZone()!=  null)  {  [CE]  cannot  find  symbol  instantLocale  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  instantLocale  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  instantLocale  &&  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    locale    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  instantLocale	7	None	replace
253	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  iLocale  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iLocale!=  iLocale  &&  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    locale    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	7	7	replace
254	[BUG]  [BUGGY]  }  else  if(iLocale!=  iLocale  &&  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  iLocale  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  iLocale  &&  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    locale    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	7	7	replace
255	[BUG]  [BUGGY]  }  else  if(iLocale!=  context.iLocale  &&  bucket.getZone()!=  null)  {  [CE]  cannot  find  symbol  context  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  context.iLocale  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  context.iLocale  &&  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    locale    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  context	7	None	replace
256	[BUG]  [BUGGY]  }  else  if(iLocale!=  tempLocale  &&  bucket.getZone()!=  null)  {  [CE]  cannot  find  symbol  tempLocale  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  tempLocale  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  tempLocale  &&  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    locale    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  tempLocale	7	None	replace
257	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	16	7	add
258	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	16	7	add
259	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	16	None	add
260	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	16	None	add
261	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  long  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  long  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    long  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	16	None	add
262	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	16	7	add
263	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	16	7	add
264	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iPivotYear  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iPivotYear  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	16	None	add
265	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  instant.setPos(parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  ')'  expected  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  instant.setPos(parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    instant.setPos(parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  ')'  expected	16	None	add
266	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    newPos  =  parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	16	7	add
267	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    newPos  =  parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	16	7	add
268	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iDefaultYear  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iDefaultYear  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iDefaultYear  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	16	None	add
269	[BUG]  [BUGGY]  instant.setChrono(bucket.getChronology());  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setChrono(bucket.getChronology());  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setChrono(bucket.getChronology());	      iChrono    =    bucket.getChronology();    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
270	[BUG]  [BUGGY]  Chronology  iChrono  =  bucket.getChronology();  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  Chronology  iChrono  =  bucket.getChronology();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	Chronology  iChrono  =  bucket.getChronology();	      iChrono    =    bucket.getChronology();    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
271	[BUG]  [BUGGY]  instant.getChronology();  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.getChronology();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.getChronology();	      iChrono    =    bucket.getChronology();    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
272	[BUG]  [BUGGY]  instant  =  bucket.getChronology();  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant  =  bucket.getChronology();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant  =  bucket.getChronology();	      iChrono    =    bucket.getChronology();    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
273	[BUG]  [BUGGY]  iChrono  =  instant.getChronology();  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  iChrono  =  instant.getChronology();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	iChrono  =  instant.getChronology();	      iChrono    =    bucket.getChronology();    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
274	[BUG]  [BUGGY]  chrono  =  bucket.getChronology();  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  chrono  =  bucket.getChronology();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	chrono  =  bucket.getChronology();	      iChrono    =    bucket.getChronology();    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
275	[BUG]  [BUGGY]  instant.setChrono(bucket.getChronology();  [CE]  ')'  expected  [FE]                        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setChrono(bucket.getChronology();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setChrono(bucket.getChronology();	      iChrono    =    bucket.getChronology();    	non-compiled	[CE]  ')'  expected	28	None	replace
276	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono  ==  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iChrono  ==  null  &&  bucket.getZone()!=  null)  {	  }    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	33	7	replace
277	[BUG]  [BUGGY]  }  else  if(iChrono  ==  null  &&  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono  ==  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iChrono  ==  null  &&  bucket.getZone()!=  null)  {	  }    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	33	7	replace
278	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iChrono!=  null  &&  bucket.getZone()  ==  null)  {	  }    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	33	7	replace
279	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()  ==  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iChrono!=  null  &&  bucket.getZone()  ==  null)  {	  }    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	33	7	replace
280	[BUG]  [BUGGY]  }  else  if(iParsed  &&  bucket.getZone()!=  null)  {  [CE]  cannot  find  symbol  iParsed  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iParsed  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iParsed  &&  bucket.getZone()!=  null)  {	  }    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  iParsed	33	None	replace
281	[BUG]  [BUGGY]  }  else  if(iPivotParsed  &&  bucket.getZone()!=  null)  {  [CE]  cannot  find  symbol  iPivotParsed  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iPivotParsed  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iPivotParsed  &&  bucket.getZone()!=  null)  {	  }    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  iPivotParsed	33	None	replace
282	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	1	7	add
283	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	1	7	add
284	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	1	7	add
285	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()  ==  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	1	7	add
286	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()  >=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()  >=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()  >=  null)  {	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	1	None	add
287	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());	  	compilable	  [FE]  AssertionFailedError  	1	7	add
288	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());	  	compilable	  [FE]  AssertionFailedError  	1	7	add
289	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  parsedZone.getZone()!=  null)  {  [CE]  cannot  find  symbol  parsedZone  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  parsedZone.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  parsedZone.getZone()!=  null)  {	  	non-compiled	[CE]  cannot  find  symbol  parsedZone	1	None	add
290	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()  >>  null)  {  [CE]  bad  operand  types  for  binary  operator  '>>'  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()  >>  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()  >>  null)  {	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>>'	1	None	add
291	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()  [Delete]  null)  {  [CE]  ')'  expected  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()  [Delete]  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()  [Delete]  null)  {	  	non-compiled	[CE]  ')'  expected	1	None	add
292	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()  [BUGGY]  null)  {  [CE]  ')'  expected  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()  [BUGGY]  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()  [BUGGY]  null)  {	  	non-compiled	[CE]  ')'  expected	1	None	add
293	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  ||  parsedZone.getZone()  ==  null)  {  [CE]  cannot  find  symbol  parsedZone  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  ||  parsedZone.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  ||  parsedZone.getZone()  ==  null)  {	  	non-compiled	[CE]  cannot  find  symbol  parsedZone	1	None	add
294	[BUG]  [BUGGY]  }  else  if(selectChronology(bucket)&&  bucket.getZone()!=  null)  {  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(selectChronology(bucket)&&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(selectChronology(bucket)&&  bucket.getZone()!=  null)  {	  }    else    if(selectChronology(chrono)&&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	10	None	replace
295	[BUG]  [BUGGY]  }  else  if(selectChronology(instantLocal)&&  bucket.getZone()!=  null)  {  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(selectChronology(instantLocal)&&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(selectChronology(instantLocal)&&  bucket.getZone()!=  null)  {	  }    else    if(selectChronology(chrono)&&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	10	None	replace
296	[BUG]  [BUGGY]  }  else  if(selectChronology(bucket.getZone())&&  bucket.getZone()!=  null)  {  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(selectChronology(bucket.getZone())&&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(selectChronology(bucket.getZone())&&  bucket.getZone()!=  null)  {	  }    else    if(selectChronology(chrono)&&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	10	None	replace
297	[BUG]  [BUGGY]  }  else  if(selectChronology(chrono)||  bucket.getZone()!=  null)  {  [CE]  bad  operand  types  for  binary  operator  '||'  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(selectChronology(chrono)||  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(selectChronology(chrono)||  bucket.getZone()!=  null)  {	  }    else    if(selectChronology(chrono)&&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '||'	10	None	replace
298	[BUG]  [BUGGY]  }  else  if(selectChronology(bucket)&&  chrono.getZone()!=  null)  {  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(selectChronology(bucket)&&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(selectChronology(bucket)&&  chrono.getZone()!=  null)  {	  }    else    if(selectChronology(chrono)&&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	10	None	replace
299	[BUG]  [BUGGY]  }  else  if(selectChronology(chrono)&&  instant.getZone()!=  null)  {  [CE]  bad  operand  types  for  binary  operator  '&&'  [FE]                              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(selectChronology(chrono)&&  instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(selectChronology(chrono)&&  instant.getZone()!=  null)  {	  }    else    if(selectChronology(chrono)&&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '&&'	10	None	replace
300	[BUG]  [BUGGY]  }  else  if(selectChronology(chrono)&&  bucket.getZone()  ==  null)  {  [CE]  bad  operand  types  for  binary  operator  '&&'  [FE]                                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(selectChronology(chrono)&&  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(selectChronology(chrono)&&  bucket.getZone()  ==  null)  {	  }    else    if(selectChronology(chrono)&&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '&&'	10	None	replace
301	[BUG]  [BUGGY]  }  else  if(selectChronology(chrono)&&  bucket.getOffset()!=  null)  {  [CE]  incomparable  types:  int  and  <null>  [FE]                                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(selectChronology(chrono)&&  bucket.getOffset()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(selectChronology(chrono)&&  bucket.getOffset()!=  null)  {	  }    else    if(selectChronology(chrono)&&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	10	None	replace
302	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        newPos    =    parser.parseInto(bucket,    text,    position);    newPos  =  parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	22	7	add
303	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    newPos  =  parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	22	7	add
304	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  int  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  int  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    int  newPos  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	add
305	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        newPos    =    parser.parseInto(bucket,    text,    position);    newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	22	7	add
306	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	22	7	add
307	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  iPivotYear  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  iPivotYear  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    iPivotYear  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	22	None	add
308	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  assign  a  value  to  final  variable  iLocale  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iLocale	22	None	add
309	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  iPivotYear  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  iPivotYear  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    iPivotYear  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	22	None	add
310	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  Integer  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  Integer  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    Integer  newPos  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	add
311	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));	  	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)	22	None	add
312	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  iDefaultYear  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  iDefaultYear  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    newPos  =  parser.parseInto(bucket,  text,  position);  iDefaultYear  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	22	None	add
313	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  chrono!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iOffsetParsed  &&  chrono!=  null)  {	  }    else    if(chrono!=    null)    {    	compilable	  [FE]  AssertionFailedError  	49	7	replace
314	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  chrono!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  chrono!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  chrono!=  null)  {	  }    else    if(chrono!=    null)    {    	compilable	  [FE]  AssertionFailedError  	49	7	replace
315	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(instant!=  null)  {	  }    else    if(chrono!=    null)    {    	compilable	  [FE]  AssertionFailedError  	49	7	replace
316	[BUG]  [BUGGY]  }  else  if(instant!=  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(instant!=  null)  {	  }    else    if(chrono!=    null)    {    	compilable	  [FE]  AssertionFailedError  	49	7	replace
317	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iLocale!=  null)  {	  }    else    if(chrono!=    null)    {    	compilable	  [FE]  AssertionFailedError  	49	7	replace
318	[BUG]  [BUGGY]  }  else  if(iLocale!=  null)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  null)  {	  }    else    if(chrono!=    null)    {    	compilable	  [FE]  AssertionFailedError  	49	7	replace
319	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  iChrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iLocale!=  null  &&  iChrono.getZone()!=  null)  {	  }    else    if(iChrono.getZone()!=    null)    {    [timeout]    	compilable	  [FE]  NullPointerException  	5	7	replace
320	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  iChrono.getZone()!=  null)  {  [FE]  NullPointerException  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  iChrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  null  &&  iChrono.getZone()!=  null)  {	  }    else    if(iChrono.getZone()!=    null)    {    [timeout]    	compilable	  [FE]  NullPointerException  	5	7	replace
321	[BUG]  [BUGGY]  }  else  if(iChrono.getZone()  ==  null)  {  [timeout]  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iChrono.getZone()  ==  null)  {	  }    else    if(iChrono.getZone()!=    null)    {    [timeout]    	non-compiled	[timeout]	5	None	replace
322	[BUG]  [BUGGY]  }  else  if(iPivotYear!=  null  &&  iChrono.getZone()!=  null)  {  [timeout]  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iPivotYear!=  null  &&  iChrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iPivotYear!=  null  &&  iChrono.getZone()!=  null)  {	  }    else    if(iChrono.getZone()!=    null)    {    [timeout]    	non-compiled	[timeout]	5	None	replace
323	[BUG]  [BUGGY]  }  else  if(iZone.getZone()!=  null)  {  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iZone.getZone()!=  null)  {	  }    else    if(iChrono.getZone()!=    null)    {    [timeout]    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
324	[BUG]  [BUGGY]  }  else  if(iChrono.getType()  ==  Token.CATCH  ||  iChrono.getZone()!=  null)  {  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono.getType()  ==  Token.CATCH  ||  iChrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iChrono.getType()  ==  Token.CATCH  ||  iChrono.getZone()!=  null)  {	  }    else    if(iChrono.getZone()!=    null)    {    [timeout]    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
325	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  NullPointerException  	36	8	add
326	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [FE]  NullPointerException  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  NullPointerException  	36	8	add
327	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]      NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  NullPointerException  	36	8	add
328	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [FE]  NullPointerException  [FE]      NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  ==  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  NullPointerException  	36	8	add
329	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [timeout]  [FE]        NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	non-compiled	[timeout]	36	None	add
330	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  newPos  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [timeout]  [FE]          NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  newPos  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  int  newPos  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	non-compiled	[timeout]	36	None	add
331	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >>  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  incompatible  types  [FE]            NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >>  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >>  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	non-compiled	[CE]  incompatible  types	36	None	add
332	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]              NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }	  	compilable	  [FE]  NullPointerException  	36	8	add
333	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  [FE]  NullPointerException  [FE]              NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }	  	compilable	  [FE]  NullPointerException  	36	8	add
334	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  <  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [timeout]  [FE]                NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  <  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  <  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	non-compiled	[timeout]	36	None	add
335	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [timeout]  [FE]                  NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[timeout]	36	None	add
336	[BUG]  [BUGGY]  Integer  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));  [CE]  illegal  start  of  type  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  Integer  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	Integer  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  newPos));	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	37	None	replace
337	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
338	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  newPos));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  newPos));	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
339	[BUG]  [BUGGY]  Integer  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  Integer  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	Integer  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
340	[BUG]  [BUGGY]  Integer  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  newPos));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  Integer  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	Integer  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  newPos));	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
341	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text,  newPos));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(true,  text,  newPos));	      instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
342	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos,  text));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(true,  newPos,  text));	      instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
343	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos,  position));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos,  position));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(true,  newPos,  position));	      instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
344	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  position,  newPos));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  position,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(true,  position,  newPos));	      instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
345	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  iLocale,  newPos));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  iLocale,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(true,  iLocale,  newPos));	      instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
346	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos,  iLocale));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos,  iLocale));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(true,  newPos,  iLocale));	      instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
347	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  iChrono  =  parsedZone;  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  iChrono  =  parsedZone;  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,  text));  iChrono  =  parsedZone;	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	11	None	add
348	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(!iOffsetParsed  &&  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(!iOffsetParsed  &&  bucket.getZone()  ==  null)  {	  }    else    if(!iOffsetParsed    &&    bucket.getZone()!=    null)    {    [timeout]    	compilable	  [FE]  AssertionFailedError  	6	7	replace
349	[BUG]  [BUGGY]  }  else  if(!iOffsetParsed  &&  bucket.getZone()  ==  null)  {  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(!iOffsetParsed  &&  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(!iOffsetParsed  &&  bucket.getZone()  ==  null)  {	  }    else    if(!iOffsetParsed    &&    bucket.getZone()!=    null)    {    [timeout]    	compilable	  [FE]  AssertionFailedError  	6	7	replace
350	[BUG]  [BUGGY]  }  else  if(!iOffsetParsed  &&  bucket.getLocalMillis()!=  null)  {  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(!iOffsetParsed  &&  bucket.getLocalMillis()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(!iOffsetParsed  &&  bucket.getLocalMillis()!=  null)  {	  }    else    if(!iOffsetParsed    &&    bucket.getZone()!=    null)    {    [timeout]    	non-compiled	[CE]  cannot  find  symbol	6	None	replace
351	[BUG]  [BUGGY]  }  else  if(!iOffsetParsed  &&  bucket.getOffsetZone()!=  null)  {  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(!iOffsetParsed  &&  bucket.getOffsetZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(!iOffsetParsed  &&  bucket.getOffsetZone()!=  null)  {	  }    else    if(!iOffsetParsed    &&    bucket.getZone()!=    null)    {    [timeout]    	non-compiled	[CE]  cannot  find  symbol	6	None	replace
352	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()  >=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()  >=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  bucket.getZone()  >=  null)  {	  }    else    if(!iOffsetParsed    &&    bucket.getZone()!=    null)    {    [timeout]    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	6	None	replace
353	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	3	7	add
354	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	3	7	add
355	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  bucket.getZone()  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	3	7	add
356	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()  ==  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  bucket.getZone()  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	3	7	add
357	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale  ==  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale  ==  null  &&  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	3	7	add
358	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale  ==  null  &&  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale  ==  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale  ==  null  &&  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	3	7	add
359	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale  >=  null  &&  bucket.getZone()!=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale  >=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale  >=  null  &&  bucket.getZone()!=  null)  {	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	3	None	add
360	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()  >=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()  >=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  bucket.getZone()  >=  null)  {	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	3	None	add
361	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());	  	compilable	  [FE]  AssertionFailedError  	3	7	add
362	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());	  	compilable	  [FE]  AssertionFailedError  	3	7	add
363	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()  >>  null)  {  [CE]  bad  operand  types  for  binary  operator  '>>'  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()  >>  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  bucket.getZone()  >>  null)  {	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>>'	3	None	add
364	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null  ||  iLocale!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null  ||  iLocale!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	3	7	add
365	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null  ||  iLocale!=  null)  {  [FE]  AssertionFailedError  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null  ||  iLocale!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null  ||  iLocale!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	3	7	add
366	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  ||  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale!=  null  ||  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	3	7	add
367	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  ||  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  ||  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale!=  null  ||  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	3	7	add
368	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale  >>  null  &&  bucket.getZone()!=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>>'  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale  >>  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale  >>  null  &&  bucket.getZone()!=  null)  {	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>>'	3	None	add
369	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	24	7	add
370	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	24	7	add
371	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	add
372	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	24	7	add
373	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	24	7	add
374	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	add
375	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  long  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  long  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    long  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	add
376	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  iPivotYear  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  iPivotYear  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    iPivotYear  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	24	None	add
377	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	add
378	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  iDefaultYear  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  iDefaultYear  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    iDefaultYear  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	24	None	add
379	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  assign  a  value  to  final  variable  iLocale  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iLocale	24	None	add
380	[BUG]  [BUGGY]  long  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  long  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	long  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));	      int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
381	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetParsed();  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetParsed();  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetParsed();  instant.setMillis(bucket.computeMillis(false,  text));	      int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
382	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetParsedInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetParsedInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetParsedInteger();  instant.setMillis(bucket.computeMillis(false,  text));	      int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
383	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  newPos));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  newPos));	      int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
384	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));	      int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
385	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  newPos));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(false,  text,  newPos));	      instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  illegal  start  of  type	15	None	replace
386	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos,  text));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos,  text));	      instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  illegal  start  of  type	15	None	replace
387	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos,  position));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos,  position));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos,  position));	      instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  illegal  start  of  type	15	None	replace
388	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos,  iLocale));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos,  iLocale));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos,  iLocale));	      instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  illegal  start  of  type	15	None	replace
389	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }	  	compilable	  [FE]  NullPointerException  	45	8	add
390	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  [FE]  NullPointerException  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }	  	compilable	  [FE]  NullPointerException  	45	8	add
391	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]      NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }	  	compilable	  [FE]  NullPointerException  	45	8	add
392	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [FE]  NullPointerException  [FE]      NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }	  	compilable	  [FE]  NullPointerException  	45	8	add
393	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.set  [CE]  not  a  statement  [FE]        NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.set  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.set	  	non-compiled	[CE]  not  a  statement	45	None	add
394	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(instantLocal);  }  [CE]  method  setChronology  in  interface  ReadWritableInstant  cannot  be  applied  to  given  types;  [FE]          NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(instantLocal);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(instantLocal);  }	  	non-compiled	[CE]  method  setChronology  in  interface  ReadWritableInstant  cannot  be  applied  to  given  types;	45	None	add
395	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.  [CE]  <identifier>  expected  [FE]            NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.	  	non-compiled	[CE]  <identifier>  expected	45	None	add
396	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(instantLo  [CE]  ')'  expected  [FE]              NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(instantLo  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(instantLo	  	non-compiled	[CE]  ')'  expected	45	None	add
397	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]                NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(null);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(null);  }	  	compilable	  [FE]  NullPointerException  	45	8	add
398	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(null);  }  [FE]  NullPointerException  [FE]                NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(null);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(null);  }	  	compilable	  [FE]  NullPointerException  	45	8	add
399	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(parsedZone);  }  [CE]  cannot  find  symbol  parsedZone  [FE]                  NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(parsedZone);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(parsedZone);  }	  	non-compiled	[CE]  cannot  find  symbol  parsedZone	45	None	add
400	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	32	7	add
401	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	32	7	add
402	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono!=  null  &&  bucket.getZone()  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	32	7	add
403	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()  ==  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono!=  null  &&  bucket.getZone()  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	32	7	add
404	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono  ==  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono  ==  null  &&  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	32	7	add
405	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono  ==  null  &&  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono  ==  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono  ==  null  &&  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	32	7	add
406	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono  >=  null  &&  bucket.getZone()!=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono  >=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono  >=  null  &&  bucket.getZone()!=  null)  {	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	32	None	add
407	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());	  	compilable	  [FE]  AssertionFailedError  	32	7	add
408	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());	  	compilable	  [FE]  AssertionFailedError  	32	7	add
409	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()  >=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()  >=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono!=  null  &&  bucket.getZone()  >=  null)  {	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	32	None	add
410	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null  ||  iChrono.equals(bucket.getZone()))  {  [timeout]  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null  ||  iChrono.equals(bucket.getZone()))  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null  ||  iChrono.equals(bucket.getZone()))  {	  	non-compiled	[timeout]	32	None	add
411	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getLocale()!=  null)  {  [timeout]  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getLocale()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono!=  null  &&  bucket.getLocale()!=  null)  {	  	non-compiled	[timeout]	32	None	add
412	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  ||  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono!=  null  ||  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	32	7	add
413	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  ||  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  ||  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono!=  null  ||  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	32	7	add
414	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()  >>  null)  {  [CE]  bad  operand  types  for  binary  operator  '>>'  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()  >>  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono!=  null  &&  bucket.getZone()  >>  null)  {	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>>'	32	None	add
415	[BUG]  [BUGGY]  ble  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  ble  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	ble  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	37	None	replace
416	[BUG]  [BUGGY]  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]      NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	37	None	replace
417	[BUG]  [BUGGY]  }  else  if(iLocale!=  locale  &&  iChrono.getZone()!=  null)  {  [CE]  cannot  find  symbol  locale  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  locale  &&  iChrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  locale  &&  iChrono.getZone()!=  null)  {	  }    else    if(iChrono.getZone()!=    null)    {    [timeout]    	non-compiled	[CE]  cannot  find  symbol  locale	5	None	replace
418	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text  [CE]  ')'  expected  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    chrono    =    chrono.withZone(parsedOffset);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  ')'  expected	38	None	replace
419	[BUG]  [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    chrono    =    chrono.withZone(parsedOffset);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	38	None	replace
420	[BUG]  [BUGGY]  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text  [CE]  ')'  expected  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    chrono    =    chrono.withZone(parsedOffset);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  ')'  expected	38	None	replace
421	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  chrono);  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  chrono);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	newPos  =  parser.parseInto(bucket,  text,  position,  chrono);	      newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
422	[BUG]  [BUGGY]      iChrono  =  selectChronology(bucket);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      iChrono  =  selectChronology(bucket);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        iChrono  =  selectChronology(bucket);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	11	None	add
423	[BUG]  [BUGGY]      DateTimeParser  parser  =  bucket.getParser();  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      DateTimeParser  parser  =  bucket.getParser();  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        DateTimeParser  parser  =  bucket.getParser();	  	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	11	None	add
424	[BUG]  [BUGGY]      Chronology  chrono  =  selectChronology(bucket);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      Chronology  chrono  =  selectChronology(bucket);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        Chronology  chrono  =  selectChronology(bucket);	  	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	11	None	add
425	[BUG]  [BUGGY]      iChrono  =  selectChronology(bucket.getChronology());  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      iChrono  =  selectChronology(bucket.getChronology());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        iChrono  =  selectChronology(bucket.getChronology());	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	11	None	add
426	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      parsedOffset  =  parsedZone.getOffset(parsedOffset);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	        parsedOffset  =  parsedZone.getOffset(parsedOffset);	  	compilable	  [FE]  AssertionFailedError  	11	7	add
427	[BUG]  [BUGGY]      parsedOffset  =  parsedZone.getOffset(parsedOffset);  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      parsedOffset  =  parsedZone.getOffset(parsedOffset);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        parsedOffset  =  parsedZone.getOffset(parsedOffset);	  	compilable	  [FE]  AssertionFailedError  	11	7	add
428	[BUG]  [BUGGY]      DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        DateTimeParser  parser  =  iPrinter.createChronology(bucket,  text,  position);	  	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	11	None	add
429	[BUG]  [BUGGY]      iChrono  =  selectChronology(chrono);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      iChrono  =  selectChronology(chrono);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        iChrono  =  selectChronology(chrono);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	11	None	add
430	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instant);  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instant);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.getParser(instant);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
431	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(instant);  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.parse(instant);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.parse(instant);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
432	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(instant,  newPos);  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.parse(instant,  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.parse(instant,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
433	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(instant,  text);  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.parse(instant,  text);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.parse(instant,  text);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
434	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(newPos,  text);  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.parse(newPos,  text);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.parse(newPos,  text);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
435	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()  [BUGGY]  null)  {  [CE]  ')'  expected  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()  [BUGGY]  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  bucket.getZone()  [BUGGY]  null)  {	  	non-compiled	[CE]  ')'  expected	3	None	add
436	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getName()!=  null)  {  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getName()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  bucket.getName()!=  null)  {	  	non-compiled	[CE]  cannot  find  symbol	3	None	add
437	[BUG]  [BUGGY]  }  else  if(iLocale!=  context  &&  bucket.getZone()!=  null)  {  [CE]  cannot  find  symbol  context  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  context  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  context  &&  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    locale    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  context	7	None	replace
438	[BUG]  [BUGGY]  }  else  if(iLocale!=  iPivotYear  &&  bucket.getZone()!=  null)  {  [CE]  incomparable  types:  Locale  and  Integer  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  iPivotYear  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  iPivotYear  &&  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    locale    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  incomparable  types:  Locale  and  Integer	7	None	replace
439	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(instant.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	8	7	add
440	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(instant.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(instant.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	8	7	add
441	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  initial  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  initial	8	None	add
442	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  [CE]  cannot  find  symbol  initial  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  initial	8	None	add
443	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  instant  =  chrono.withZone(bucket.getZone());  }  else  if(instant.getZone()!=  null)  {  [CE]  incompatible  types  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  instant  =  chrono.withZone(bucket.getZone());  }  else  if(instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null)  {  instant  =  chrono.withZone(bucket.getZone());  }  else  if(instant.getZone()!=  null)  {	  	non-compiled	[CE]  incompatible  types	8	None	add
444	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setChronology(iChrono);  [CE]  cannot  find  symbol  initial  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setChronology(iChrono);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setChronology(iChrono);	  	non-compiled	[CE]  cannot  find  symbol  initial	8	None	add
445	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setPivotYear(iPivotYear);  [CE]  cannot  find  symbol  initial  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setPivotYear(iPivotYear);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setPivotYear(iPivotYear);	  	non-compiled	[CE]  cannot  find  symbol  initial	8	None	add
446	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getOffsetChronology()!=  null)  {  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getOffsetChronology()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  bucket.getOffsetChronology()!=  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
447	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getOffsetZone()  ==  null)  {  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getOffsetZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  bucket.getOffsetZone()  ==  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
448	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getLocale()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iOffsetParsed  &&  bucket.getLocale()!=  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	2	7	replace
449	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getLocale()!=  null)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getLocale()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  bucket.getLocale()!=  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	2	7	replace
450	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getOffset()!=  null)  {  [CE]  incomparable  types:  int  and  <null>  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getOffset()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  bucket.getOffset()!=  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	2	None	replace
451	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getOffsetMillis()!=  null)  {  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getOffsetMillis()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  bucket.getOffsetMillis()!=  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
452	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  0));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  0));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(true,  0));	      instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
453	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text),  newPos);  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text),  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(true,  text),  newPos);	      instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
454	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  null));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  null));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(true,  null));	      instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
455	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	48	7	add
456	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	48	7	add
457	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(chrono!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(chrono!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	48	7	add
458	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(chrono!=  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(chrono!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(chrono!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	48	7	add
459	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());  [CE]  >  expected  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());	  	non-compiled	[CE]  >  expected	48	None	add
460	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  System.arraycopy(iChrono,  0,  newPos,  parsedOffset,  parsedOffset);  [CE]  cannot  find  symbol  parsedOffset  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  System.arraycopy(iChrono,  0,  newPos,  parsedOffset,  parsedOffset);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  System.arraycopy(iChrono,  0,  newPos,  parsedOffset,  parsedOffset);	  	non-compiled	[CE]  cannot  find  symbol  parsedOffset	48	None	add
461	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  System.arraycopy(bucket,  0,  newPos,  0,  parsedOffset,  parsedOffset);  [CE]  cannot  find  symbol  parsedOffset  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  System.arraycopy(bucket,  0,  newPos,  0,  parsedOffset,  parsedOffset);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  System.arraycopy(bucket,  0,  newPos,  0,  parsedOffset,  parsedOffset);	  	non-compiled	[CE]  cannot  find  symbol  parsedOffset	48	None	add
462	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	48	7	add
463	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	48	7	add
464	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  System.arraycopy(iChrono,  0,  newPos,  text,  position);  [CE]  method  arraycopy  in  class  System  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  System.arraycopy(iChrono,  0,  newPos,  text,  position);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  System.arraycopy(iChrono,  0,  newPos,  text,  position);	  	non-compiled	[CE]  method  arraycopy  in  class  System  cannot  be  applied  to  given  types;	48	None	add
465	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  Instant  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  Instant  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    Instant  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  ';'  expected	20	None	add
466	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  If(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  If(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    If(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	non-compiled	[CE]  ';'  expected	40	None	add
467	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	1	7	add
468	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	1	7	add
469	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  initial  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  initial	1	None	add
470	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());  [CE]  >  expected  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());	  	non-compiled	[CE]  >  expected	1	None	add
471	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }	  	non-compiled	[CE]  illegal  start  of  type	1	None	add
472	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
473	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
474	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(iOffsetParsed  &&  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(iOffsetParsed  &&  bucket.getZone()  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	1	7	add
475	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(iOffsetParsed  &&  bucket.getZone()  ==  null)  {  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(iOffsetParsed  &&  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(iOffsetParsed  &&  bucket.getZone()  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	1	7	add
476	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  oldPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  oldPos  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  oldPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    oldPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  oldPos	16	None	add
477	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    int  newPos  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	16	None	add
478	[BUG]  [BUGGY]  int  parsedOffset  =  iChrono.getOffsetInteger();  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  iChrono.getOffsetInteger();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  iChrono.getOffsetInteger();	      int    parsedOffset    =    bucket.getOffsetInteger();    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
479	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetParsed(instantLocal);  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetParsed(instantLocal);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetParsed(instantLocal);	      int    parsedOffset    =    bucket.getOffsetInteger();    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
480	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos),  iLocale);  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos),  iLocale);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(true,  newPos),  iLocale);	      instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
481	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos  +  1));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  newPos  +  1));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(true,  newPos  +  1));	      instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
482	[BUG]  [BUGGY]  }  else  if(selectChronology(chrono)&&  bucket.getOffsetZone()!=  null)  {  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(selectChronology(chrono)&&  bucket.getOffsetZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(selectChronology(chrono)&&  bucket.getOffsetZone()!=  null)  {	  }    else    if(selectChronology(chrono)&&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
483	[BUG]  [BUGGY]  }  else  if(selectChronology(chrono)&&  bucket.getPivotYear()!=  null)  {  [CE]  bad  operand  types  for  binary  operator  '&&'  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(selectChronology(chrono)&&  bucket.getPivotYear()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(selectChronology(chrono)&&  bucket.getPivotYear()!=  null)  {	  }    else    if(selectChronology(chrono)&&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '&&'	10	None	replace
484	[BUG]  [BUGGY]  }  else  if(selectChronology(chrono)&&  bucket.getSelection()!=  null)  {  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(selectChronology(chrono)&&  bucket.getSelection()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(selectChronology(chrono)&&  bucket.getSelection()!=  null)  {	  }    else    if(selectChronology(chrono)&&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
485	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }	  	compilable	  [FE]  NullPointerException  	43	8	add
486	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [FE]  NullPointerException  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }	  	compilable	  [FE]  NullPointerException  	43	8	add
487	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  newPos  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  newPos  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  int  newPos  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }	  	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	43	None	add
488	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [CE]  cannot  find  symbol  parsedOffset  [FE]        NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }	  	non-compiled	[CE]  cannot  find  symbol  parsedOffset	43	None	add
489	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]          NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  long  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  long  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }	  	compilable	  [FE]  NullPointerException  	43	8	add
490	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  long  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [FE]  NullPointerException  [FE]          NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  long  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  long  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }	  	compilable	  [FE]  NullPointerException  	43	8	add
491	[BUG]  [BUGGY]  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
492	[BUG]  [BUGGY]  ble  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  ble  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	ble  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
493	[BUG]  [BUGGY]  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
494	[BUG]  [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(bucket.computeMillis(false,  text));  }	      instant.setMillis(bucket.computeMillis(false,    newPos));    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
495	[BUG]  [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(bucket.computeMillis(false,  newPos));  }  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(bucket.computeMillis(false,  newPos));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(bucket.computeMillis(false,  newPos));  }	      instant.setMillis(bucket.computeMillis(false,    newPos));    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
496	[BUG]  [BUGGY]  if(newPos!=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos!=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos!=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(bucket.computeMillis(false,  text));  }	      instant.setMillis(bucket.computeMillis(false,    newPos));    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
497	[BUG]  [BUGGY]  if(newPos!=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(bucket.computeMillis(false,  newPos));  }  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos!=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(bucket.computeMillis(false,  newPos));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos!=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(bucket.computeMillis(false,  newPos));  }	      instant.setMillis(bucket.computeMillis(false,    newPos));    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
498	[BUG]  [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(instantLocal.computeMillis(false,  newPos));  }  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(instantLocal.computeMillis(false,  newPos));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(instantLocal.computeMillis(false,  newPos));  }	      instant.setMillis(bucket.computeMillis(false,    newPos));    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
499	[BUG]  [BUGGY]  if(newPos!=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(instantLocal.computeMillis(false,  newPos));  }  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos!=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(instantLocal.computeMillis(false,  newPos));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos!=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(instantLocal.computeMillis(false,  newPos));  }	      instant.setMillis(bucket.computeMillis(false,    newPos));    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
500	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  If(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  ';'  expected  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  If(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    If(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	non-compiled	[CE]  ';'  expected	36	None	add
501	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]      NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  long  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  long  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  NullPointerException  	36	8	add
502	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  long  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [FE]  NullPointerException  [FE]      NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  long  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  long  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  NullPointerException  	36	8	add
503	[BUG]  [BUGGY]  if(iLocale  ==  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iLocale  ==  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iLocale  ==  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
504	[BUG]  [BUGGY]  if(iOffsetParsed)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iOffsetParsed)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iOffsetParsed)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
505	[BUG]  [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setParsed(true);  }  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setParsed(true);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setParsed(true);  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setParsed(true);    }    	non-compiled	[CE]  illegal  start  of  type	47	None	replace
506	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setPar  [CE]  not  a  statement  [FE]                        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setPar  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setPar	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setParsed(true);    }    	non-compiled	[CE]  not  a  statement	47	None	replace
507	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text),  newPos);  }  else  {  instant.setParsed(true);  }  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text),  newPos);  }  else  {  instant.setParsed(true);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text),  newPos);  }  else  {  instant.setParsed(true);  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setParsed(true);    }    	non-compiled	[CE]  illegal  start  of  type	47	None	replace
508	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setParsed  [CE]  not  a  statement  [FE]                            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setParsed  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setParsed	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setParsed(true);    }    	non-compiled	[CE]  not  a  statement	47	None	replace
509	[BUG]  [BUGGY]  if(iLocale!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  [CE]  'else'  without  'if'  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iLocale!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iLocale!=  null)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  'else'  without  'if'	17	None	replace
510	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(instant);  }  [CE]  method  setChronology  in  interface  ReadWritableInstant  cannot  be  applied  to  given  types;  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(instant);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(instant);  }	  	non-compiled	[CE]  method  setChronology  in  interface  ReadWritableInstant  cannot  be  applied  to  given  types;	45	None	add
511	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]      NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }	  	compilable	  [FE]  NullPointerException  	45	8	add
512	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  [FE]  NullPointerException  [FE]      NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }	  	compilable	  [FE]  NullPointerException  	45	8	add
513	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position  +  1);  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position  +  1);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position  +  1);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
514	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  newPos);  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
515	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position  +  newPos);  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position  +  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position  +  newPos);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
516	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  initial  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  initial	30	None	add
517	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  [CE]  cannot  find  symbol  initial  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  initial	30	None	add
518	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());  [CE]  >  expected  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());	  	non-compiled	[CE]  >  expected	30	None	add
519	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(iZone!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(iZone!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	30	7	add
520	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(iZone!=  null)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(iZone!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  else  if(iZone!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	30	7	add
521	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  initial  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol  initial	30	None	add
522	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setChronology(iChrono);  [CE]  cannot  find  symbol  initial  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setChronology(iChrono);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setChronology(iChrono);	  	non-compiled	[CE]  cannot  find  symbol  initial	30	None	add
523	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  iPivotYear  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  iPivotYear  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    iPivotYear  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	22	None	add
524	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  iLocale  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iLocale  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  iLocale  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    iLocale  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iLocale	22	None	add
525	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  long  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  long  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    long  newPos  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	add
526	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  iChrono.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  iChrono.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    newPos  =  iChrono.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  find  symbol	22	None	add
527	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iZone  ==  null)  {	  }    else    if(iZone!=    null)    {    	compilable	  [FE]  AssertionFailedError  	31	7	replace
528	[BUG]  [BUGGY]  }  else  if(iZone  ==  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iZone  ==  null)  {	  }    else    if(iZone!=    null)    {    	compilable	  [FE]  AssertionFailedError  	31	7	replace
529	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iChrono  ==  null)  {	  }    else    if(iZone!=    null)    {    	compilable	  [FE]  AssertionFailedError  	31	7	replace
530	[BUG]  [BUGGY]  }  else  if(iChrono  ==  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iChrono  ==  null)  {	  }    else    if(iZone!=    null)    {    	compilable	  [FE]  AssertionFailedError  	31	7	replace
531	[BUG]  [BUGGY]  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
532	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetParsed();  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetParsed();  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetParsed();  instant.setMillis(bucket.computeMillis(true,  text));	      int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
533	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setLocale(locale);  }  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setLocale(locale);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setLocale(locale);  }	      int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
534	[BUG]  [BUGGY]  instant.setPos(newPos);  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setPos(newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setPos(newPos);	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
535	[BUG]  [BUGGY]  instant.setParser(bucket.computeParser(true,  text));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setParser(bucket.computeParser(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setParser(bucket.computeParser(true,  text));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
536	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono  >>  null  &&  bucket.getZone()!=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>>'  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono  >>  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono  >>  null  &&  bucket.getZone()!=  null)  {	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>>'	32	None	add
537	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getName()!=  null)  {  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getName()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono!=  null  &&  bucket.getName()!=  null)  {	  	non-compiled	[CE]  cannot  find  symbol	32	None	add
538	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  else  {  instant.setChronology(iChrono);  }  [CE]  illegal  start  of  type  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  else  {  instant.setChronology(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  else  {  instant.setChronology(iChrono);  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
539	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    newPos  =  parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	24	7	add
540	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    newPos  =  parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	24	7	add
541	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	add
542	[BUG]  [BUGGY]  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  [CE]  illegal  start  of  type  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    	non-compiled	[CE]  illegal  start  of  type	46	None	replace
543	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setCh  [CE]  not  a  statement  [FE]      NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setCh  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setCh	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    	non-compiled	[CE]  not  a  statement	46	None	replace
544	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  else  {  instant.setChronology(chrono);  }  [CE]  illegal  start  of  type  [FE]        NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  else  {  instant.setChronology(chrono);  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    	non-compiled	[CE]  illegal  start  of  type	46	None	replace
545	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(chrono  ==  null)  {	  }    else    if(chrono!=    null)    {    	compilable	  [FE]  AssertionFailedError  	49	7	replace
546	[BUG]  [BUGGY]  }  else  if(chrono  ==  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(chrono  ==  null)  {	  }    else    if(chrono!=    null)    {    	compilable	  [FE]  AssertionFailedError  	49	7	replace
547	[BUG]  [BUGGY]  iChrono  =  chrono.getChronology();  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  iChrono  =  chrono.getChronology();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	iChrono  =  chrono.getChronology();	      iChrono    =    bucket.getChronology();    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
548	[BUG]  [BUGGY]  iChrono  =  bucket.getChronology(newPos);  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  iChrono  =  bucket.getChronology(newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	iChrono  =  bucket.getChronology(newPos);	      iChrono    =    bucket.getChronology();    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
549	[BUG]  [BUGGY]  iChrono  =  bucket.getChronology()  +  newPos;  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  iChrono  =  bucket.getChronology()  +  newPos;  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	iChrono  =  bucket.getChronology()  +  newPos;	      iChrono    =    bucket.getChronology();    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
550	[BUG]  [BUGGY]  iChrono  =  newPos  +  bucket.getChronology();  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  iChrono  =  newPos  +  bucket.getChronology();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	iChrono  =  newPos  +  bucket.getChronology();	      iChrono    =    bucket.getChronology();    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
551	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iZone!=  null  &&  chrono.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	35	7	replace
552	[BUG]  [BUGGY]  }  else  if(iZone!=  null  &&  chrono.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iZone!=  null  &&  chrono.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	35	7	replace
553	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  Text));  [CE]  cannot  find  symbol  Text  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  Text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  Text));	  	non-compiled	[CE]  cannot  find  symbol  Text	13	None	add
554	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  moment.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  moment  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  moment.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    moment.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  moment	13	None	add
555	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  minute.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  minute  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  minute.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    minute.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  minute	13	None	add
556	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getOffset()!=  null)  {  [CE]  incomparable  types:  int  and  <null>  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getOffset()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  null  &&  bucket.getOffset()!=  null)  {	  }    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	4	None	replace
557	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos),  iLocale);  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos),  iLocale);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos),  iLocale);	      instant.setMillis(bucket.computeMillis(false,    newPos));    	non-compiled	[CE]  illegal  start  of  type	15	None	replace
558	[BUG]  [BUGGY]  }  else  if(iTimeZone!=  null  &&  bucket.getZone()!=  null)  {  [CE]  cannot  find  symbol  iTimeZone  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iTimeZone!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iTimeZone!=  null  &&  bucket.getZone()!=  null)  {	  }    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  iTimeZone	33	None	replace
559	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos  +  1);  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos  +  1);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos  +  1);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
560	[BUG]  [BUGGY]  Parser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  Parser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	Parser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
561	[BUG]  [BUGGY]  Node  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  Node  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	Node  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
562	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos,  iLocale);  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos,  iLocale);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos,  iLocale);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
563	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos,  iLocal);  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos,  iLocal);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos,  iLocal);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
564	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getUpperBound()!=  null)  {  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getUpperBound()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  chrono.getUpperBound()!=  null)  {	  	non-compiled	[CE]  cannot  find  symbol	34	None	add
565	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale  >>  null  &&  chrono.getZone()!=  null)  {  [CE]  bad  operand  types  for  binary  operator  '>>'  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale  >>  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale  >>  null  &&  chrono.getZone()!=  null)  {	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>>'	34	None	add
566	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null  ||  iLocale!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null  ||  iLocale!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	34	7	add
567	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null  ||  iLocale!=  null)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null  ||  iLocale!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null  ||  iLocale!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	34	7	add
568	[BUG]  [BUGGY]  }  else  if(iLocale!=  locale  &&  iOffsetParsed  &&  bucket.getZone()!=  null)  {  [CE]  cannot  find  symbol  locale  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  locale  &&  iOffsetParsed  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  locale  &&  iOffsetParsed  &&  bucket.getZone()!=  null)  {	  }    else    if(!iOffsetParsed    &&    bucket.getZone()!=    null)    {    [timeout]    	non-compiled	[CE]  cannot  find  symbol  locale	6	None	replace
569	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text),  position);  }  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text),  position);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  chrono  =  chrono.withZone(parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text),  position);  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    chrono    =    chrono.withZone(parsedOffset);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	38	None	replace
570	[BUG]  [BUGGY]  float  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  float  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	float  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));	      int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
571	[BUG]  [BUGGY]  boolean  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  boolean  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	boolean  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));	      int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
572	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(instantLocal,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(instantLocal,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(instantLocal,  text));	      int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
573	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setLocale(iLocale);  }  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setLocale(iLocale);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setLocale(iLocale);  }	      int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
574	[BUG]  [BUGGY]  }  else  if(iLocale!=  context.locale  &&  bucket.getZone()!=  null)  {  [CE]  cannot  find  symbol  context  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  context.locale  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  context.locale  &&  bucket.getZone()!=  null)  {	  }    else    if(iLocale!=    locale    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  context	7	None	replace
575	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    newPos  =  parser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	16	None	add
576	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	16	None	add
577	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseFrom(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseFrom(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    newPos  =  parser.parseFrom(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	16	None	add
578	[BUG]  [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos,  iLocale);  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos,  iLocale);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos,  iLocale);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
579	[BUG]  [BUGGY]  int  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
580	[BUG]  [BUGGY]  if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text));  }	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
581	[BUG]  [BUGGY]  if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text  [CE]  ')'  expected  [FE]                    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position,    newPos);    	non-compiled	[CE]  ')'  expected	29	None	replace
582	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text),  position);  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text),  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  text),  position);	  	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	13	None	add
583	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(null,  text));  [CE]  no  suitable  method  found  for  computeMillis(<null>,String)  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(null,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(null,  text));	  	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(<null>,String)	13	None	add
584	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setPos(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setPos(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setPos(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	13	None	add
585	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text  &  position));  [CE]  bad  operand  types  for  binary  operator  '&'  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text  &  position));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  text  &  position));	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '&'	13	None	add
586	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text  +  position));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  text  +  position));	  	compilable	  [FE]  AssertionFailedError  	13	7	add
587	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text  +  position));  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text  +  position));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  text  +  position));	  	compilable	  [FE]  AssertionFailedError  	13	7	add
588	[BUG]  [BUGGY]  }  else  if(selectChronology(chrono)&&  bucket.getLocalMillis()!=  null)  {  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(selectChronology(chrono)&&  bucket.getLocalMillis()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(selectChronology(chrono)&&  bucket.getLocalMillis()!=  null)  {	  }    else    if(selectChronology(chrono)&&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
589	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	        if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  AssertionFailedError  	11	7	add
590	[BUG]  [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  AssertionFailedError  	11	7	add
591	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  }  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	        if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  }	  	compilable	  [FE]  AssertionFailedError  	11	7	add
592	[BUG]  [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  }  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  }	  	compilable	  [FE]  AssertionFailedError  	11	7	add
593	[BUG]  [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  }	  	non-compiled	[CE]  cannot  find  symbol	11	None	add
594	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	        if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }	  	compilable	  [FE]  AssertionFailedError  	11	7	add
595	[BUG]  [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }	  	compilable	  [FE]  AssertionFailedError  	11	7	add
596	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(bucket.getChronology());  }  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	        if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(bucket.getChronology());  }	  	compilable	  [FE]  AssertionFailedError  	11	7	add
597	[BUG]  [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(bucket.getChronology());  }  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(bucket.getChronology());  }  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(bucket.getChronology());  }	  	compilable	  [FE]  AssertionFailedError  	11	7	add
598	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  }  else  {  instant.setChronology(bucket.getChronology());  }  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	        if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  }  else  {  instant.setChronology(bucket.getChronology());  }	  	compilable	  [FE]  AssertionFailedError  	11	7	add
599	[BUG]  [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  }  else  {  instant.setChronology(bucket.getChronology());  }  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  }  else  {  instant.setChronology(bucket.getChronology());  }  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  }  else  {  instant.setChronology(bucket.getChronology());  }	  	compilable	  [FE]  AssertionFailedError  	11	7	add
600	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	        parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	11	7	add
601	[BUG]  [BUGGY]      parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	11	7	add
602	[BUG]  [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setLocale(locale);  }  [CE]  cannot  find  symbol  locale  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setLocale(locale);  }  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setLocale(locale);  }	  	non-compiled	[CE]  cannot  find  symbol  locale	11	None	add
603	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  [CE]  illegal  start  of  type  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	37	None	replace
604	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffset();  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffset();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffset();	      int    parsedOffset    =    bucket.getOffsetInteger();    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
605	[BUG]  [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger()  -  position;  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  parsedOffset  =  bucket.getOffsetInteger()  -  position;  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  parsedOffset  =  bucket.getOffsetInteger()  -  position;	      int    parsedOffset    =    bucket.getOffsetInteger();    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
606	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text,  position));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text,  position));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(true,  text,  position));	      instant.setMillis(bucket.computeMillis(true,    newPos));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
607	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  iOffsetParsed);  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  iOffsetParsed);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	newPos  =  parser.parseInto(bucket,  text,  position,  iOffsetParsed);	      newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
608	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()  [Delete]  null)  {  [CE]  ')'  expected  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  bucket.getZone()  [Delete]  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  bucket.getZone()  [Delete]  null)  {	  	non-compiled	[CE]  ')'  expected	3	None	add
609	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  [CE]  'else'  without  'if'  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    bucket.getZone()!=    null)    {    else  if(iLocale!=  null  &&  bucket.getZone()!=  null)  {	  	non-compiled	[CE]  'else'  without  'if'	3	None	add
610	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  &&  bucket.getZone()!=  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	2	7	replace
611	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  &&  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  &&  bucket.getZone()!=  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	2	7	replace
612	[BUG]  [BUGGY]  }  else  if(offsetParsed  &&  bucket.getZone()!=  null)  {  [CE]  cannot  find  symbol  offsetParsed  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(offsetParsed  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(offsetParsed  &&  bucket.getZone()!=  null)  {	  }    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  offsetParsed	2	None	replace
613	[BUG]  [BUGGY]  }  else  if(iLocale!=  locale  &&  chrono.getZone()!=  null)  {  [CE]  cannot  find  symbol  locale  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  locale  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  locale  &&  chrono.getZone()!=  null)  {	  }    else    if(iChrono.getZone()!=    null)    {    [timeout]    	non-compiled	[CE]  cannot  find  symbol  locale	5	None	replace
614	[BUG]  [BUGGY]  }  else  if(iChrono.hasZone(chrono))  {  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono.hasZone(chrono))  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iChrono.hasZone(chrono))  {	  }    else    if(iChrono.getZone()!=    null)    {    [timeout]    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
615	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  parsedOffset  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	non-compiled	[CE]  cannot  find  symbol  parsedOffset	40	None	add
616	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null  ||  chrono.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	48	7	add
617	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  chrono.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null  ||  chrono.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	48	7	add
618	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null  ||  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	48	7	add
619	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null  ||  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	48	7	add
620	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  instantLocal.equals(iChrono))  {  [CE]  long  cannot  be  dereferenced  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  instantLocal.equals(iChrono))  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null  ||  instantLocal.equals(iChrono))  {	  	non-compiled	[CE]  long  cannot  be  dereferenced	48	None	add
621	[BUG]  [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  instantLocal.equals(iChrono,  text))  {  [CE]  long  cannot  be  dereferenced  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null)  {  }  else  if(chrono!=  null  ||  instantLocal.equals(iChrono,  text))  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(chrono!=    null)    {    }  else  if(chrono!=  null  ||  instantLocal.equals(iChrono,  text))  {	  	non-compiled	[CE]  long  cannot  be  dereferenced	48	None	add
622	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(null,  text));  [CE]  no  suitable  method  found  for  computeMillis(<null>,String)  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(null,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(null,  text));	  	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(<null>,String)	20	None	add
623	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(False,  text));  [CE]  cannot  find  symbol  False  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(False,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(False,  text));	  	non-compiled	[CE]  cannot  find  symbol  False	20	None	add
624	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(boolean,  text));  [CE]  '.class'  expected  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      instant.setMillis(bucket.computeMillis(true,  text));  instant.setMillis(bucket.computeMillis(boolean,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        instant.setMillis(bucket.computeMillis(true,    text));    instant.setMillis(bucket.computeMillis(boolean,  text));	  	non-compiled	[CE]  '.class'  expected	20	None	add
625	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(chrono!=  null  &&  chrono.getZone()!=  null)  {	  }    else    if(chrono!=    null)    {    	compilable	  [FE]  AssertionFailedError  	49	7	replace
626	[BUG]  [BUGGY]  }  else  if(chrono!=  null  &&  chrono.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(chrono!=  null  &&  chrono.getZone()!=  null)  {	  }    else    if(chrono!=    null)    {    	compilable	  [FE]  AssertionFailedError  	49	7	replace
627	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(chrono!=  null  &&  bucket.getZone()!=  null)  {	  }    else    if(chrono!=    null)    {    	compilable	  [FE]  AssertionFailedError  	49	7	replace
628	[BUG]  [BUGGY]  }  else  if(chrono!=  null  &&  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(chrono!=  null  &&  bucket.getZone()!=  null)  {	  }    else    if(chrono!=    null)    {    	compilable	  [FE]  AssertionFailedError  	49	7	replace
629	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null  &&  instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(chrono!=  null  &&  instant.getZone()!=  null)  {	  }    else    if(chrono!=    null)    {    	compilable	  [FE]  AssertionFailedError  	49	7	replace
630	[BUG]  [BUGGY]  }  else  if(chrono!=  null  &&  instant.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null  &&  instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(chrono!=  null  &&  instant.getZone()!=  null)  {	  }    else    if(chrono!=    null)    {    	compilable	  [FE]  AssertionFailedError  	49	7	replace
631	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null  &&  instant.getChronology()!=  chrono)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(chrono!=  null  &&  instant.getChronology()!=  chrono)  {	  }    else    if(chrono!=    null)    {    	compilable	  [FE]  AssertionFailedError  	49	7	replace
632	[BUG]  [BUGGY]  }  else  if(chrono!=  null  &&  instant.getChronology()!=  chrono)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null  &&  instant.getChronology()!=  chrono)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(chrono!=  null  &&  instant.getChronology()!=  chrono)  {	  }    else    if(chrono!=    null)    {    	compilable	  [FE]  AssertionFailedError  	49	7	replace
633	[BUG]  [BUGGY]  }  else  if(chrono!=  null  &&  chrono.isZone())  {  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null  &&  chrono.isZone())  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(chrono!=  null  &&  chrono.isZone())  {	  }    else    if(chrono!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	49	None	replace
634	[BUG]  [BUGGY]  }  else  if(chrono!=  null  &&  instant.isChronology())  {  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null  &&  instant.isChronology())  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(chrono!=  null  &&  instant.isChronology())  {	  }    else    if(chrono!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	49	None	replace
635	[BUG]  [BUGGY]  }  else  if(chrono!=  null  &&  chrono.getChronology()!=  chrono)  {  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(chrono!=  null  &&  chrono.getChronology()!=  chrono)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(chrono!=  null  &&  chrono.getChronology()!=  chrono)  {	  }    else    if(chrono!=    null)    {    	non-compiled	[CE]  cannot  find  symbol	49	None	replace
636	[BUG]  [BUGGY]  }  else  if(timeZone!=  null  &&  bucket.getZone()!=  null)  {  [CE]  cannot  find  symbol  timeZone  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(timeZone!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(timeZone!=  null  &&  bucket.getZone()!=  null)  {	  }    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  timeZone	33	None	replace
637	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  else  {  instant.setChronology(chrono);  }	  	compilable	  [FE]  NullPointerException  	45	8	add
638	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  else  {  instant.setChronology(chrono);  }  [FE]  NullPointerException  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(true,  text));  }  else  {  instant.setChronology(chrono);  }	  	compilable	  [FE]  NullPointerException  	45	8	add
639	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  [CE]  cannot  find  symbol  parsedOffset  [FE]      NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  if(newPos  >=  0)  {  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    if(newPos  >=  0)  {  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }	  	non-compiled	[CE]  cannot  find  symbol  parsedOffset	45	None	add
640	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  parsedOffset  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	non-compiled	[CE]  cannot  find  symbol  parsedOffset	36	None	add
641	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]      NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  Integer  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  Integer  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  NullPointerException  	36	8	add
642	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  Integer  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [FE]  NullPointerException  [FE]      NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  if(newPos  >=  0)  {  Integer  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    if(newPos  >=  0)  {  Integer  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }	  	compilable	  [FE]  NullPointerException  	36	8	add
643	[BUG]  [BUGGY]  instant.setInteger(bucket.computeInteger(instantLocal),  newPos);  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setInteger(bucket.computeInteger(instantLocal),  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setInteger(bucket.computeInteger(instantLocal),  newPos);	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
644	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(0,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(0,  text));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
645	[BUG]  [BUGGY]  instant.setPos(bucket.computePosition(instantLocal),  newPos);  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setPos(bucket.computePosition(instantLocal),  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setPos(bucket.computePosition(instantLocal),  newPos);	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
646	[BUG]  [BUGGY]  instant.setPos(instantLocal  +  newPos);  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setPos(instantLocal  +  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setPos(instantLocal  +  newPos);	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
647	[BUG]  [BUGGY]  instant.setInteger(bucket.computeInteger(instantLocal,  newPos));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setInteger(bucket.computeInteger(instantLocal,  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setInteger(bucket.computeInteger(instantLocal,  newPos));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
648	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  oldPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  oldPos  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  oldPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    oldPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol  oldPos	24	None	add
649	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  cannot  find  symbol	24	None	add
650	[BUG]  [BUGGY]  }  else  if(timeZone!=  null)  {  [CE]  cannot  find  symbol  timeZone  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(timeZone!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(timeZone!=  null)  {	  }    else    if(iZone!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  timeZone	31	None	replace
651	[BUG]  [BUGGY]  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [CE]  illegal  start  of  type  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos!=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
652	[BUG]  [BUGGY]  }  else  if(timeZone!=  null  &&  chrono.getZone()!=  null)  {  [CE]  cannot  find  symbol  timeZone  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(timeZone!=  null  &&  chrono.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(timeZone!=  null  &&  chrono.getZone()!=  null)  {	  }    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  timeZone	35	None	replace
653	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text),  newPos));  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text),  newPos));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(true,  text),  newPos));	      instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  ';'  expected	21	None	replace
654	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  int  newPos  =  parser.parseInto(bucket,  text  [CE]  ')'  expected  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  int  newPos  =  parser.parseInto(bucket,  text  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  int  newPos  =  parser.parseInto(bucket,  text	  	non-compiled	[CE]  ')'  expected	8	None	add
655	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  parsedOffset  =  instant.getOffsetInteger();  [CE]  cannot  find  symbol  initial  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  parsedOffset  =  instant.getOffsetInteger();  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  parsedOffset  =  instant.getOffsetInteger();	  	non-compiled	[CE]  cannot  find  symbol  initial	8	None	add
656	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  return  newPos;  }  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  return  newPos;  }  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  return  newPos;  }	  	non-compiled	[CE]  illegal  start  of  type	8	None	add
657	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  [CE]  >  expected  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));	  	non-compiled	[CE]  >  expected	8	None	add
658	[BUG]  [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  int  newPos  =  parser.parseInto(bucket,  text,  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(instant.getZone()!=  null)  {  }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  int  newPos  =  parser.parseInto(bucket,  text,  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(instant.getZone()!=    null)    {    }  else  if(instant.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  instant.setMillis(instant.computeMillis(false,  text));  int  newPos  =  parser.parseInto(bucket,  text,	  	non-compiled	[CE]  illegal  start  of  expression	8	None	add
659	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text),  position);  }  else  {  instant.setChronology(chrono);  }  [CE]  illegal  start  of  type  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text),  position);  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text),  position);  }  else  {  instant.setChronology(chrono);  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(chrono);    }    	non-compiled	[CE]  illegal  start  of  type	46	None	replace
660	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChrono(iChrono);  }  [CE]  cannot  find  symbol  [FE]    NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChrono(iChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChrono(iChrono);  }	  	non-compiled	[CE]  cannot  find  symbol	43	None	add
661	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  [CE]  illegal  start  of  expression  [FE]      NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);	  	non-compiled	[CE]  illegal  start  of  expression	43	None	add
662	[BUG]  [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(jChrono);  }  [CE]  cannot  find  symbol  jChrono  [FE]        NullPointerException    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(iChrono);  }  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(jChrono);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setChronology(iChrono);    }    if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(jChrono);  }	  	non-compiled	[CE]  cannot  find  symbol  jChrono	43	None	add
663	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  position);	      instant.setMillis(bucket.computeMillis(false,    newPos));    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
664	[BUG]  [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(bucket.computeMillis(true,  text));  }  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(bucket.computeMillis(true,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(bucket.computeMillis(true,  text));  }	      instant.setMillis(bucket.computeMillis(false,    newPos));    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
665	[BUG]  [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(instantLocal.computeMillis(true,  text));  }  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(instantLocal.computeMillis(true,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setMillis(instantLocal.computeMillis(true,  text));  }	      instant.setMillis(bucket.computeMillis(false,    newPos));    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
666	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  ')'  expected  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  ')'  expected	30	None	add
667	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);  instant.setMillis(flush.computeMillis(false,  text));  [CE]  ')'  expected  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);  instant.setMillis(flush.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);  instant.setMillis(flush.computeMillis(false,  text));	  	non-compiled	[CE]  ')'  expected	30	None	add
668	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);  instant.setMillis(computeMillis(false,  text));  [CE]  ')'  expected  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);  instant.setMillis(computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);  instant.setMillis(computeMillis(false,  text));	  	non-compiled	[CE]  ')'  expected	30	None	add
669	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  ')'  expected  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  ')'  expected	30	None	add
670	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);  [CE]  ')'  expected  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  ')'  expected	30	None	add
671	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear)  {  [CE]  ')'  expected  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear)  {	  	non-compiled	[CE]  ')'  expected	30	None	add
672	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  >  expected  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  >  expected	30	None	add
673	[BUG]  [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(chrono.computeMillis(false,  text));  [CE]  >  expected  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iZone!=  null)  {  }  else  if(iZone!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(chrono.computeMillis(false,  text));  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iZone!=    null)    {    }  else  if(iZone!=  null)  <  chrono  =  chrono.withZone(bucket.getZone());  instant.setMillis(chrono.computeMillis(false,  text));	  	non-compiled	[CE]  >  expected	30	None	add
674	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instantLocal,  text);  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.getParser(instantLocal,  text);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.getParser(instantLocal,  text);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
675	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(text,  position);  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.parse(text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.parse(text,  position);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
676	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(text,  position,  newPos);  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.parse(text,  position,  newPos);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.parse(text,  position,  newPos);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
677	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse(text);  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.parse(text);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.parse(text);	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
678	[BUG]  [BUGGY]  DateTimeParser  parser  =  bucket.parse();  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  DateTimeParser  parser  =  bucket.parse();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	DateTimeParser  parser  =  bucket.parse();	      DateTimeParser    parser    =    bucket.getParser();    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
679	[BUG]  [BUGGY]  if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text));  }	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
680	[BUG]  [BUGGY]  if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text  [CE]  ')'  expected  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(iChrono!=  null)  {  DateTimeParser  parser  =  bucket.getParser();  iChrono  =  parser.parseInto(bucket,  text,  position);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text	      DateTimeParser    parser    =    bucket.getParser();    iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  ')'  expected	27	None	replace
681	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(iChrono!=  null  &&  instant.getZone()!=  null)  {	  }    else    if(instant.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	9	7	replace
682	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  instant.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iChrono!=  null  &&  instant.getZone()!=  null)  {	  }    else    if(instant.getZone()!=    null)    {    	compilable	  [FE]  AssertionFailedError  	9	7	replace
683	[BUG]  [BUGGY]  }  else  if(iLocale!=  locale  &&  instant.getZone()!=  null)  {  [CE]  cannot  find  symbol  locale  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  locale  &&  instant.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(iLocale!=  locale  &&  instant.getZone()!=  null)  {	  }    else    if(instant.getZone()!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  locale	9	None	replace
684	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text),  position);  }  else  {  instant.setParsed(true);  }  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text),  position);  }  else  {  instant.setParsed(true);  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffsetInteger();  instant.setMillis(bucket.computeMillis(false,  text),  position);  }  else  {  instant.setParsed(true);  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffsetInteger();    instant.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setParsed(true);    }    	non-compiled	[CE]  illegal  start  of  type	47	None	replace
685	[BUG]  [BUGGY]  int  iChrono  =  bucket.getChronology();  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  iChrono  =  bucket.getChronology();  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  iChrono  =  bucket.getChronology();	      iChrono    =    bucket.getChronology();    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
686	[BUG]  [BUGGY]  iChrono  =  bucket.getChronology(instantLocal);  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  iChrono  =  bucket.getChronology(instantLocal);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	iChrono  =  bucket.getChronology(instantLocal);	      iChrono    =    bucket.getChronology();    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
687	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  chrono.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  chrono.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    newPos  =  parser.parseInto(bucket,  text,  position);  chrono.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	22	None	add
688	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	add
689	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	add
690	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        newPos    =    parser.parseInto(bucket,    text,    position);    newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	22	7	add
691	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	22	7	add
692	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	add	        newPos    =    parser.parseInto(bucket,    text,    position);    newPos  =  iParser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	22	7	add
693	[BUG]  [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  iParser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]      newPos  =  parser.parseInto(bucket,  text,  position);  newPos  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	        newPos    =    parser.parseInto(bucket,    text,    position);    newPos  =  iParser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	22	7	add
694	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  ||  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  ||  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	1	7	add
695	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  ||  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  ||  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  ||  bucket.getZone()!=  null)  {	  	compilable	  [FE]  AssertionFailedError  	1	7	add
696	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  ||  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  ||  bucket.getZone()  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	1	7	add
697	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  ||  bucket.getZone()  ==  null)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  ||  bucket.getZone()  ==  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null  ||  bucket.getZone()  ==  null)  {	  	compilable	  [FE]  AssertionFailedError  	1	7	add
698	[BUG]  [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  [CE]  cannot  find  symbol  initial  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iOffsetParsed    &&    bucket.getZone()!=    null)    {    }  else  if(iOffsetParsed  &&  bucket.getZone()!=  null)  {  initial  =  chrono.withZone(bucket.getZone());	  	non-compiled	[CE]  cannot  find  symbol  initial	1	None	add
699	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
700	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
701	[BUG]  [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(true,  text));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));    [BUGGY]  if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(true,  text));  }  [BUGGY]    if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	712	712	7	replace	if(newPos  >=  0)  {  int  parsedOffset  =  bucket.getOffset();  instant.setMillis(bucket.computeMillis(true,  text));  }	      if(newPos    >=    0)    {    int    parsedOffset    =    bucket.getOffset();    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
702	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  <  chrono  =  chrono.withLocal(bucket.getZone());  [CE]  >  expected  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  <  chrono  =  chrono.withLocal(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  <  chrono  =  chrono.withLocal(bucket.getZone());	  	non-compiled	[CE]  >  expected	34	None	add
703	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null  ||   " ".equals(chrono.getLocale()))  {  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null  ||   " ".equals(chrono.getLocale()))  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null  ||   " ".equals(chrono.getLocale()))  {	  	non-compiled	[CE]  cannot  find  symbol	34	None	add
704	[BUG]  [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  initial  =  chrono.withLocal(bucket.getZone());  [CE]  cannot  find  symbol  initial  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  initial  =  chrono.withLocal(bucket.getZone());  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iLocale!=    null    &&    chrono.getZone()!=    null)    {    }  else  if(iLocale!=  null  &&  chrono.getZone()!=  null)  {  initial  =  chrono.withLocal(bucket.getZone());	  	non-compiled	[CE]  cannot  find  symbol  initial	34	None	add
705	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(!iOffsetParsed  &&  bucket.getZone()!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	}  else  if(!iOffsetParsed  &&  bucket.getZone()!=  null  &&  bucket.getZone()!=  null)  {	  }    else    if(!iOffsetParsed    &&    bucket.getZone()!=    null)    {    [timeout]    	compilable	  [FE]  AssertionFailedError  	6	7	replace
706	[BUG]  [BUGGY]  }  else  if(!iOffsetParsed  &&  bucket.getZone()!=  null  &&  bucket.getZone()!=  null)  {  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(!iOffsetParsed  &&  bucket.getZone()!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}  else  if(!iOffsetParsed  &&  bucket.getZone()!=  null  &&  bucket.getZone()!=  null)  {	  }    else    if(!iOffsetParsed    &&    bucket.getZone()!=    null)    {    [timeout]    	compilable	  [FE]  AssertionFailedError  	6	7	replace
707	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null  ||  iChrono.equals(bucket.getChronology()))  {  [timeout]  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null  ||  iChrono.equals(bucket.getChronology()))  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null  ||  iChrono.equals(bucket.getChronology()))  {	  	non-compiled	[timeout]	32	None	add
708	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [timeout]  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }	  	non-compiled	[timeout]	32	None	add
709	[BUG]  [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(jChrono!=  null  &&  bucket.getZone()!=  null)  {  [CE]  cannot  find  symbol  jChrono  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  }  else  if(iChrono!=  null  &&  bucket.getZone()!=  null)  {  }  else  if(jChrono!=  null  &&  bucket.getZone()!=  null)  {  [BUGGY]    chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	}    else    if(iChrono!=    null    &&    bucket.getZone()!=    null)    {    }  else  if(jChrono!=  null  &&  bucket.getZone()!=  null)  {	  	non-compiled	[CE]  cannot  find  symbol  jChrono	32	None	add
