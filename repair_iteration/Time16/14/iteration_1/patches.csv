bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  DateTimeParser  parser  =  iParser.parseInstant(instantLocal,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  iParser.parseInstant(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  iParser.parseInstant(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	5	None	replace
2	[BUG]  [BUGGY]  DateTimeParser  parser  =  iParser.parseInstant(instant,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  iParser.parseInstant(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  iParser.parseInstant(instant,  text,  position);	      DateTimeParser    parser    =    parser.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	5	None	replace
3	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInstant(instant,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInstant(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInstant(instant,  text,  position);	      DateTimeParser    parser    =    parser.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	5	None	replace
4	[BUG]  [BUGGY]  Parser  parser  =  iParser.parseInstant(instantLocal,  text,  position);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Parser  parser  =  iParser.parseInstant(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Parser  parser  =  iParser.parseInstant(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
5	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position  -  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position  -  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position  -  1);	      DateTimeParser    parser    =    parser.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	5	None	replace
6	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position,  iDefaultYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position,  iDefaultYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position,  iDefaultYear);	      DateTimeParser    parser    =    parser.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	5	None	replace
7	[BUG]  [BUGGY]  parser  =  iParser.parseInstant(instantLocal,  text,  position);  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser  =  iParser.parseInstant(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser  =  iParser.parseInstant(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
8	[BUG]  [BUGGY]  DateTimeParser  parser  =  iParser.createChronology(instantLocal,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  iParser.createChronology(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  iParser.createChronology(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.createChronology(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
9	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.createChronology(instantLocal,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.createChronology(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.createChronology(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.createChronology(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
10	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parser(instantLocal,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parser(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parser(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.createChronology(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
11	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.createChronology(instant,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.createChronology(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.createChronology(instant,  text,  position);	      DateTimeParser    parser    =    parser.createChronology(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
12	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.createChronology(instantLocal,  text,  position,  iDefaultYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.createChronology(instantLocal,  text,  position,  iDefaultYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.createChronology(instantLocal,  text,  position,  iDefaultYear);	      DateTimeParser    parser    =    parser.createChronology(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
13	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.createChronology(instantLocal,  text,  position,  chrono);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.createChronology(instantLocal,  text,  position,  chrono);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.createChronology(instantLocal,  text,  position,  chrono);	      DateTimeParser    parser    =    parser.createChronology(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
14	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.createChronology(instantLocal,  text,  position  -  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.createChronology(instantLocal,  text,  position  -  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.createChronology(instantLocal,  text,  position  -  1);	      DateTimeParser    parser    =    parser.createChronology(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
15	[BUG]  [BUGGY]  Parser  parser  =  iParser.createChronology(instantLocal,  text,  position);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Parser  parser  =  iParser.createChronology(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Parser  parser  =  iParser.createChronology(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.createChronology(instantLocal,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
16	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseChronology(instantLocal,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseChronology(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseChronology(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.createChronology(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
17	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iLocale);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,Locale)  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iLocale);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iLocale);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iChronology);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,Locale)	44	None	replace
18	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldType);  [CE]  cannot  find  symbol  iFieldType  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldType);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldType);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iChronology);    	non-compiled	[CE]  cannot  find  symbol  iFieldType	44	None	replace
19	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iValue);  [CE]  cannot  find  symbol  iValue  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iValue);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iValue);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iChronology);    	non-compiled	[CE]  cannot  find  symbol  iValue	44	None	replace
20	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iZone);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,DateTimeZone)  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iZone);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iZone);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iChronology);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,DateTimeZone)	44	None	replace
21	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldChronology);  [CE]  cannot  find  symbol  iFieldChronology  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldChronology);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldChronology);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iChronology);    	non-compiled	[CE]  cannot  find  symbol  iFieldChronology	44	None	replace
22	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iValueChronology);  [CE]  cannot  find  symbol  iValueChronology  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iValueChronology);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iValueChronology);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iChronology);    	non-compiled	[CE]  cannot  find  symbol  iValueChronology	44	None	replace
23	[BUG]  [BUGGY]  DateTimeParser  parser  =  iParser.parseInto(instant,  text,  position  -  instantLocal);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  iParser.parseInto(instant,  text,  position  -  instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  iParser.parseInto(instant,  text,  position  -  instantLocal);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position    -    instantLocal);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
24	[BUG]  [BUGGY]  Parser  parser  =  iParser.parseInto(instant,  text,  position  -  instantLocal);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Parser  parser  =  iParser.parseInto(instant,  text,  position  -  instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Parser  parser  =  iParser.parseInto(instant,  text,  position  -  instantLocal);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position    -    instantLocal);    	non-compiled	[CE]  cannot  find  symbol	28	None	replace
25	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInto(instant,  text,  position  -  instantLocal);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInto(instant,  text,  position  -  instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInto(instant,  text,  position  -  instantLocal);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position    -    instantLocal);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
26	[BUG]  [BUGGY]  parser  =  iParser.parseInto(instant,  text,  position  -  instantLocal);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser  =  iParser.parseInto(instant,  text,  position  -  instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser  =  iParser.parseInto(instant,  text,  position  -  instantLocal);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position    -    instantLocal);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	28	None	replace
27	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  instantLocal,  iDefaultYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  instantLocal,  iDefaultYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  instantLocal,  iDefaultYear);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position    -    instantLocal);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
28	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  1,  instantLocal);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  1,  instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  1,  instantLocal);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position    -    instantLocal);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
29	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  +  instantLocal);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  +  instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  +  instantLocal);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position    -    instantLocal);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
30	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
31	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  iPivotYear,  iDefaultYear);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
32	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iPivotYear,  chrono,  iLocale,  iDefaultYear);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iPivotYear,  chrono,  iLocale,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iPivotYear,  chrono,  iLocale,  iDefaultYear);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
33	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  instantLocal);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  instantLocal);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  instantLocal);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
34	[BUG]  [BUGGY]  timeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  timeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	timeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
35	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
36	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  iPivotYear,  chrono);  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  iPivotYear,  chrono);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  iPivotYear,  chrono);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
37	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear);  [timeout]  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    	non-compiled	[timeout]	30	None	replace
38	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  [timeout]  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    	non-compiled	[timeout]	30	None	replace
39	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  0,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Integer,int,int)  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  0,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  0,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Integer,int,int)	30	None	replace
40	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear);  [timeout]  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    	non-compiled	[timeout]	30	None	replace
41	[BUG]  [BUGGY]  if(iLocale!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  }  [timeout]  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  if(iLocale!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  }  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	if(iLocale!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  }	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    	non-compiled	[timeout]	30	None	replace
42	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear  +  1);  [timeout]  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear  +  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear  +  1);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    	non-compiled	[timeout]	30	None	replace
43	[BUG]  [BUGGY]  if(iLocale  ==  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  }  [timeout]  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  if(iLocale  ==  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  }  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	if(iLocale  ==  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  }	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    	non-compiled	[timeout]	30	None	replace
44	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iValueType);  [CE]  cannot  find  symbol  iValueType  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iValueType);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iValueType);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iValueType	46	None	replace
45	[BUG]  [BUGGY]  int  iLocale  =  chrono.getLocale(instantLocal);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  int  iLocale  =  chrono.getLocale(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	int  iLocale  =  chrono.getLocale(instantLocal);	      int    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	25	None	replace
46	[BUG]  [BUGGY]  int  iLocale  =  chrono.getLocale(position);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  int  iLocale  =  chrono.getLocale(position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	int  iLocale  =  chrono.getLocale(position);	      int    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	25	None	replace
47	[BUG]  [BUGGY]  int  iLocale  =  instantLocal.getLocale();  [CE]  long  cannot  be  dereferenced  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  int  iLocale  =  instantLocal.getLocale();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	int  iLocale  =  instantLocal.getLocale();	      int    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  long  cannot  be  dereferenced	25	None	replace
48	[BUG]  [BUGGY]  int  iLocale  =  this.chrono.getLocale();  [CE]  cannot  find  symbol  chrono  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  int  iLocale  =  this.chrono.getLocale();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	int  iLocale  =  this.chrono.getLocale();	      int    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol  chrono	25	None	replace
49	[BUG]  [BUGGY]  int  iLocale  =  instant.getLocale();  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  int  iLocale  =  instant.getLocale();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	int  iLocale  =  instant.getLocale();	      int    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	25	None	replace
50	[BUG]  [BUGGY]  int  iLocale  =  chrono.getLocale(locale);  [CE]  cannot  find  symbol  locale  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  int  iLocale  =  chrono.getLocale(locale);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	int  iLocale  =  chrono.getLocale(locale);	      int    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol  locale	25	None	replace
51	[BUG]  [BUGGY]  int  iLocale  =  time.getLocale();  [CE]  cannot  find  symbol  time  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  int  iLocale  =  time.getLocale();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	int  iLocale  =  time.getLocale();	      int    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol  time	25	None	replace
52	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	add	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	compilable	  [FE]  AssertionFailedError  	20	7	replace
53	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	compilable	  [FE]  AssertionFailedError  	20	7	replace
54	[BUG]  [BUGGY]  if(iLocale!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }  [CE]  cannot  find  symbol  bucket  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  if(iLocale!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	if(iLocale!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	non-compiled	[CE]  cannot  find  symbol  bucket	20	None	replace
55	[BUG]  [BUGGY]  if(iOffsetParsed  &&  chrono!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }  [CE]  cannot  find  symbol  bucket  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  if(iOffsetParsed  &&  chrono!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	if(iOffsetParsed  &&  chrono!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	non-compiled	[CE]  cannot  find  symbol  bucket	20	None	replace
56	[BUG]  [BUGGY]  if(iLocale  ==  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }  [CE]  cannot  find  symbol  bucket  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  if(iLocale  ==  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	if(iLocale  ==  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	non-compiled	[CE]  cannot  find  symbol  bucket	20	None	replace
57	[BUG]  [BUGGY]  ParserBucket  bucket  =  new  ParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  ParserBucket  bucket  =  new  ParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	ParserBucket  bucket  =  new  ParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	non-compiled	[CE]  cannot  find  symbol	20	None	replace
58	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	non-compiled	[CE]  cannot  find  symbol	20	None	replace
59	[BUG]  [BUGGY]  if(iLocale!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }  else  {  instantLo  [CE]  not  a  statement  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  if(iLocale!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }  else  {  instantLo  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	if(iLocale!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }  else  {  instantLo	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	non-compiled	[CE]  not  a  statement	20	None	replace
60	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  *  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	add	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  *  1);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	compilable	  [FE]  AssertionFailedError  	20	7	replace
61	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  *  1);  [FE]  AssertionFailedError  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  *  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  *  1);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	compilable	  [FE]  AssertionFailedError  	20	7	replace
62	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  locale,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  locale  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  locale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  locale,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotXear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  locale	31	None	replace
63	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Integer,int)  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotXear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Integer,int)	31	None	replace
64	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  instantMillis,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,long,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  instantMillis,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  instantMillis,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotXear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,long,int)	31	None	replace
65	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  locale,  iPivotXear,  iDefaultYear);  [CE]  cannot  find  symbol  locale  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  locale,  iPivotXear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  locale,  iPivotXear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotXear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  locale	31	None	replace
66	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  location,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  location  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  location,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  location,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotXear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  location	31	None	replace
67	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iHorizontal);  [CE]  cannot  find  symbol  iHorizontal  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iHorizontal);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iHorizontal);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iOptional);    	non-compiled	[CE]  cannot  find  symbol  iHorizontal	47	None	replace
68	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOffset);  [CE]  cannot  find  symbol  iOffset  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOffset);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOffset);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iOptional);    	non-compiled	[CE]  cannot  find  symbol  iOffset	47	None	replace
69	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  locale,  iPivotYear,  iDefaultYear,  iOptional);  [CE]  cannot  find  symbol  locale  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  locale,  iPivotYear,  iDefaultYear,  iOptional);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  locale,  iPivotYear,  iDefaultYear,  iOptional);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iOptional);    	non-compiled	[CE]  cannot  find  symbol  locale	47	None	replace
70	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  instantLocal);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,Integer,int,long)  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  instantLocal);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  instantLocal);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,Integer,int,long)	18	None	replace
71	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  0,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Chronology,int,Integer,int)  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  0,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  0,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Chronology,int,Integer,int)	18	None	replace
72	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iLocale);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,Integer,int,Locale)  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iLocale);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iLocale);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,Integer,int,Locale)	18	None	replace
73	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  null);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,Integer,int,<null>)  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  null);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  null);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,Integer,int,<null>)	18	None	replace
74	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iOffsetParsed);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,Integer,int,boolean)  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iOffsetParsed);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iOffsetParsed);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,Integer,int,boolean)	18	None	replace
75	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iMillis,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  iMillis  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iMillis,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iMillis,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iMillis	18	None	replace
76	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,Integer,int)  [FE]                              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,Integer,int)	18	None	replace
77	[BUG]  [BUGGY]  instantLocal  =  chrono.withZone(instantLocal);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  chrono.withZone(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	instantLocal  =  chrono.withZone(instantLocal);	      iChrono    =    chrono.withZone(instantLocal);    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	26	None	replace
78	[BUG]  [BUGGY]  iChrono  =  chrono.withLocal(instantLocal);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  iChrono  =  chrono.withLocal(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	iChrono  =  chrono.withLocal(instantLocal);	      iChrono    =    chrono.withZone(instantLocal);    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	26	None	replace
79	[BUG]  [BUGGY]  Chronology  chrono  =  chrono.withLocal(instantLocal);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  chrono.withLocal(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  chrono.withLocal(instantLocal);	      iChrono    =    chrono.withZone(instantLocal);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	replace
80	[BUG]  [BUGGY]  Chronology  chrono  =  chrono.withZone(instantLocal);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  chrono.withZone(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  chrono.withZone(instantLocal);	      iChrono    =    chrono.withZone(instantLocal);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	replace
81	[BUG]  [BUGGY]  chrono  =  chrono.withZone(instantLocal);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  chrono  =  chrono.withZone(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	chrono  =  chrono.withZone(instantLocal);	      iChrono    =    chrono.withZone(instantLocal);    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	26	None	replace
82	[BUG]  [BUGGY]  chrono  =  chrono.withLocal(instantLocal);  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  chrono  =  chrono.withLocal(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	chrono  =  chrono.withLocal(instantLocal);	      iChrono    =    chrono.withZone(instantLocal);    	non-compiled	[CE]  cannot  find  symbol	26	None	replace
83	[BUG]  [BUGGY]  momentLocal  =  chrono.withZone(instantLocal);  [CE]  cannot  find  symbol  momentLocal  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  momentLocal  =  chrono.withZone(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	momentLocal  =  chrono.withZone(instantLocal);	      iChrono    =    chrono.withZone(instantLocal);    	non-compiled	[CE]  cannot  find  symbol  momentLocal	26	None	replace
84	[BUG]  [BUGGY]  int  iLocale  =  chrono.getZone().getOffset(instantMillis);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,int,Integer,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  int  iLocale  =  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	int  iLocale  =  chrono.getZone().getOffset(instantMillis);	      long    iLocale    =    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,int,Integer,int)	41	None	replace
85	[BUG]  [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantMillis,  position);  [CE]  no  suitable  method  found  for  getOffset(long,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantMillis,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getZone().getOffset(instantMillis,  position);	      long    iLocale    =    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  no  suitable  method  found  for  getOffset(long,int)	41	None	replace
86	[BUG]  [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantMillis,  instantLocal);  [CE]  no  suitable  method  found  for  getOffset(long,long)  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantMillis,  instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getZone().getOffset(instantMillis,  instantLocal);	      long    iLocale    =    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  no  suitable  method  found  for  getOffset(long,long)	41	None	replace
87	[BUG]  [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantLocal,  instantMillis);  [CE]  no  suitable  method  found  for  getOffset(long,long)  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantLocal,  instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getZone().getOffset(instantLocal,  instantMillis);	      long    iLocale    =    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  no  suitable  method  found  for  getOffset(long,long)	41	None	replace
88	[BUG]  [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantLocal,  position);  [CE]  no  suitable  method  found  for  getOffset(long,int)  [FE]                            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantLocal,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getZone().getOffset(instantLocal,  position);	      long    iLocale    =    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  no  suitable  method  found  for  getOffset(long,int)	41	None	replace
89	[BUG]  [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(position,  instantMillis);  [CE]  no  suitable  method  found  for  getOffset(int,long)  [FE]                              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(position,  instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getZone().getOffset(position,  instantMillis);	      long    iLocale    =    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  no  suitable  method  found  for  getOffset(int,long)	41	None	replace
90	[BUG]  [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(position);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)  [FE]                                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getZone().getOffset(position);	      long    iLocale    =    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)	41	None	replace
91	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	add	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);	  	compilable	  [FE]  AssertionFailedError  	3	7	add
92	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);	  	compilable	  [FE]  AssertionFailedError  	3	7	add
93	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  }  else  {  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  }  else  {  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  }  else  {  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);	  	non-compiled	[CE]  illegal  start  of  type	3	None	add
94	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iDefaultYear  =  parser.parseInto(instant,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iDefaultYear  =  parser.parseInto(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iDefaultYear  =  parser.parseInto(instant,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	3	None	add
95	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getUpperZone().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getUpperZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getUpperZone().getOffset(instantMillis);	  	non-compiled	[CE]  cannot  find  symbol	3	None	add
96	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iPivotYear  =  pivotYear;  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iPivotYear  =  pivotYear;  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iPivotYear  =  pivotYear;	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	3	None	add
97	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iPivotYear  =  parser.parseInto(instant,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iPivotYear  =  parser.parseInto(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iPivotYear  =  parser.parseInto(instant,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	3	None	add
98	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iDefaultYear  =  parser.parseInto(chrono,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iDefaultYear  =  parser.parseInto(chrono,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iDefaultYear  =  parser.parseInto(chrono,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	3	None	add
99	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  this.iChrono  =  parser.parseInto(instant,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  this.iChrono  =  parser.parseInto(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  this.iChrono  =  parser.parseInto(instant,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	3	None	add
100	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iChrono  =  parser.parseInto(instant,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iChrono  =  parser.parseInto(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iChrono  =  parser.parseInto(instant,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	3	None	add
101	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  instantLocal);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,long)  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  instantLocal);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  instantLocal);	  final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,long)	14	None	replace
102	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int)  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear);	  final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int)	14	None	replace
103	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Chronology,Integer,int)  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear);	  final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Chronology,Integer,int)	14	None	replace
104	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOffsetParsed);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,boolean)  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOffsetParsed);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOffsetParsed);	  final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,boolean)	14	None	replace
105	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  iDefaultYear);  [CE]  cannot  find  symbol  iPivotXear  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  iDefaultYear);	  final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iPivotXear	14	None	replace
106	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Integer,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iDefaultYear);	  final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Integer,int)	14	None	replace
107	[BUG]  [BUGGY]  DateTimeParser  parser  =  iParser.parseInto(instant,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  iParser.parseInto(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  iParser.parseInto(instant,  text,  position);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	1	None	replace
108	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInto(instant,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInto(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInto(instant,  text,  position);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	1	None	replace
109	[BUG]  [BUGGY]  Parser  parser  =  iParser.parseInto(instant,  text,  position);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Parser  parser  =  iParser.parseInto(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Parser  parser  =  iParser.parseInto(instant,  text,  position);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	1	None	replace
110	[BUG]  [BUGGY]  parser  =  iParser.parseInto(instant,  text,  position);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser  =  iParser.parseInto(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser  =  iParser.parseInto(instant,  text,  position);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	1	None	replace
111	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  1);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	1	None	replace
112	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position,  iDefaultYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position,  iDefaultYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instant,  text,  position,  iDefaultYear);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	1	None	replace
113	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position,  instantLocal);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position,  instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instant,  text,  position,  instantLocal);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	1	None	replace
114	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position,  iLocale);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position,  iLocale);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instant,  text,  position,  iLocale);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	1	None	replace
115	[BUG]  [BUGGY]  long  iLocale  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)	36	None	replace
116	[BUG]  [BUGGY]  int  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  int  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	int  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  possible  loss  of  precision	36	None	replace
117	[BUG]  [BUGGY]  int  iLocale  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [CE]  possible  loss  of  precision  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  int  iLocale  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	int  iLocale  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  possible  loss  of  precision	36	None	replace
118	[BUG]  [BUGGY]  int  iLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  int  iLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	int  iLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  possible  loss  of  precision	36	None	replace
119	[BUG]  [BUGGY]  long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantMillis,  position);  [CE]  no  suitable  method  found  for  getOffset(long,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantMillis,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantMillis,  position);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  no  suitable  method  found  for  getOffset(long,int)	36	None	replace
120	[BUG]  [BUGGY]  Integer  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [CE]  incompatible  types  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Integer  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Integer  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  incompatible  types	36	None	replace
121	[BUG]  [BUGGY]  Long  iLocale  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Long,Integer,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Long  iLocale  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Long  iLocale  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Long,Integer,int)	36	None	replace
122	[BUG]  [BUGGY]  int  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantLocal);  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  int  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	int  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantLocal);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  possible  loss  of  precision	39	None	replace
123	[BUG]  [BUGGY]  long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantMillis,  instantLocal);  [CE]  no  suitable  method  found  for  getOffset(long,long)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantMillis,  instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantMillis,  instantLocal);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  no  suitable  method  found  for  getOffset(long,long)	39	None	replace
124	[BUG]  [BUGGY]  long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantLocal,  position);  [CE]  no  suitable  method  found  for  getOffset(long,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantLocal,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantLocal,  position);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  no  suitable  method  found  for  getOffset(long,int)	39	None	replace
125	[BUG]  [BUGGY]  long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(position);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(position);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)	39	None	replace
126	[BUG]  [BUGGY]  long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantLocal)+  1;  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantLocal)+  1;  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantLocal)+  1;	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)	39	None	replace
127	[BUG]  [BUGGY]  Integer  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantLocal);  [CE]  incompatible  types  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Integer  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Integer  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantLocal);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  incompatible  types	39	None	replace
128	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  instantLocal);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,<null>,Integer,int,long)  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  instantLocal);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  instantLocal);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    null,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,<null>,Integer,int,long)	32	None	replace
129	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  instantMillis,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,<null>,long,Integer,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  instantMillis,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  instantMillis,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    null,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,<null>,long,Integer,int)	32	None	replace
130	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  null,  instantMillis,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Chronology,<null>,long,Integer,int)  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  null,  instantMillis,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  null,  instantMillis,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    null,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Chronology,<null>,long,Integer,int)	32	None	replace
131	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  null,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Chronology,<null>,Integer,int)  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  null,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  null,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    null,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Chronology,<null>,Integer,int)	32	None	replace
132	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iPivotYear,  chrono,  null,  iLocale,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Integer,Chronology,<null>,Locale,int)  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iPivotYear,  chrono,  null,  iLocale,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iPivotYear,  chrono,  null,  iLocale,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    null,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Integer,Chronology,<null>,Locale,int)	32	None	replace
133	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iLocale);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,<null>,Integer,int,Locale)  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iLocale);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iLocale);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    null,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,<null>,Integer,int,Locale)	32	None	replace
134	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  0,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,<null>,int,Integer,int)  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  0,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  0,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    null,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,<null>,int,Integer,int)	32	None	replace
135	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iOffsetParsed);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,<null>,Integer,int,boolean)  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iOffsetParsed);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iOffsetParsed);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    null,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,<null>,Integer,int,boolean)	32	None	replace
136	[BUG]  [BUGGY]  long  iLocale  =  chrono.getLocale(instantLocal);  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getLocale(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getLocale(instantLocal);	      long    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
137	[BUG]  [BUGGY]  long  iLocale  =  chrono.getLocale(position);  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getLocale(position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getLocale(position);	      long    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
138	[BUG]  [BUGGY]  long  iLocale  =  instant.getLocale();  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  instant.getLocale();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  instant.getLocale();	      long    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
139	[BUG]  [BUGGY]  long  iLocale  =  instantLocal.getLocale();  [CE]  long  cannot  be  dereferenced  [FE]                              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  instantLocal.getLocale();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  instantLocal.getLocale();	      long    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  long  cannot  be  dereferenced	10	None	replace
140	[BUG]  [BUGGY]  long  iLocale  =  this.chrono.getLocale();  [CE]  cannot  find  symbol  chrono  [FE]                                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  this.chrono.getLocale();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  this.chrono.getLocale();	      long    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol  chrono	10	None	replace
141	[BUG]  [BUGGY]  long  iLocale  =  chrono.getLocale(locale);  [CE]  cannot  find  symbol  locale  [FE]                                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getLocale(locale);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getLocale(locale);	      long    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol  locale	10	None	replace
142	[BUG]  [BUGGY]  Long  iLocale  =  chrono.getLocale();  [CE]  cannot  find  symbol  [FE]                                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Long  iLocale  =  chrono.getLocale();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Long  iLocale  =  chrono.getLocale();	      long    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
143	[BUG]  [BUGGY]  long  iLocale  =  time.getLocale();  [CE]  cannot  find  symbol  time  [FE]                                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  time.getLocale();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  time.getLocale();	      long    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol  time	10	None	replace
144	[BUG]  [BUGGY]  DateTimeParser  parser  =  iParser.parseInto(instantMillis,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  iParser.parseInto(instantMillis,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  iParser.parseInto(instantMillis,  text,  position);	      DateTimeParser    parser    =    parser.parseInto(instantMillis,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	9	None	replace
145	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInto(instantMillis,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInto(instantMillis,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInto(instantMillis,  text,  position);	      DateTimeParser    parser    =    parser.parseInto(instantMillis,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	9	None	replace
146	[BUG]  [BUGGY]  Parser  parser  =  iParser.parseInto(instantMillis,  text,  position);  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Parser  parser  =  iParser.parseInto(instantMillis,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Parser  parser  =  iParser.parseInto(instantMillis,  text,  position);	      DateTimeParser    parser    =    parser.parseInto(instantMillis,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
147	[BUG]  [BUGGY]  parser  =  iParser.parseInto(instantMillis,  text,  position);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser  =  iParser.parseInto(instantMillis,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser  =  iParser.parseInto(instantMillis,  text,  position);	      DateTimeParser    parser    =    parser.parseInto(instantMillis,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	9	None	replace
148	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantMillis,  text,  position  -  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantMillis,  text,  position  -  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instantMillis,  text,  position  -  1);	      DateTimeParser    parser    =    parser.parseInto(instantMillis,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	9	None	replace
149	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDate);  [CE]  cannot  find  symbol  iDate  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDate);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDate);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iIndex);    	non-compiled	[CE]  cannot  find  symbol  iDate	49	None	replace
150	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.withChronology(parser);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.withChronology(parser);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.withChronology(parser);	      DateTimeParser    parser    =    parser.withChronology(chrono);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
151	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.withChronology(chrono);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.withChronology(chrono);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.withChronology(chrono);	      DateTimeParser    parser    =    parser.withChronology(chrono);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
152	[BUG]  [BUGGY]  DateTimeParser  parser  =  iParser.withChronology(chrono);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  iParser.withChronology(chrono);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  iParser.withChronology(chrono);	      DateTimeParser    parser    =    parser.withChronology(chrono);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
153	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.withChronology(param);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.withChronology(param);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.withChronology(param);	      DateTimeParser    parser    =    parser.withChronology(chrono);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
154	[BUG]  [BUGGY]  Parser  parser  =  chrono.withChronology(chrono);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Parser  parser  =  chrono.withChronology(chrono);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Parser  parser  =  chrono.withChronology(chrono);	      DateTimeParser    parser    =    parser.withChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol	24	None	replace
155	[BUG]  [BUGGY]  parser  =  chrono.withChronology(chrono);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser  =  chrono.withChronology(chrono);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser  =  chrono.withChronology(chrono);	      DateTimeParser    parser    =    parser.withChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol	24	None	replace
156	[BUG]  [BUGGY]  Parser  parser  =  iParser.withChronology(chrono);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Parser  parser  =  iParser.withChronology(chrono);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Parser  parser  =  iParser.withChronology(chrono);	      DateTimeParser    parser    =    parser.withChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol	24	None	replace
157	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position);	      	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
158	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position);	      	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
159	[BUG]  [BUGGY]  Chronology  chrono  =  selectChronology(instantLocal);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  Chronology  chrono  =  selectChronology(instantLocal);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	Chronology  chrono  =  selectChronology(instantLocal);	      	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
160	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParser  parser  =  parser.parseInto(instant,  text,  position);	      	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
161	[BUG]  [BUGGY]  Chronology  chrono  =  selectChronology(chrono);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  Chronology  chrono  =  selectChronology(chrono);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	Chronology  chrono  =  selectChronology(chrono);	      	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
162	[BUG]  [BUGGY]  int  iLocale  =  parser.parseInto(instant,  text,  position);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  int  iLocale  =  parser.parseInto(instant,  text,  position);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	int  iLocale  =  parser.parseInto(instant,  text,  position);	      	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	22	None	replace
163	[BUG]  [BUGGY]  instant.setMillis(instantLocal  +  chrono.getZone().getOffset(instantMillis));  [CE]  cannot  find  symbol  bucket  [FE]                                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  instant.setMillis(instantLocal  +  chrono.getZone().getOffset(instantMillis));  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	instant.setMillis(instantLocal  +  chrono.getZone().getOffset(instantMillis));	      	non-compiled	[CE]  cannot  find  symbol  bucket	22	None	replace
164	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position);	      	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
165	[BUG]  [BUGGY]  instant.setMillis(instantLocal  +  chrono.getZone().getOffset(instantLocal));  [CE]  cannot  find  symbol  bucket  [FE]                                        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  instant.setMillis(instantLocal  +  chrono.getZone().getOffset(instantLocal));  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	instant.setMillis(instantLocal  +  chrono.getZone().getOffset(instantLocal));	      	non-compiled	[CE]  cannot  find  symbol  bucket	22	None	replace
166	[BUG]  [BUGGY]  DateTimeParser  parser  =  iParser.parse(instantLocal,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  iParser.parse(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  iParser.parse(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	8	None	replace
167	[BUG]  [BUGGY]  Parser  parser  =  iParser.parse(instantLocal,  text,  position);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Parser  parser  =  iParser.parse(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Parser  parser  =  iParser.parse(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.parse(instantLocal,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	8	None	replace
168	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position  -  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position  -  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position  -  1);	      DateTimeParser    parser    =    parser.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	8	None	replace
169	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position,  iDefaultYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position,  iDefaultYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position,  iDefaultYear);	      DateTimeParser    parser    =    parser.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	8	None	replace
170	[BUG]  [BUGGY]  DateTimeParser  parser  =  iParser.parse(instant,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  iParser.parse(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  iParser.parse(instant,  text,  position);	      DateTimeParser    parser    =    parser.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	8	None	replace
171	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position,  chrono);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position,  chrono);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position,  chrono);	      DateTimeParser    parser    =    parser.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	8	None	replace
172	[BUG]  [BUGGY]  parser  =  iParser.parse(instantLocal,  text,  position);  [CE]  cannot  find  symbol  [FE]                                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser  =  iParser.parse(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser  =  iParser.parse(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.parse(instantLocal,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	8	None	replace
173	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	add
174	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);	  	non-compiled	[CE]  cannot  find  symbol	19	None	add
175	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  [CE]  not  a  statement  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);	  	non-compiled	[CE]  not  a  statement	19	None	add
176	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  [CE]  not  a  statement  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,	  	non-compiled	[CE]  not  a  statement	19	None	add
177	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  [CE]  not  a  statement  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear	  	non-compiled	[CE]  not  a  statement	19	None	add
178	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  i  [CE]  not  a  statement  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  i  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  i	  	non-compiled	[CE]  not  a  statement	19	None	add
179	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	add
180	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear  [CE]  not  a  statement  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear	  	non-compiled	[CE]  not  a  statement	19	None	add
181	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  [CE]  not  a  statement  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +	  	non-compiled	[CE]  not  a  statement	19	None	add
182	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  instantMillis,  iDefaultYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,long,int,int)  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  instantMillis,  iDefaultYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  instantMillis,  iDefaultYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iPivotParsed);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,long,int,int)	43	None	replace
183	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iDefaultYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Integer,int,int)  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iDefaultYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iDefaultYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iPivotParsed);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Integer,int,int)	43	None	replace
184	[BUG]  [BUGGY]  ZeitpunktParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  ZeitpunktParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	ZeitpunktParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iPivotParsed);    	non-compiled	[CE]  cannot  find  symbol	43	None	replace
185	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotWeekyear,  iDefaultYear,  iDefaultYear);  [CE]  cannot  find  symbol  iPivotWeekyear  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotWeekyear,  iDefaultYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotWeekyear,  iDefaultYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iPivotParsed);    	non-compiled	[CE]  cannot  find  symbol  iPivotWeekyear	43	None	replace
186	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position  -  1);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position  -  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position  -  1);	      Chronology    chrono    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	6	None	replace
187	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  iDefaultYear);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  iDefaultYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  iDefaultYear);	      Chronology    chrono    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	6	None	replace
188	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  newPos);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  newPos);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  newPos);	      Chronology    chrono    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	6	None	replace
189	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position  +  1);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position  +  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position  +  1);	      Chronology    chrono    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	6	None	replace
190	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  instantMillis);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  instantMillis);	      Chronology    chrono    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	6	None	replace
191	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  iPivotYear);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  iPivotYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  iPivotYear);	      Chronology    chrono    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	6	None	replace
192	[BUG]  [BUGGY]  Chronology  chrono  =  iParser.parseInto(instantLocal,  text,  position);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  iParser.parseInto(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  iParser.parseInto(instantLocal,  text,  position);	      Chronology    chrono    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	6	None	replace
193	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  null);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  null);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  null);	      Chronology    chrono    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	6	None	replace
194	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iDefaultYear,  iPivotYear);  [timeout]  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iDefaultYear,  iPivotYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iDefaultYear,  iPivotYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iOptionalYear);    	non-compiled	[timeout]	34	None	replace
195	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iOptionalYear,  iPivotYear);  [timeout]  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iOptionalYear,  iPivotYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iOptionalYear,  iPivotYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iOptionalYear);    	non-compiled	[timeout]	34	None	replace
196	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  locale,  iPivotYear,  iOptionalYear);  [CE]  cannot  find  symbol  locale  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  locale,  iPivotYear,  iOptionalYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  locale,  iPivotYear,  iOptionalYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iOptionalYear);    	non-compiled	[CE]  cannot  find  symbol  locale	34	None	replace
197	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iDefaultYear,  iPivotYear,  iOptionalYear);  [CE]  cannot  find  symbol  iOptionalYear  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iDefaultYear,  iPivotYear,  iOptionalYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iDefaultYear,  iPivotYear,  iOptionalYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iOptionalYear);    	non-compiled	[CE]  cannot  find  symbol  iOptionalYear	34	None	replace
198	[BUG]  [BUGGY]  Parser  parser  =  iParser.parse(instant,  text,  position);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Parser  parser  =  iParser.parse(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Parser  parser  =  iParser.parse(instant,  text,  position);	      DateTimeParser    parser    =    parser.parse(instant,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
199	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parse(instant,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parse(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parse(instant,  text,  position);	      DateTimeParser    parser    =    parser.parse(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
200	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parse(instant,  text,  position  -  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parse(instant,  text,  position  -  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parse(instant,  text,  position  -  1);	      DateTimeParser    parser    =    parser.parse(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
201	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parse(instant,  text,  position,  iDefaultYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parse(instant,  text,  position,  iDefaultYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parse(instant,  text,  position,  iDefaultYear);	      DateTimeParser    parser    =    parser.parse(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
202	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parse(instant,  text,  position,  iLocale);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parse(instant,  text,  position,  iLocale);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parse(instant,  text,  position,  iLocale);	      DateTimeParser    parser    =    parser.parse(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
203	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parse(instant,  text,  position,  chrono);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parse(instant,  text,  position,  chrono);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parse(instant,  text,  position,  chrono);	      DateTimeParser    parser    =    parser.parse(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
204	[BUG]  [BUGGY]  parser  =  iParser.parse(instant,  text,  position);  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser  =  iParser.parse(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser  =  iParser.parse(instant,  text,  position);	      DateTimeParser    parser    =    parser.parse(instant,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
205	[BUG]  [BUGGY]  int  iLocale  =  chrono.getZone().getOffset(instantLocal);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,int,Integer,int)  [FE]        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  int  iLocale  =  chrono.getZone().getOffset(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	int  iLocale  =  chrono.getZone().getOffset(instantLocal);	      long    iLocale    =    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,int,Integer,int)	35	None	replace
206	[BUG]  [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantLocal  +  1);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantLocal  +  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getZone().getOffset(instantLocal  +  1);	      long    iLocale    =    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)	35	None	replace
207	[BUG]  [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantLocal,  instantLocal);  [CE]  no  suitable  method  found  for  getOffset(long,long)  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantLocal,  instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getZone().getOffset(instantLocal,  instantLocal);	      long    iLocale    =    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  no  suitable  method  found  for  getOffset(long,long)	35	None	replace
208	[BUG]  [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantLocal)+  1;  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantLocal)+  1;  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getZone().getOffset(instantLocal)+  1;	      long    iLocale    =    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)	35	None	replace
209	[BUG]  [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantLocal,  point);  [CE]  cannot  find  symbol  point  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantLocal,  point);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getZone().getOffset(instantLocal,  point);	      long    iLocale    =    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  cannot  find  symbol  point	35	None	replace
210	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	add
211	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  not  a  statement  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  not  a  statement	13	None	add
212	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  chrono  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  chrono  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  chrono  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	add
213	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  parser  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  parser  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  parser  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	add
214	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  chrono  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  not  a  statement  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  chrono  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  chrono  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  not  a  statement	13	None	add
215	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  buf  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  buf  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  buf  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	add
216	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  instantLocal  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  variable  instantLocal  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  instantLocal  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  instantLocal  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  variable  instantLocal  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	add
217	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  [CE]  not  a  statement  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,	  	non-compiled	[CE]  not  a  statement	13	None	add
218	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  i  [CE]  not  a  statement  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  i  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  i	  	non-compiled	[CE]  not  a  statement	13	None	add
219	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  temp  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  temp  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  temp  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	add
220	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	add
221	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);	  	non-compiled	[CE]  cannot  find  symbol	29	None	add
222	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal,  chrono,  iPivotYear,  iDefaultYear);  [CE]  not  a  statement  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal,  chrono,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal,  chrono,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  not  a  statement	29	None	add
223	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal  =  chrono.computeMillis(false,  text);  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal  =  chrono.computeMillis(false,  text);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal  =  chrono.computeMillis(false,  text);	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	add
224	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  not  a  statement  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  not  a  statement	29	None	add
225	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  iParser  =  parser.parseInto(instantLocal,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iParser  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  iParser  =  parser.parseInto(instantLocal,  text,  position);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    iParser  =  parser.parseInto(instantLocal,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iParser	29	None	add
226	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  iParser  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iParser  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  iParser  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    iParser  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iParser	29	None	add
227	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  parser.parseInto(bucket,  text,  position);  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  parser.parseInto(bucket,  text,  position);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	add
228	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal  =  chrono.parseInto(bucket,  text,  position);  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal  =  chrono.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	add
229	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear,  instantLocal);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Chronology,Integer,int,long)  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear,  instantLocal);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear,  instantLocal);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    instantLocal);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Chronology,Integer,int,long)	12	None	replace
230	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  iDefaultYear,  instantLocal);  [CE]  cannot  find  symbol  iPivotXear  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  iDefaultYear,  instantLocal);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  iDefaultYear,  instantLocal);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    instantLocal);    	non-compiled	[CE]  cannot  find  symbol  iPivotXear	12	None	replace
231	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  instantLocal);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,long)  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  instantLocal);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  instantLocal);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    instantLocal);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,long)	12	None	replace
232	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,long,Chronology,Locale,Integer,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    instantLocal);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,long,Chronology,Locale,Integer,int)	12	None	replace
233	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instant,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInstant(instant,  text,  position);	      DateTimeParser    parser    =    chrono.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	40	None	replace
234	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  iDefaultYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  iDefaultYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  iDefaultYear);	      DateTimeParser    parser    =    chrono.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	40	None	replace
235	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position  -  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position  -  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position  -  1);	      DateTimeParser    parser    =    chrono.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	40	None	replace
236	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  iPivotYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  iPivotYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  iPivotYear);	      DateTimeParser    parser    =    chrono.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	40	None	replace
237	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position  +  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position  +  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position  +  1);	      DateTimeParser    parser    =    chrono.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	40	None	replace
238	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  instantMillis);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  instantMillis);	      DateTimeParser    parser    =    chrono.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	40	None	replace
239	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  newPos);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  newPos);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  newPos);	      DateTimeParser    parser    =    chrono.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	40	None	replace
240	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  null);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  null);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  null);	      DateTimeParser    parser    =    chrono.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	40	None	replace
241	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iOffsetParsed,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,boolean,Integer,int)  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iOffsetParsed,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iOffsetParsed,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iOffsetParsed);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,boolean,Integer,int)	15	None	replace
242	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldType,  iOffsetParsed);  [CE]  cannot  find  symbol  iFieldType  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldType,  iOffsetParsed);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldType,  iOffsetParsed);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iOffsetParsed);    	non-compiled	[CE]  cannot  find  symbol  iFieldType	15	None	replace
243	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iAutoChronology);  [CE]  cannot  find  symbol  iAutoChronology  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iAutoChronology);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iAutoChronology);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iOffsetParsed);    	non-compiled	[CE]  cannot  find  symbol  iAutoChronology	15	None	replace
244	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iPreviousYear);  [CE]  cannot  find  symbol  iPreviousYear  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iPreviousYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iPreviousYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iPreviousYear);    	non-compiled	[CE]  cannot  find  symbol  iPreviousYear	45	None	replace
245	[BUG]  [BUGGY]  FixedDateTimeParserBucket  bucket  =  new  FixedDateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  FixedDateTimeParserBucket  bucket  =  new  FixedDateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	FixedDateTimeParserBucket  bucket  =  new  FixedDateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iPreviousYear);    	non-compiled	[CE]  cannot  find  symbol	45	None	replace
246	[BUG]  [BUGGY]  ParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  ParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	ParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iPreviousYear);    	non-compiled	[CE]  cannot  find  symbol	45	None	replace
247	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instant,  text,  position,  instantLocal);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instant,  text,  position,  instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(instant,  text,  position,  instantLocal);	      Chronology    chrono    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	7	None	replace
248	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instant,  text,  position  -  1);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instant,  text,  position  -  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(instant,  text,  position  -  1);	      Chronology    chrono    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	7	None	replace
249	[BUG]  [BUGGY]  Chronology  chrono  =  iParser.parseInto(instant,  text,  position);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  iParser.parseInto(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  iParser.parseInto(instant,  text,  position);	      Chronology    chrono    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	7	None	replace
250	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instant,  text,  position  +  1);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instant,  text,  position  +  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(instant,  text,  position  +  1);	      Chronology    chrono    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	7	None	replace
251	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instant,  text,  position,  newPos);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instant,  text,  position,  newPos);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(instant,  text,  position,  newPos);	      Chronology    chrono    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	7	None	replace
252	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instant,  text,  position,  iDefaultYear);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instant,  text,  position,  iDefaultYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(instant,  text,  position,  iDefaultYear);	      Chronology    chrono    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	7	None	replace
253	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instant,  text,  position,  iLocale);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instant,  text,  position,  iLocale);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(instant,  text,  position,  iLocale);	      Chronology    chrono    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	7	None	replace
254	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instant,  text,  position,  iPivotYear);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instant,  text,  position,  iPivotYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(instant,  text,  position,  iPivotYear);	      Chronology    chrono    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	7	None	replace
255	[BUG]  [BUGGY]  Integer  iLocale  =  chrono.getLocale(instantLocal);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Integer  iLocale  =  chrono.getLocale(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Integer  iLocale  =  chrono.getLocale(instantLocal);	      Integer    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
256	[BUG]  [BUGGY]  Integer  iLocale  =  instant.getLocale();  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Integer  iLocale  =  instant.getLocale();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Integer  iLocale  =  instant.getLocale();	      Integer    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
257	[BUG]  [BUGGY]  Integer  iLocale  =  instantLocal.getLocale();  [CE]  long  cannot  be  dereferenced  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Integer  iLocale  =  instantLocal.getLocale();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Integer  iLocale  =  instantLocal.getLocale();	      Integer    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  long  cannot  be  dereferenced	37	None	replace
258	[BUG]  [BUGGY]  Integer  iLocale  =  instantLocal  +  chrono.getLocale();  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Integer  iLocale  =  instantLocal  +  chrono.getLocale();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Integer  iLocale  =  instantLocal  +  chrono.getLocale();	      Integer    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
259	[BUG]  [BUGGY]  Integer  iLocale  =  chrono.getLocale(position);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Integer  iLocale  =  chrono.getLocale(position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Integer  iLocale  =  chrono.getLocale(position);	      Integer    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
260	[BUG]  [BUGGY]  Integer  iLocale  =  this.chrono.getLocale();  [CE]  cannot  find  symbol  chrono  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Integer  iLocale  =  this.chrono.getLocale();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Integer  iLocale  =  this.chrono.getLocale();	      Integer    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol  chrono	37	None	replace
261	[BUG]  [BUGGY]  Integer  iLocale  =  chrono.getLocaleInt();  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Integer  iLocale  =  chrono.getLocaleInt();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Integer  iLocale  =  chrono.getLocaleInt();	      Integer    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
262	[BUG]  [BUGGY]  Integer  iLocale  =  time.getLocale();  [CE]  cannot  find  symbol  time  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Integer  iLocale  =  time.getLocale();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Integer  iLocale  =  time.getLocale();	      Integer    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol  time	37	None	replace
263	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  instantLocal);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,long)  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  instantLocal);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  instantLocal);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    0,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,long)	21	None	replace
264	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  0,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Chronology,Integer,int,int)  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  0,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  0,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    0,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Chronology,Integer,int,int)	21	None	replace
265	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iLocale);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,Locale)  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iLocale);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iLocale);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    0,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,Locale)	21	None	replace
266	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iOffsetParsed);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,boolean)  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iOffsetParsed);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iOffsetParsed);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    0,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,boolean)	21	None	replace
267	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  null);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,<null>)  [FE]                              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  null);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  null);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    0,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,<null>)	21	None	replace
268	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear  +  1);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int)  [FE]                                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear  +  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear  +  1);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    0,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int)	21	None	replace
269	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iFieldType);  [CE]  cannot  find  symbol  iFieldType  [FE]                                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iFieldType);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iFieldType);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    0,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iFieldType	21	None	replace
270	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  iPivotYear,  chrono,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Integer,Chronology,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  iPivotYear,  chrono,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  iPivotYear,  chrono,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    iLocale,    chrono,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Integer,Chronology,int)	16	None	replace
271	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  iPivotYear,  chrono,  iLocale,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Integer,Chronology,Locale,int)  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  iPivotYear,  chrono,  iLocale,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  iPivotYear,  chrono,  iLocale,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    iLocale,    chrono,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Integer,Chronology,Locale,int)	16	None	replace
272	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iPivotYear,  chrono,  iLocale,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Integer,Chronology,Locale,int)  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iPivotYear,  chrono,  iLocale,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iPivotYear,  chrono,  iLocale,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    iLocale,    chrono,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Integer,Chronology,Locale,int)	16	None	replace
273	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(iLocale,  instantLocal,  chrono,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(Locale,long,Chronology,Integer,int)  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(iLocale,  instantLocal,  chrono,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(iLocale,  instantLocal,  chrono,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    iLocale,    chrono,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(Locale,long,Chronology,Integer,int)	16	None	replace
274	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	add	instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);	      instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	compilable	  [FE]  AssertionFailedError  	4	9	replace
275	[BUG]  [BUGGY]  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantLocal);	      instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	compilable	  [FE]  AssertionFailedError  	4	9	replace
276	[BUG]  [BUGGY]  instantLocal  =  instantLocal  +  chrono.getLocalMillis().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantLocal  +  chrono.getLocalMillis().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	instantLocal  =  instantLocal  +  chrono.getLocalMillis().getOffset(instantMillis);	      instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
277	[BUG]  [BUGGY]  instantLocal  =  instantLocal  +  chrono.getChronology().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantLocal  +  chrono.getChronology().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	instantLocal  =  instantLocal  +  chrono.getChronology().getOffset(instantMillis);	      instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
278	[BUG]  [BUGGY]  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis,  position);  [CE]  no  suitable  method  found  for  getOffset(long,int)  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis,  position);	      instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  no  suitable  method  found  for  getOffset(long,int)	4	None	replace
279	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	add	instantLocal  =  instantLocal  +  chrono.getZone().getOffset(position);	      instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	compilable	  [FE]  AssertionFailedError  	4	9	replace
280	[BUG]  [BUGGY]  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(position);  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	instantLocal  =  instantLocal  +  chrono.getZone().getOffset(position);	      instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	compilable	  [FE]  AssertionFailedError  	4	9	replace
281	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis  -  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	add	instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis  -  1);	      instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	compilable	  [FE]  AssertionFailedError  	4	9	replace
282	[BUG]  [BUGGY]  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis  -  1);  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis  -  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis  -  1);	      instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	compilable	  [FE]  AssertionFailedError  	4	9	replace
283	[BUG]  [BUGGY]  instantLocal  =  instantLocal  +  chrono.getLocale().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantLocal  +  chrono.getLocale().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	instantLocal  =  instantLocal  +  chrono.getLocale().getOffset(instantMillis);	      instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
284	[BUG]  [BUGGY]  instantLocal  =  instantLocal  +  chrono.getMillis().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantLocal  +  chrono.getMillis().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	instantLocal  =  instantLocal  +  chrono.getMillis().getOffset(instantMillis);	      instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
285	[BUG]  [BUGGY]  DateTimeParser  parser  =  iParser.parseInto(instantLocal,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  iParser.parseInto(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  iParser.parseInto(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	2	None	replace
286	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInto(instantLocal,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInto(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInto(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	2	None	replace
287	[BUG]  [BUGGY]  Parser  parser  =  iParser.parseInto(instantLocal,  text,  position);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Parser  parser  =  iParser.parseInto(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Parser  parser  =  iParser.parseInto(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
288	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position,  iDefaultYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position,  iDefaultYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position,  iDefaultYear);	      DateTimeParser    parser    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	2	None	replace
289	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position  -  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position  -  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position  -  1);	      DateTimeParser    parser    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	2	None	replace
290	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position,  iPivotYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position,  iPivotYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position,  iPivotYear);	      DateTimeParser    parser    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	2	None	replace
291	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position,  chrono);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position,  chrono);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position,  chrono);	      DateTimeParser    parser    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	2	None	replace
292	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.getParser(instantLocal);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.getParser(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.getParser(instantLocal);	      DateTimeParser    parser    =    chrono.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	42	None	replace
293	[BUG]  [BUGGY]  DateTimeParser  parser  =  iChronology.getParser();  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  iChronology.getParser();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  iChronology.getParser();	      DateTimeParser    parser    =    chrono.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	42	None	replace
294	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  instantLocal);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parse(instantLocal,  instantLocal);	      DateTimeParser    parser    =    chrono.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	42	None	replace
295	[BUG]  [BUGGY]  DateTimeParser  parser  =  iChrono.getParser();  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  iChrono.getParser();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  iChrono.getParser();	      DateTimeParser    parser    =    chrono.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	42	None	replace
296	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  instantLocal);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  instantLocal);	      DateTimeParser    parser    =    chrono.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	42	None	replace
297	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parse(instantLocal);	      DateTimeParser    parser    =    chrono.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	42	None	replace
298	[BUG]  [BUGGY]  parser.parseInto(instantLocal,  text,  position,  iDefaultYear);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser.parseInto(instantLocal,  text,  position,  iDefaultYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser.parseInto(instantLocal,  text,  position,  iDefaultYear);	      parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	11	None	replace
299	[BUG]  [BUGGY]  parser.parseInto(instantLocal,  text,  position,  iPivotYear);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser.parseInto(instantLocal,  text,  position,  iPivotYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser.parseInto(instantLocal,  text,  position,  iPivotYear);	      parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	11	None	replace
300	[BUG]  [BUGGY]  parser.parseInto(instantLocal,  text,  position,  newPos);  [CE]  cannot  find  symbol  newPos  [FE]                              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser.parseInto(instantLocal,  text,  position,  newPos);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser.parseInto(instantLocal,  text,  position,  newPos);	      parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  cannot  find  symbol  newPos	11	None	replace
301	[BUG]  [BUGGY]  parser.parseInto(instantLocal,  text,  position,  chrono);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser.parseInto(instantLocal,  text,  position,  chrono);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser.parseInto(instantLocal,  text,  position,  chrono);	      parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	11	None	replace
302	[BUG]  [BUGGY]  parser.parseInto(instantLocal,  text,  position,  iLocale);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser.parseInto(instantLocal,  text,  position,  iLocale);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser.parseInto(instantLocal,  text,  position,  iLocale);	      parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	11	None	replace
303	[BUG]  [BUGGY]  parser.parseInto(instantLocal,  text,  position,  null);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser.parseInto(instantLocal,  text,  position,  null);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser.parseInto(instantLocal,  text,  position,  null);	      parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	11	None	replace
304	[BUG]  [BUGGY]  parser.parseInto(instantLocal,  text,  position,  iChrono);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser.parseInto(instantLocal,  text,  position,  iChrono);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser.parseInto(instantLocal,  text,  position,  iChrono);	      parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	11	None	replace
305	[BUG]  [BUGGY]  parser.parseInto(instantLocal,  text,  position,  instantMillis);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser.parseInto(instantLocal,  text,  position,  instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser.parseInto(instantLocal,  text,  position,  instantMillis);	      parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	11	None	replace
306	[BUG]  [BUGGY]  parser.parseInto(instant,  text,  position);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser.parseInto(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser.parseInto(instant,  text,  position);	      parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	11	None	replace
307	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iZone,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Chronology,DateTimeZone,Integer,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iZone,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iZone,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iZone,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Chronology,DateTimeZone,Integer,int)	33	None	replace
308	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  iPivotYear,  iDefaultYear,  instantLocal);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,DateTimeZone,Integer,int,long)  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  iPivotYear,  iDefaultYear,  instantLocal);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  iPivotYear,  iDefaultYear,  instantLocal);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iZone,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,DateTimeZone,Integer,int,long)	33	None	replace
309	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iSecondYear,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  iSecondYear  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iSecondYear,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iSecondYear,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iZone,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iSecondYear	33	None	replace
310	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  iPivotYear,  iDefaultYear,  iLocale);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,DateTimeZone,Integer,int,Locale)  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  iPivotYear,  iDefaultYear,  iLocale);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  iPivotYear,  iDefaultYear,  iLocale);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iZone,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,DateTimeZone,Integer,int,Locale)	33	None	replace
311	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iPivotYear,  chrono,  iZone,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Integer,Chronology,DateTimeZone,int)  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iPivotYear,  chrono,  iZone,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iPivotYear,  chrono,  iZone,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iZone,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Integer,Chronology,DateTimeZone,int)	33	None	replace
312	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  iDefaultYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  iDefaultYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  iDefaultYear);	      DateTimeParser    parser    =    chrono.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	38	None	replace
313	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position  -  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position  -  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position  -  1);	      DateTimeParser    parser    =    chrono.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	38	None	replace
314	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  iPivotYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  iPivotYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  iPivotYear);	      DateTimeParser    parser    =    chrono.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	38	None	replace
315	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position  +  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position  +  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position  +  1);	      DateTimeParser    parser    =    chrono.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	38	None	replace
316	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  instantMillis);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  instantMillis);	      DateTimeParser    parser    =    chrono.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	38	None	replace
317	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  newPos);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  newPos);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  newPos);	      DateTimeParser    parser    =    chrono.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	38	None	replace
318	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  null);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  null);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  null);	      DateTimeParser    parser    =    chrono.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	38	None	replace
319	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iLastChronology);  [CE]  cannot  find  symbol  iLastChronology  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iLastChronology);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iLastChronology);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    instantLocal);    	non-compiled	[CE]  cannot  find  symbol  iLastChronology	12	None	replace
320	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldType,  instantLocal);  [CE]  cannot  find  symbol  iFieldType  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldType,  instantLocal);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldType,  instantLocal);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    instantLocal);    	non-compiled	[CE]  cannot  find  symbol  iFieldType	12	None	replace
321	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultY  [CE]  not  a  statement  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultY  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultY	  	non-compiled	[CE]  not  a  statement	19	None	add
322	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  not  a  statement  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  not  a  statement	19	None	add
323	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1  [CE]  not  a  statement  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1	  	non-compiled	[CE]  not  a  statement	19	None	add
324	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.withParser(instantLocal);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.withParser(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.withParser(instantLocal);	      DateTimeParser    parser    =    chrono.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	42	None	replace
325	[BUG]  [BUGGY]  Parser  parser  =  chrono.parseInto(instantMillis,  text,  position);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Parser  parser  =  chrono.parseInto(instantMillis,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Parser  parser  =  chrono.parseInto(instantMillis,  text,  position);	      DateTimeParser    parser    =    parser.parseInto(instantMillis,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
326	[BUG]  [BUGGY]  IllegalArgumentException  e  =  chrono.parseInto(instantMillis,  text,  position);  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  IllegalArgumentException  e  =  chrono.parseInto(instantMillis,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	IllegalArgumentException  e  =  chrono.parseInto(instantMillis,  text,  position);	      DateTimeParser    parser    =    parser.parseInto(instantMillis,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
327	[BUG]  [BUGGY]  parser  =  chrono.parseInto(instantMillis,  text,  position);  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser  =  chrono.parseInto(instantMillis,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser  =  chrono.parseInto(instantMillis,  text,  position);	      DateTimeParser    parser    =    parser.parseInto(instantMillis,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
328	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position,  iLocale);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position,  iLocale);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position,  iLocale);	      DateTimeParser    parser    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	2	None	replace
329	[BUG]  [BUGGY]  DateTimeParser  parser  =  this.iParser.parseInto(instantLocal,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  this.iParser.parseInto(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  this.iParser.parseInto(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	2	None	replace
330	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPivotYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,Integer)  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPivotYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPivotYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iPreviousYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,Integer)	45	None	replace
331	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPreviousYear,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  iPreviousYear  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPreviousYear,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPreviousYear,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iPreviousYear);    	non-compiled	[CE]  cannot  find  symbol  iPreviousYear	45	None	replace
332	[BUG]  [BUGGY]  iChrono  =  chrono.withZone(parsedZone);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  iChrono  =  chrono.withZone(parsedZone);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	iChrono  =  chrono.withZone(parsedZone);	      iChrono    =    chrono.withZone(instantLocal);    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	26	None	replace
333	[BUG]  [BUGGY]  int  iChrono  =  chrono.withZone(instantLocal);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  int  iChrono  =  chrono.withZone(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	int  iChrono  =  chrono.withZone(instantLocal);	      iChrono    =    chrono.withZone(instantLocal);    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	26	None	replace
334	[BUG]  [BUGGY]  parsedZone  =  chrono.withZone(instantLocal);  [CE]  cannot  find  symbol  parsedZone  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parsedZone  =  chrono.withZone(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parsedZone  =  chrono.withZone(instantLocal);	      iChrono    =    chrono.withZone(instantLocal);    	non-compiled	[CE]  cannot  find  symbol  parsedZone	26	None	replace
335	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iOptionalYear);  [CE]  cannot  find  symbol  iOptionalYear  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iOptionalYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iOptionalYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iOptionalYear);    	non-compiled	[CE]  cannot  find  symbol  iOptionalYear	34	None	replace
336	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iOptionalYear,  iPivotYear,  iLocale);  [CE]  cannot  find  symbol  iOptionalYear  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iOptionalYear,  iPivotYear,  iLocale);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iOptionalYear,  iPivotYear,  iLocale);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iOptionalYear);    	non-compiled	[CE]  cannot  find  symbol  iOptionalYear	34	None	replace
337	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iFieldType,  iPivotYear,  iOptionalYear);  [CE]  cannot  find  symbol  iFieldType  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iFieldType,  iPivotYear,  iOptionalYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iFieldType,  iPivotYear,  iOptionalYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iOptionalYear);    	non-compiled	[CE]  cannot  find  symbol  iFieldType	34	None	replace
338	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  iPivotYear,  iOptionalYear);  [CE]  cannot  find  symbol  iOptionalYear  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  iPivotYear,  iOptionalYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  iPivotYear,  iOptionalYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iOptionalYear);    	non-compiled	[CE]  cannot  find  symbol  iOptionalYear	34	None	replace
339	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(iLocal,  chrono,  iZone,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  iLocal  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(iLocal,  chrono,  iZone,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(iLocal,  chrono,  iZone,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iZone,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iLocal	33	None	replace
340	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iZone,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Integer,DateTimeZone,int)  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iZone,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iZone,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iZone,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Integer,DateTimeZone,int)	33	None	replace
341	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  null,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	add	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  null,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iZone,    iPivotYear,    iDefaultYear);    	compilable	  [FE]  AssertionFailedError  	33	7	replace
342	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  null,  iPivotYear,  iDefaultYear);  [FE]  AssertionFailedError  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  null,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  null,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iZone,    iPivotYear,    iDefaultYear);    	compilable	  [FE]  AssertionFailedError  	33	7	replace
343	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  0,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,int,Integer,int)  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  0,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  0,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iZone,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,int,Integer,int)	33	None	replace
344	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPeriod);  [CE]  cannot  find  symbol  iPeriod  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPeriod);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPeriod);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iChronology);    	non-compiled	[CE]  cannot  find  symbol  iPeriod	44	None	replace
345	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDateTimeZone);  [CE]  cannot  find  symbol  iDateTimeZone  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDateTimeZone);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDateTimeZone);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iChronology);    	non-compiled	[CE]  cannot  find  symbol  iDateTimeZone	44	None	replace
346	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  iLocale);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  iLocale);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  iLocale);	      DateTimeParser    parser    =    chrono.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	38	None	replace
347	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  0);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  0);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  0);	      DateTimeParser    parser    =    chrono.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	38	None	replace
348	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.withChronology(instantLocal);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.withChronology(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.withChronology(instantLocal);	      DateTimeParser    parser    =    parser.withChronology(chrono);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
349	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.withChronology(range);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.withChronology(range);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.withChronology(range);	      DateTimeParser    parser    =    parser.withChronology(chrono);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
350	[BUG]  [BUGGY]  Parser  parser  =  chrono.withChronology(parser);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Parser  parser  =  chrono.withChronology(parser);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Parser  parser  =  chrono.withChronology(parser);	      DateTimeParser    parser    =    parser.withChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol	24	None	replace
351	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(iLocale,  chrono,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(Locale,Chronology,Integer,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(iLocale,  chrono,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(iLocale,  chrono,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    iLocale,    chrono,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(Locale,Chronology,Integer,int)	16	None	replace
352	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(chrono,  iLocale,  instantLocale,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  instantLocale  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(chrono,  iLocale,  instantLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(chrono,  iLocale,  instantLocale,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    iLocale,    chrono,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  instantLocale	16	None	replace
353	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instant,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(ReadWritableInstant,Chronology,Locale,Integer,int)  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instant,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instant,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    iLocale,    chrono,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(ReadWritableInstant,Chronology,Locale,Integer,int)	16	None	replace
354	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  pivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  pivotYear  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  pivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  pivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    iLocale,    chrono,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  pivotYear	16	None	replace
355	[BUG]  [BUGGY]  int  iLocale  =  chrono.getLocale(0);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  int  iLocale  =  chrono.getLocale(0);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	int  iLocale  =  chrono.getLocale(0);	      int    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	25	None	replace
356	[BUG]  [BUGGY]  int  iLocale  =  chrono.getLocale()  +  1;  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  int  iLocale  =  chrono.getLocale()  +  1;  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	int  iLocale  =  chrono.getLocale()  +  1;	      int    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	25	None	replace
357	[BUG]  [BUGGY]  int  iLocale  =  chrono.getLocale()  +  position;  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  int  iLocale  =  chrono.getLocale()  +  position;  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	int  iLocale  =  chrono.getLocale()  +  position;	      int    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	25	None	replace
358	[BUG]  [BUGGY]  Parser  parser  =  iParser.parseInstant(instant,  text,  position);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Parser  parser  =  iParser.parseInstant(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Parser  parser  =  iParser.parseInstant(instant,  text,  position);	      DateTimeParser    parser    =    parser.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
359	[BUG]  [BUGGY]  Parser  parser  =  chrono.parseInstant(instantLocal,  text,  position);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Parser  parser  =  chrono.parseInstant(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Parser  parser  =  chrono.parseInstant(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
360	[BUG]  [BUGGY]  parser  =  chrono.parseInstant(instantLocal,  text,  position);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser  =  chrono.parseInstant(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser  =  chrono.parseInstant(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
361	[BUG]  [BUGGY]  DateTimeParser  parser  =  iParser.createChronology(instant,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  iParser.createChronology(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  iParser.createChronology(instant,  text,  position);	      DateTimeParser    parser    =    parser.createChronology(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
362	[BUG]  [BUGGY]  DateTimeParser  parser  =  newParser(instantLocal,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  newParser(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  newParser(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.createChronology(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
363	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  iLocale);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  iLocale);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  iLocale);	      DateTimeParser    parser    =    chrono.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	40	None	replace
364	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  0);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  0);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  0);	      DateTimeParser    parser    =    chrono.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	40	None	replace
365	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantMillis,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantMillis,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInstant(instantMillis,  text,  position);	      DateTimeParser    parser    =    chrono.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	40	None	replace
366	[BUG]  [BUGGY]  long  iLocale  =  chrono.getLocale()  +  chrono.getZone().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getLocale()  +  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getLocale()  +  chrono.getZone().getOffset(instantMillis);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  cannot  find  symbol	36	None	replace
367	[BUG]  [BUGGY]  long  iLocale  =  chrono.getLocale(instantLocal)+  chrono.getZone().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getLocale(instantLocal)+  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getLocale(instantLocal)+  chrono.getZone().getOffset(instantMillis);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  cannot  find  symbol	36	None	replace
368	[BUG]  [BUGGY]  long  iLocale  =  position  +  chrono.getZone().getOffset(instantMillis);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  position  +  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  position  +  chrono.getZone().getOffset(instantMillis);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)	36	None	replace
369	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iEndYear);  [CE]  cannot  find  symbol  iEndYear  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iEndYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iEndYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iEndYear	46	None	replace
370	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldType,  iDefaultYear);  [CE]  cannot  find  symbol  iFieldType  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldType,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldType,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iFieldType	46	None	replace
371	[BUG]  [BUGGY]  DateTimeParser  parser  =  this.iParser.parseInto(instant,  text,  position  -  instantLocal);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  this.iParser.parseInto(instant,  text,  position  -  instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  this.iParser.parseInto(instant,  text,  position  -  instantLocal);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position    -    instantLocal);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
372	[BUG]  [BUGGY]  Parser  parser  =  chrono.parseInto(instant,  text,  position  -  instantLocal);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Parser  parser  =  chrono.parseInto(instant,  text,  position  -  instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Parser  parser  =  chrono.parseInto(instant,  text,  position  -  instantLocal);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position    -    instantLocal);    	non-compiled	[CE]  cannot  find  symbol	28	None	replace
373	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  instantLocal  +  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  instantLocal  +  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  instantLocal  +  1);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position    -    instantLocal);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
374	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotXear,  iDefaultYear);  [CE]  cannot  find  symbol  iPivotXear  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotXear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotXear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iPivotXear	18	None	replace
375	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iChronology);  [CE]  cannot  find  symbol  iChronology  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iChronology);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iChronology);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iChronology	18	None	replace
376	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear  +  1);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,Integer,int)  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear  +  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear  +  1);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,Integer,int)	18	None	replace
377	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotZone,  iDefaultYear);  [CE]  cannot  find  symbol  iPivotZone  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotZone,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotZone,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iPivotZone	18	None	replace
378	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iValue);  [CE]  cannot  find  symbol  iValue  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iValue);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iValue);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iValue	18	None	replace
379	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(iLocale,  chrono,  0,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(Locale,Chronology,int,Locale,Integer,int)  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(iLocale,  chrono,  0,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(iLocale,  chrono,  0,  iLocale,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(Locale,Chronology,int,Locale,Integer,int)	18	None	replace
380	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  iLocale);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  iLocale);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  iLocale);	      Chronology    chrono    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	6	None	replace
381	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(bucket,  text,  position);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(bucket,  text,  position);	      Chronology    chrono    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	6	None	replace
382	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iChronology);  [CE]  cannot  find  symbol  iChronology  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iChronology);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iChronology);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    null,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iChronology	32	None	replace
383	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotXear,  iDefaultYear);  [CE]  cannot  find  symbol  iPivotXear  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotXear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotXear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    null,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iPivotXear	32	None	replace
384	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iValue);  [CE]  cannot  find  symbol  iValue  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iValue);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iValue);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    null,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iValue	32	None	replace
385	[BUG]  [BUGGY]  instantLocal  =  instantLocal  +  chrono.getLocalFamily().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantLocal  +  chrono.getLocalFamily().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	instantLocal  =  instantLocal  +  chrono.getLocalFamily().getOffset(instantMillis);	      instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
386	[BUG]  [BUGGY]  instantLocal  =  instantLocal  +  chrono.getLocalFactory().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantLocal  +  chrono.getLocalFactory().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	instantLocal  =  instantLocal  +  chrono.getLocalFactory().getOffset(instantMillis);	      instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
387	[BUG]  [BUGGY]  instantLocal  =  instantLocal  +  chrono.getLocalDate().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantLocal  +  chrono.getLocalDate().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	instantLocal  =  instantLocal  +  chrono.getLocalDate().getOffset(instantMillis);	      instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
388	[BUG]  [BUGGY]  instantLocal  =  instantLocal  +  chrono.getLocalName().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantLocal  +  chrono.getLocalName().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	instantLocal  =  instantLocal  +  chrono.getLocalName().getOffset(instantMillis);	      instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
389	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  instant  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  variable  instant  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  instant  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  instant  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  variable  instant  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	add
390	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  stop  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  stop  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  stop  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	add
391	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  buf  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  not  a  statement  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  buf  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  buf  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  not  a  statement	13	None	add
392	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,<null>,Integer,int)  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear);	  final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,<null>,Integer,int)	14	None	replace
393	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,DateTimeZone,Integer,int)  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  iPivotYear,  iDefaultYear);	  final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,DateTimeZone,Integer,int)	14	None	replace
394	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  null,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	add	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  null,  iPivotYear,  iDefaultYear);	  final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	compilable	  [FE]  AssertionFailedError  	14	7	replace
395	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  null,  iPivotYear,  iDefaultYear);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  null,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  null,  iPivotYear,  iDefaultYear);	  final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	compilable	  [FE]  AssertionFailedError  	14	7	replace
396	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOptionalChronology);  [CE]  cannot  find  symbol  iOptionalChronology  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOptionalChronology);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOptionalChronology);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iPercentile);    	non-compiled	[CE]  cannot  find  symbol  iOptionalChronology	48	None	replace
397	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear).setMillis(parser.computeMillis(false,  text));  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear).setMillis(parser.computeMillis(false,  text));  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear).setMillis(parser.computeMillis(false,  text));	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	add
398	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  super.setMillis(parser.computeMillis(false,  text));  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  super.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  super.setMillis(parser.computeMillis(false,  text));	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	add
399	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear);  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear);	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	add
400	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal  =  chrono,  iPivotYear,  iDefaultYear);  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal  =  chrono,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal  =  chrono,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  ';'  expected	29	None	add
401	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal  =  chrono,  iLocale,  0,  iPivotYear);  [CE]  ';'  expected  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal  =  chrono,  iLocale,  0,  iPivotYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  instantLocal  =  chrono,  iLocale,  0,  iPivotYear);	  	non-compiled	[CE]  ';'  expected	29	None	add
402	[BUG]  [BUGGY]  DateTimeParser  parser  =  this.iParser.parse(instant,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  this.iParser.parse(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  this.iParser.parse(instant,  text,  position);	      DateTimeParser    parser    =    parser.parse(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
403	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parse(instant,  text,  position,  iPivotYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parse(instant,  text,  position,  iPivotYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parse(instant,  text,  position,  iPivotYear);	      DateTimeParser    parser    =    parser.parse(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
404	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parse(instant,  text,  position  +  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parse(instant,  text,  position  +  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parse(instant,  text,  position  +  1);	      DateTimeParser    parser    =    parser.parse(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
405	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parse(instant,  text,  position,  iLocal);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parse(instant,  text,  position,  iLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parse(instant,  text,  position,  iLocal);	      DateTimeParser    parser    =    parser.parse(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
406	[BUG]  [BUGGY]  long  iLocale  =  instantLocal  +  chrono.getLocale().getOffset(instantLocal);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  instantLocal  +  chrono.getLocale().getOffset(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  instantLocal  +  chrono.getLocale().getOffset(instantLocal);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  cannot  find  symbol	39	None	replace
407	[BUG]  [BUGGY]  long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantLocal  +  1);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantLocal  +  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantLocal  +  1);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)	39	None	replace
408	[BUG]  [BUGGY]  long  iLocale  =  chrono.getLocale()  +  chrono.getZone().getOffset(instantLocal);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getLocale()  +  chrono.getZone().getOffset(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getLocale()  +  chrono.getZone().getOffset(instantLocal);	      long    iLocale    =    instantLocal    +    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  cannot  find  symbol	39	None	replace
409	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position  +  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position  +  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position  +  1);	      DateTimeParser    parser    =    parser.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	8	None	replace
410	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position,  iPivotYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position,  iPivotYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position,  iPivotYear);	      DateTimeParser    parser    =    parser.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	8	None	replace
411	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position,  iLocale);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position,  iLocale);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parse(instantLocal,  text,  position,  iLocale);	      DateTimeParser    parser    =    parser.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	8	None	replace
412	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iOptional,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  iOptional  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iOptional,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iOptional,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iOptional);    	non-compiled	[CE]  cannot  find  symbol  iOptional	47	None	replace
413	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iOptional,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  iOptional  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iOptional,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iOptional,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iOptional);    	non-compiled	[CE]  cannot  find  symbol  iOptional	47	None	replace
414	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iOptional);  [CE]  cannot  find  symbol  iOptional  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iOptional);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iOptional);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iOptional);    	non-compiled	[CE]  cannot  find  symbol  iOptional	47	None	replace
415	[BUG]  [BUGGY]  long  iLocale  =  chrono.getLocale()  +  1;  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getLocale()  +  1;  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getLocale()  +  1;	      long    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
416	[BUG]  [BUGGY]  long  iLocale  =  chrono.getLocale(0);  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getLocale(0);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getLocale(0);	      long    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
417	[BUG]  [BUGGY]  long  iLocale  =  chrono.getLocale(null);  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getLocale(null);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getLocale(null);	      long    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
418	[BUG]  [BUGGY]  long  iLocale  =  chrono.getLocale().getOffset(instantLocal);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getLocale().getOffset(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getLocale().getOffset(instantLocal);	      long    iLocale    =    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
419	[BUG]  [BUGGY]  Integer  iLocale  =  chrono.getLocale(locale);  [CE]  cannot  find  symbol  locale  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Integer  iLocale  =  chrono.getLocale(locale);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Integer  iLocale  =  chrono.getLocale(locale);	      Integer    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol  locale	37	None	replace
420	[BUG]  [BUGGY]  Integer  iLocale  =  chrono.getLocale(0);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Integer  iLocale  =  chrono.getLocale(0);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Integer  iLocale  =  chrono.getLocale(0);	      Integer    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
421	[BUG]  [BUGGY]  Integer  iLocale  =  chrono.withLocale(instantLocal);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Integer  iLocale  =  chrono.withLocale(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Integer  iLocale  =  chrono.withLocale(instantLocal);	      Integer    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
422	[BUG]  [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantMillis  +  1);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantMillis  +  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getZone().getOffset(instantMillis  +  1);	      long    iLocale    =    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)	41	None	replace
423	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [CE]  cannot  find  symbol  iLocal  [FE]    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);	  	non-compiled	[CE]  cannot  find  symbol  iLocal	3	None	add
424	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  initialLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [CE]  cannot  find  symbol  initialLocal  [FE]      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  initialLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  initialLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);	  	non-compiled	[CE]  cannot  find  symbol  initialLocal	3	None	add
425	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [CE]  cannot  assign  a  value  to  final  variable  iLocale  [FE]        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  iLocale  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iLocale	3	None	add
426	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getLastZone().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getLastZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getLastZone().getOffset(instantMillis);	  	non-compiled	[CE]  cannot  find  symbol	3	None	add
427	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getOwner().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getOwner().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getOwner().getOffset(instantMillis);	  	non-compiled	[CE]  cannot  find  symbol	3	None	add
428	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getPivotZone().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getPivotZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getPivotZone().getOffset(instantMillis);	  	non-compiled	[CE]  cannot  find  symbol	3	None	add
429	[BUG]  [BUGGY]  DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);	      	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
430	[BUG]  [BUGGY]  DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));	      	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
431	[BUG]  [BUGGY]  DateTimeParserBucket  parser  =  parser.parseInto(instantLocal,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  parser  =  parser.parseInto(instantLocal,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  parser  =  parser.parseInto(instantLocal,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));	      	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
432	[BUG]  [BUGGY]  Integer  iLocale  =  parser.parseInto(instant,  text,  position);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  Integer  iLocale  =  parser.parseInto(instant,  text,  position);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	Integer  iLocale  =  parser.parseInto(instant,  text,  position);	      	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	22	None	replace
433	[BUG]  [BUGGY]  DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);  iLocale,  iPivotYear,  iDefaultYear);  [CE]  not  a  statement  [FE]                                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);  iLocale,  iPivotYear,  iDefaultYear);	      	non-compiled	[CE]  not  a  statement	22	None	replace
434	[BUG]  [BUGGY]  DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);  instant.setLocal(parser.computeMillis(false,  text));  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);  instant.setLocal(parser.computeMillis(false,  text));  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);  instant.setLocal(parser.computeMillis(false,  text));	      	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
435	[BUG]  [BUGGY]  DateTimeParserBucket  parser  =  parser.parseInto(instantLocal,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  parser  =  parser.parseInto(instantLocal,  text,  position);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  parser  =  parser.parseInto(instantLocal,  text,  position);	      	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
436	[BUG]  [BUGGY]  DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);  instant.setMillis(paramser.computeMillis(false,  text));  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);  instant.setMillis(paramser.computeMillis(false,  text));  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);  instant.setMillis(paramser.computeMillis(false,  text));	      	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
437	[BUG]  [BUGGY]  DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);  instant.setMillis(paraser.computeMillis(false,  text));  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);  instant.setMillis(paraser.computeMillis(false,  text));  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  parser  =  parser.parseInto(instant,  text,  position);  instant.setMillis(paraser.computeMillis(false,  text));	      	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
438	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	30	None	replace
439	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  0,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,DateTimeZone,int,int)  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  0,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  0,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,DateTimeZone,int,int)	30	None	replace
440	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear  *  iDefaultYear);  [timeout]  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear  *  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear  *  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    	non-compiled	[timeout]	30	None	replace
441	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPivotLocale);  [CE]  cannot  find  symbol  iPivotLocale  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPivotLocale);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPivotLocale);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iIndex);    	non-compiled	[CE]  cannot  find  symbol  iPivotLocale	49	None	replace
442	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  iDefaultYear);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  iDefaultYear);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
443	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
444	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  pivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  pivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  pivotYear,  iDefaultYear);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
445	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
446	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iEndOfDay);  [CE]  cannot  find  symbol  iEndOfDay  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iEndOfDay);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iEndOfDay);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iOffsetParsed);    	non-compiled	[CE]  cannot  find  symbol  iEndOfDay	15	None	replace
447	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  locale,  iPivotYear,  iDefaultYear,  iDefaultYear);  [CE]  cannot  find  symbol  locale  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  locale,  iPivotYear,  iDefaultYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  locale,  iPivotYear,  iDefaultYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iPivotParsed);    	non-compiled	[CE]  cannot  find  symbol  locale	43	None	replace
448	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  bucket  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser.parseInto(bucket,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser.parseInto(bucket,  text,  position);	      parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  cannot  find  symbol  bucket	11	None	replace
449	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  0,  iDefaultYear);  [CE]  cannot  find  symbol  iPivotXear  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  0,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  0,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    0,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iPivotXear	21	None	replace
450	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iValue);  [CE]  cannot  find  symbol  iValue  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iValue);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iValue);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    0,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iValue	21	None	replace
451	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iPivotOffset);  [CE]  cannot  find  symbol  iPivotOffset  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iPivotOffset);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iPivotOffset);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    0,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iPivotOffset	21	None	replace
452	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(iLocale,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(Locale,Chronology,Locale,Integer,int,int)  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(iLocale,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(iLocale,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    0,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(Locale,Chronology,Locale,Integer,int,int)	21	None	replace
453	[BUG]  [BUGGY]  DateTimeParser  parser  =  this.iParser.parseInto(instant,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  this.iParser.parseInto(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  this.iParser.parseInto(instant,  text,  position);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	1	None	replace
454	[BUG]  [BUGGY]  Parser  parser  =  chrono.parseInto(instant,  text,  position);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Parser  parser  =  chrono.parseInto(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Parser  parser  =  chrono.parseInto(instant,  text,  position);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	1	None	replace
455	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position,  iPivotYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position,  iPivotYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instant,  text,  position,  iPivotYear);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	1	None	replace
456	[BUG]  [BUGGY]  if(chrono!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }  [CE]  cannot  find  symbol  bucket  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  if(chrono!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	if(chrono!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	non-compiled	[CE]  cannot  find  symbol  bucket	20	None	replace
457	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  2);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	add	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  2);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	compilable	  [FE]  AssertionFailedError  	20	7	replace
458	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  2);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  2);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  2);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	compilable	  [FE]  AssertionFailedError  	20	7	replace
459	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  3);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	add	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  3);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	compilable	  [FE]  AssertionFailedError  	20	7	replace
460	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  3);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  3);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  3);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	compilable	  [FE]  AssertionFailedError  	20	7	replace
461	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear  +  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	add	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear  +  1);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	compilable	  [FE]  AssertionFailedError  	20	7	replace
462	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear  +  1);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear  +  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear  +  1);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	compilable	  [FE]  AssertionFailedError  	20	7	replace
463	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instant,  text,  position,  iLocal);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instant,  text,  position,  iLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(instant,  text,  position,  iLocal);	      Chronology    chrono    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	7	None	replace
464	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  iDefaultYear,  iDefaultYear);  [CE]  cannot  find  symbol  iPivotXear  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  iDefaultYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  iDefaultYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    instantLocal);    	non-compiled	[CE]  cannot  find  symbol  iPivotXear	12	None	replace
465	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Chronology,Integer,int,int)  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    instantLocal);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Locale,Chronology,Integer,int,int)	12	None	replace
466	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iValueChangeEvent);  [CE]  cannot  find  symbol  iValueChangeEvent  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iValueChangeEvent);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iValueChangeEvent);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    instantLocal);    	non-compiled	[CE]  cannot  find  symbol  iValueChangeEvent	12	None	replace
467	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPivotParsed);  [CE]  cannot  find  symbol  iPivotParsed  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPivotParsed);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPivotParsed);	  final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iPivotParsed	14	None	replace
468	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iChronology);  [CE]  cannot  find  symbol  iChronology  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iChronology);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iChronology);	  final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iChronology	14	None	replace
469	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int)  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear);	  final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int)	14	None	replace
470	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPreviousYear);  [CE]  cannot  find  symbol  iPreviousYear  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPreviousYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPreviousYear);	  final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iPreviousYear	14	None	replace
471	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOptional);  [CE]  cannot  find  symbol  iOptional  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOptional);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOptional);	  final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iOptional	14	None	replace
472	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPointer);  [CE]  cannot  find  symbol  iPointer  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPointer);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPointer);	  final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iPointer	14	None	replace
473	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPercentile);  [CE]  cannot  find  symbol  iPercentile  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPercentile);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPercentile);	  final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iPercentile	14	None	replace
474	[BUG]  [BUGGY]  long  iLocale  =  instantLocal  +  chrono.getLocale();  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  instantLocal  +  chrono.getLocale();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  instantLocal  +  chrono.getLocale();	      long    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
475	[BUG]  [BUGGY]  long  iLocale  =  chrono.withLocale(instantLocal);  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.withLocale(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.withLocale(instantLocal);	      long    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
476	[BUG]  [BUGGY]  long  iLocale  =  chrono.getLocale()  +  instantLocal;  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getLocale()  +  instantLocal;  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getLocale()  +  instantLocal;	      long    iLocale    =    chrono.getLocale();    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
477	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position,  iLocale);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position,  iLocale);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position,  iLocale);	      DateTimeParser    parser    =    parser.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	5	None	replace
478	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position  +  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position  +  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position  +  1);	      DateTimeParser    parser    =    parser.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	5	None	replace
479	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position,  iPivotYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position,  iPivotYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInstant(instantLocal,  text,  position,  iPivotYear);	      DateTimeParser    parser    =    parser.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	5	None	replace
480	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iSecond,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  iSecond  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iSecond,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iSecond,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iZone,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iSecond	33	None	replace
481	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iDefaultYear,  iPivotYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Integer,int,Integer)  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iDefaultYear,  iPivotYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iDefaultYear,  iPivotYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iZone,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Integer,int,Integer)	33	None	replace
482	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iDate,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  iDate  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iDate,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iDate,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iZone,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iDate	33	None	replace
483	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  iPivotYear,  iDefaultYear,  iChronology);  [CE]  cannot  find  symbol  iChronology  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  iPivotYear,  iDefaultYear,  iChronology);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iZone,  iPivotYear,  iDefaultYear,  iChronology);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iZone,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iChronology	33	None	replace
484	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  1,  iDefaultYear);  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  1,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  1,  iDefaultYear);	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	add
485	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  super.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  super.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear);  super.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	29	None	add
486	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,int)	46	None	replace
487	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iChronology);  [CE]  cannot  find  symbol  iChronology  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iChronology);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iChronology);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iChronology	46	None	replace
488	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iDefaultYear,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,Integer,int)  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iDefaultYear,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iDefaultYear,  iPivotYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,Integer,int)	46	None	replace
489	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iLocale);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,Locale)  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iLocale);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iLocale);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,Locale)	46	None	replace
490	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iFieldType);  [CE]  cannot  find  symbol  iFieldType  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iFieldType);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iFieldType);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iFieldType	46	None	replace
491	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position,  chrono);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position,  chrono);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instant,  text,  position,  chrono);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	1	None	replace
492	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);	  	non-compiled	[CE]  ';'  expected	19	None	add
493	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono.computeMillis(false,  text);  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono.computeMillis(false,  text);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono.computeMillis(false,  text);	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	add
494	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono.computeMillis(text,  position);  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono.computeMillis(text,  position);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono.computeMillis(text,  position);	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	add
495	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1;  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1;  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1;	  	non-compiled	[CE]  ';'  expected	19	None	add
496	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono,  iLocale,  iPivotYear,  iDefaultYear  [CE]  ';'  expected  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono,  iLocale,  iPivotYear,  iDefaultYear  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono,  iLocale,  iPivotYear,  iDefaultYear	  	non-compiled	[CE]  ';'  expected	19	None	add
497	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono;  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono;  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono;	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	add
498	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono.parseInto(bucket,  text,  position  [CE]  ')'  expected  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono.parseInto(bucket,  text,  position  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  instantLocal  =  chrono.parseInto(bucket,  text,  position	  	non-compiled	[CE]  ')'  expected	19	None	add
499	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.withChronology(params);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.withChronology(params);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.withChronology(params);	      DateTimeParser    parser    =    parser.withChronology(chrono);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
500	[BUG]  [BUGGY]  DateTimeParser  chrono  =  parser.withChronology(chrono);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  chrono  =  parser.withChronology(chrono);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  chrono  =  parser.withChronology(chrono);	      DateTimeParser    parser    =    parser.withChronology(chrono);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	replace
501	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,<null>,Integer,int,int)  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    null,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,<null>,Integer,int,int)	32	None	replace
502	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iEnd);  [CE]  cannot  find  symbol  iEnd  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iEnd);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iEnd);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    null,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iEnd	32	None	replace
503	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iOptional);  [CE]  cannot  find  symbol  iOptional  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iOptional);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  null,  iPivotYear,  iDefaultYear,  iOptional);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    null,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iOptional	32	None	replace
504	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  instantLocal,  iPivotYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  instantLocal,  iPivotYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  instantLocal,  iPivotYear);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position    -    instantLocal);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
505	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  instantLocal,  iLocale);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  instantLocal,  iLocale);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instant,  text,  position  -  instantLocal,  iLocale);	      DateTimeParser    parser    =    parser.parseInto(instant,    text,    position    -    instantLocal);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
506	[BUG]  [BUGGY]  int  iLocale  =  parser.parseInto(instant,  text,  position);  instant.setMillis(iChrono.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  int  iLocale  =  parser.parseInto(instant,  text,  position);  instant.setMillis(iChrono.computeMillis(false,  text));  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	int  iLocale  =  parser.parseInto(instant,  text,  position);  instant.setMillis(iChrono.computeMillis(false,  text));	      	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	22	None	replace
507	[BUG]  [BUGGY]  int  iLocale  =  parser.parseInto(instant,  text,  position);  instant.setMillis(iLocale,  iPivotYear,  iDefaultYear);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  int  iLocale  =  parser.parseInto(instant,  text,  position);  instant.setMillis(iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	int  iLocale  =  parser.parseInto(instant,  text,  position);  instant.setMillis(iLocale,  iPivotYear,  iDefaultYear);	      	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	22	None	replace
508	[BUG]  [BUGGY]  int  iLocale  =  parser.parseInto(instantLocal,  text,  position);  instant.setMillis(iChrono.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  int  iLocale  =  parser.parseInto(instantLocal,  text,  position);  instant.setMillis(iChrono.computeMillis(false,  text));  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	int  iLocale  =  parser.parseInto(instantLocal,  text,  position);  instant.setMillis(iChrono.computeMillis(false,  text));	      	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	22	None	replace
509	[BUG]  [BUGGY]  Integer  iLocale  =  chrono.getLocale();  [CE]  cannot  find  symbol  [FE]                              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  Integer  iLocale  =  chrono.getLocale();  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	Integer  iLocale  =  chrono.getLocale();	      	non-compiled	[CE]  cannot  find  symbol	22	None	replace
510	[BUG]  [BUGGY]  int  iLocale  =  chrono.getLocale();  [CE]  cannot  find  symbol  [FE]                                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  int  iLocale  =  chrono.getLocale();  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	int  iLocale  =  chrono.getLocale();	      	non-compiled	[CE]  cannot  find  symbol	22	None	replace
511	[BUG]  [BUGGY]  long  iLocale  =  chrono.getLocale();  [CE]  cannot  find  symbol  [FE]                                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  long  iLocale  =  chrono.getLocale();  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	long  iLocale  =  chrono.getLocale();	      	non-compiled	[CE]  cannot  find  symbol	22	None	replace
512	[BUG]  [BUGGY]  int  iLocale  =  parser.parseInto(instantLocal,  text,  position);  instant.setMillis(iLocale,  iPivotYear,  iDefaultYear);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  int  iLocale  =  parser.parseInto(instantLocal,  text,  position);  instant.setMillis(iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	int  iLocale  =  parser.parseInto(instantLocal,  text,  position);  instant.setMillis(iLocale,  iPivotYear,  iDefaultYear);	      	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	22	None	replace
513	[BUG]  [BUGGY]  int  iLocale  =  parser.parseInto(instant,  text,  position);  instant.setMillis(timeZone.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  int  iLocale  =  parser.parseInto(instant,  text,  position);  instant.setMillis(timeZone.computeMillis(false,  text));  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	int  iLocale  =  parser.parseInto(instant,  text,  position);  instant.setMillis(timeZone.computeMillis(false,  text));	      	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	22	None	replace
514	[BUG]  [BUGGY]  if(chrono!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }  else  {  instantLo  [CE]  not  a  statement  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  if(chrono!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }  else  {  instantLo  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	if(chrono!=  null)  {  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  +  1);  }  else  {  instantLo	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	non-compiled	[CE]  not  a  statement	20	None	replace
515	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear  +  1);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int)  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear  +  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear  +  1);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int)	20	None	replace
516	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  0,  iDefaultYear  +  1);  [CE]  ')'  expected  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  0,  iDefaultYear  +  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear  0,  iDefaultYear  +  1);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	non-compiled	[CE]  ')'  expected	20	None	replace
517	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  iDefaultYear  +  1);  [CE]  cannot  find  symbol  iPivotXear  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  iDefaultYear  +  1);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotXear,  iDefaultYear  +  1);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear    +    1);    	non-compiled	[CE]  cannot  find  symbol  iPivotXear	20	None	replace
518	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position  +  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position  +  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instantLocal,  text,  position  +  1);	      DateTimeParser    parser    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	2	None	replace
519	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iAdvancedChronology);  [CE]  cannot  find  symbol  iAdvancedChronology  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iAdvancedChronology);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iAdvancedChronology);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iOptional);    	non-compiled	[CE]  cannot  find  symbol  iAdvancedChronology	47	None	replace
520	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iMaximumYears);  [CE]  cannot  find  symbol  iMaximumYears  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iMaximumYears);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iMaximumYears);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iOptional);    	non-compiled	[CE]  cannot  find  symbol  iMaximumYears	47	None	replace
521	[BUG]  [BUGGY]  long  iLocale  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)  [FE]                    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);	      long    iLocale    =    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,long,Integer,int)	41	None	replace
522	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iDefaultYear,  iLocale);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Integer,int,Locale)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iDefaultYear,  iLocale);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iPivotYear,  iDefaultYear,  iLocale);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    iLocale,    chrono,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Integer,int,Locale)	16	None	replace
523	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear,  iPivotChear);  [CE]  cannot  find  symbol  iPivotChear  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear,  iPivotChear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear,  iPivotChear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    iLocale,    chrono,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iPivotChear	16	None	replace
524	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear,  iPivotZone);  [CE]  cannot  find  symbol  iPivotZone  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear,  iPivotZone);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  iLocale,  chrono,  iPivotYear,  iDefaultYear,  iPivotZone);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    iLocale,    chrono,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iPivotZone	16	None	replace
525	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  -1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  -1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parse(instantLocal,  text,  position,  -1);	      DateTimeParser    parser    =    chrono.parse(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	38	None	replace
526	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPivotParsed);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPivotParsed);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPivotParsed);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
527	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iChronology);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iChronology);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iChronology);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
528	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOffsetParsed);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOffsetParsed);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOffsetParsed);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
529	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOptional);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOptional);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iOptional);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
530	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPreviousYear);  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPreviousYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPreviousYear);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
531	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPointer);  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPointer);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPointer);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
532	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPercentile);  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPercentile);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iPercentile);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
533	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldType);  [CE]  cannot  find  symbol  [FE]                              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldType);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iFieldType);	  TimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
534	[BUG]  [BUGGY]  instantLocal  =  instantLocal  +  chrono.getTime().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  instantLocal  =  instantLocal  +  chrono.getTime().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	instantLocal  =  instantLocal  +  chrono.getTime().getOffset(instantMillis);	      instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
535	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parse(instantLocal,  text);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parse(instantLocal,  text);	      DateTimeParser    parser    =    chrono.getParser();    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	42	None	replace
536	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parser(instantLocal);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parser(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parser(instantLocal);	      DateTimeParser    parser    =    parser.createChronology(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
537	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parser();  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parser();  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parser();	      DateTimeParser    parser    =    parser.createChronology(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
538	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInt(instantLocal,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInt(instantLocal,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInt(instantLocal,  text,  position);	      DateTimeParser    parser    =    parser.createChronology(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
539	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iItemXear,  iDefaultYear);  [CE]  cannot  find  symbol  iItemXear  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iItemXear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iItemXear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotXear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iItemXear	31	None	replace
540	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iIndex,  iDefaultYear);  [CE]  cannot  find  symbol  iIndex  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iIndex,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iIndex,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotXear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iIndex	31	None	replace
541	[BUG]  [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantLocal,  index);  [CE]  cannot  find  symbol  index  [FE]        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  long  iLocale  =  chrono.getZone().getOffset(instantLocal,  index);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	long  iLocale  =  chrono.getZone().getOffset(instantLocal,  index);	      long    iLocale    =    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  cannot  find  symbol  index	35	None	replace
542	[BUG]  [BUGGY]  Integer  iLocale  =  chrono.getZone().getOffset(instantLocal);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Integer,Integer,int)  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Integer  iLocale  =  chrono.getZone().getOffset(instantLocal);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Integer  iLocale  =  chrono.getZone().getOffset(instantLocal);	      long    iLocale    =    chrono.getZone().getOffset(instantLocal);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Integer,Integer,int)	35	None	replace
543	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  1);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  1);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseInstant(instantLocal,  text,  position,  1);	      DateTimeParser    parser    =    chrono.parseInstant(instantLocal,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	40	None	replace
544	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseWithChronology(instant,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  chrono.parseWithChronology(instant,  text,  position);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  chrono.parseWithChronology(instant,  text,  position);	      DateTimeParser    parser    =    parser.parse(instant,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
545	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getName().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getName().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getName().getOffset(instantMillis);	  	non-compiled	[CE]  cannot  find  symbol	3	None	add
546	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  InstantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [CE]  cannot  find  symbol  InstantLocal  [FE]      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  InstantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    InstantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);	  	non-compiled	[CE]  cannot  find  symbol  InstantLocal	3	None	add
547	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getField().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getField().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getField().getOffset(instantMillis);	  	non-compiled	[CE]  cannot  find  symbol	3	None	add
548	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  InstantLocal  +  chrono.getZone().getOffset(instantMillis);  [CE]  cannot  find  symbol  InstantLocal  [FE]          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  InstantLocal  +  chrono.getZone().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  InstantLocal  +  chrono.getZone().getOffset(instantMillis);	  	non-compiled	[CE]  cannot  find  symbol  InstantLocal	3	None	add
549	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getSecond().getOffset(instantMillis);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getSecond().getOffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getSecond().getOffset(instantMillis);	  	non-compiled	[CE]  cannot  find  symbol	3	None	add
550	[BUG]  [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getoffset(instantMillis);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]      instantLocal  =  instantLocal  +  chrono.getZone().getOffset(instantMillis);  instantLocal  =  instantLocal  +  chrono.getZone().getoffset(instantMillis);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	        instantLocal    =    instantLocal    +    chrono.getZone().getOffset(instantMillis);    instantLocal  =  instantLocal  +  chrono.getZone().getoffset(instantMillis);	  	non-compiled	[CE]  cannot  find  symbol	3	None	add
551	[BUG]  [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	TimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iPivotParsed);    	non-compiled	[CE]  cannot  find  symbol	43	None	replace
552	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear,  iPivotYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,int,Integer)  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear,  iPivotYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iDefaultYear,  iPivotYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,int,Integer)	30	None	replace
553	[BUG]  [BUGGY]  parser.parseInto(instantLocal,  text,  position,  iDate);  [CE]  cannot  find  symbol  iDate  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  parser.parseInto(instantLocal,  text,  position,  iDate);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	parser.parseInto(instantLocal,  text,  position,  iDate);	      parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  cannot  find  symbol  iDate	11	None	replace
554	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  0,  iPivotLocal);  [CE]  cannot  find  symbol  iPivotLocal  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  0,  iPivotLocal);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  0,  iPivotLocal);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    0,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iPivotLocal	21	None	replace
555	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,int)  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    0,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,int)	21	None	replace
556	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  0,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,int)  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  0,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  0,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    0,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,int)	21	None	replace
557	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iValue);  [CE]  cannot  find  symbol  iValue  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iValue);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iValue);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    0,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iValue	21	None	replace
558	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iPivotLocal);  [CE]  cannot  find  symbol  iPivotLocal  [FE]                              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iPivotLocal);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iPivotLocal);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    0,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iPivotLocal	21	None	replace
559	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iChronology);  [CE]  cannot  find  symbol  iChronology  [FE]                                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iChronology);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  0,  iDefaultYear,  iChronology);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    0,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iChronology	21	None	replace
560	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,Integer,int,int)  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,int,Integer,int,int)	18	None	replace
561	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iIndex);  [CE]  cannot  find  symbol  iIndex  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iIndex);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iIndex);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iIndex	18	None	replace
562	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iFieldType);  [CE]  cannot  find  symbol  iFieldType  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iFieldType);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iFieldType);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iFieldType	18	None	replace
563	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iPointer);  [CE]  cannot  find  symbol  iPointer  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iPointer);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iPointer);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iPointer	18	None	replace
564	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iEnd);  [CE]  cannot  find  symbol  iEnd  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iEnd);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  0,  iPivotYear,  iDefaultYear,  iEnd);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    0,    iPivotYear,    iDefaultYear);    	non-compiled	[CE]  cannot  find  symbol  iEnd	18	None	replace
565	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.computeMillis(false,  text);  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.computeMillis(false,  text);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.computeMillis(false,  text);	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	add
566	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono,  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  ';'  expected	13	None	add
567	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  super.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  super.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  super.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	add
568	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.computeMillis(text,  position);  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.computeMillis(text,  position);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.computeMillis(text,  position);	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	add
569	[BUG]  [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.parseInto(bucket,  text,  position);  [CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	final    DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear);    final  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  bucket  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	13	None	add
570	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iPreviousYear,  iDefaultYear);  [CE]  cannot  find  symbol  iPreviousYear  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iPreviousYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iPreviousYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iPreviousYear);    	non-compiled	[CE]  cannot  find  symbol  iPreviousYear	45	None	replace
571	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantMillis,  text,  position,  iLocale);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantMillis,  text,  position,  iLocale);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instantMillis,  text,  position,  iLocale);	      DateTimeParser    parser    =    parser.parseInto(instantMillis,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	9	None	replace
572	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantMillis,  text,  position,  iDefaultYear);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantMillis,  text,  position,  iDefaultYear);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instantMillis,  text,  position,  iDefaultYear);	      DateTimeParser    parser    =    parser.parseInto(instantMillis,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	9	None	replace
573	[BUG]  [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantMillis,  text,  position,  chrono);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  DateTimeParser  parser  =  parser.parseInto(instantMillis,  text,  position,  chrono);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	DateTimeParser  parser  =  parser.parseInto(instantMillis,  text,  position,  chrono);	      DateTimeParser    parser    =    parser.parseInto(instantMillis,    text,    position);    	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	9	None	replace
574	[BUG]  [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  0);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    public  int  parseInto(ReadWritableInstant  instant,  String  text,  int  position)  {  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);    [BUGGY]  Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  0);  [BUGGY]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	replace	Chronology  chrono  =  parser.parseInto(instantLocal,  text,  position,  0);	      Chronology    chrono    =    parser.parseInto(instantLocal,    text,    position);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	6	None	replace
575	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iOffsetParsed,  iPivotYear,  iDefaultYear,  iDefaultYear);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,boolean,Integer,int,int)  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iOffsetParsed,  iPivotYear,  iDefaultYear,  iDefaultYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iOffsetParsed,  iPivotYear,  iDefaultYear,  iDefaultYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iOffsetParsed);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,boolean,Integer,int,int)	15	None	replace
576	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iOffsetParsed);  [CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,boolean)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iOffsetParsed);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iOffsetParsed);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iOffsetParsed);    	non-compiled	[CE]  no  suitable  constructor  found  for  DateTimeParserBucket(long,Chronology,Locale,Integer,int,int,boolean)	15	None	replace
577	[BUG]  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iPreviousYear);  [CE]  cannot  find  symbol  iPreviousYear  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException(   "Instant  must  not  be  null   ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);    [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iPreviousYear);  [BUGGY]    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear,  iDefaultYear,  iPreviousYear);	  DateTimeParserBucket    bucket    =    new    DateTimeParserBucket(instantLocal,    chrono,    iLocale,    iPivotYear,    iDefaultYear,    iOffsetParsed);    	non-compiled	[CE]  cannot  find  symbol  iPreviousYear	15	None	replace
