bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
26	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [BUGGY] [BUGGY] chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int  ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	706	706	7	add	
27	[BUG] [BUGGY] DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); [FE] AssertionFailedError [CONTEXT] DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); [BUGGY] DateTimeParserBucket bucket = new DateTimeParserBucket(   instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); [BUGGY] instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int  ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	
