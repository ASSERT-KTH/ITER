bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  [timeout]  [FE]    AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);	int  newPos  =  parser.parseInto(bucket,  text,  position);  	non-compiled	[timeout]	29	None	replace
2	[BUG]  [BUGGY]  timeout  [FE]      AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);	int  newPos  =  parser.parseInto(bucket,  text,  position);  	compilable	timeout	29	1	replace
3	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  timeout  [FE]      AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);	int  newPos  =  parser.parseInto(bucket,  text,  position);  	compilable	timeout	29	1	replace
4	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	add	int  newPos  =  iParser.parseInto(bucket,  text,  position);	int  newPos  =  parser.parseInto(bucket,  text,  position);  	compilable	  [FE]  AssertionFailedError  	29	7	replace
5	[BUG]  [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  newPos  =  iParser.parseInto(bucket,  text,  position);	int  newPos  =  parser.parseInto(bucket,  text,  position);  	compilable	  [FE]  AssertionFailedError  	29	7	replace
6	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);	int  newPos  =  parser.parseInto(bucket,  text,  position);  	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	29	None	replace
7	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);	int  newPos  =  parser.parseInto(bucket,  text,  position);  	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	29	None	replace
8	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  instantLocal,  position);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  instantLocal,  position);  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  newPos  =  parser.parseInto(bucket,  instantLocal,  position);	int  newPos  =  parser.parseInto(bucket,  text,  position);  	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	29	None	replace
9	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  iLocale);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  iLocale);  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  iLocale);	int  newPos  =  parser.parseInto(bucket,  text,  position);  	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	29	None	replace
10	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  0,  iDefaultYear);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  0,  iDefaultYear);  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  0,  iDefaultYear);	int  newPos  =  parser.parseInto(bucket,  text,  position);  	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	29	None	replace
11	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  instantLocal,  text);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  instantLocal,  text);  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  newPos  =  parser.parseInto(bucket,  instantLocal,  text);	int  newPos  =  parser.parseInto(bucket,  text,  position);  	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	29	None	replace
12	[BUG]  [BUGGY]    [CE]  cannot  find  symbol  newPos  [FE]                      AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	  	int  newPos  =  parser.parseInto(bucket,  text,  position);  	non-compiled	[CE]  cannot  find  symbol  newPos	29	None	replace
13	[BUG]  [BUGGY]    DateTimeParser  parser  =  requireParser();  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    DateTimeParser  parser  =  requireParser();  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    DateTimeParser  parser  =  requireParser();		non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	add
14	[BUG]  [BUGGY]    iParser  =  parser.parseInto(instantLocal,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iParser  [FE]      AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    iParser  =  parser.parseInto(instantLocal,  text,  position);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    iParser  =  parser.parseInto(instantLocal,  text,  position);		non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iParser	28	None	add
15	[BUG]  [BUGGY]    parser.parseInto(instantLocal,  text,  position);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    parser.parseInto(instantLocal,  text,  position);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    parser.parseInto(instantLocal,  text,  position);		non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	28	None	add
16	[BUG]  [BUGGY]    iChrono  =  parser.parseInto(instantLocal,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]          AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    iChrono  =  parser.parseInto(instantLocal,  text,  position);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    iChrono  =  parser.parseInto(instantLocal,  text,  position);		non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	28	None	add
17	[BUG]  [BUGGY]    iParser  =  parser.parseInstant(instantLocal,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iParser  [FE]            AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    iParser  =  parser.parseInstant(instantLocal,  text,  position);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    iParser  =  parser.parseInstant(instantLocal,  text,  position);		non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iParser	28	None	add
18	[BUG]  [BUGGY]    iChrono  =  parser.parseInstant(instantLocal,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]              AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    iChrono  =  parser.parseInstant(instantLocal,  text,  position);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    iChrono  =  parser.parseInstant(instantLocal,  text,  position);		non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	28	None	add
19	[BUG]  [BUGGY]    iChrono  =  chrono.withZone(instantLocal);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]                AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    iChrono  =  chrono.withZone(instantLocal);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    iChrono  =  chrono.withZone(instantLocal);		non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	28	None	add
20	[BUG]  [BUGGY]    Chronology  chrono  =  getChronology(instantLocal);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    Chronology  chrono  =  getChronology(instantLocal);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    Chronology  chrono  =  getChronology(instantLocal);		non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	add
21	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    parser  =  requireParser();  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	add	    parser  =  requireParser();		compilable	  [FE]  AssertionFailedError  	28	7	add
22	[BUG]  [BUGGY]    parser  =  requireParser();  [FE]  AssertionFailedError  [FE]                    AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    parser  =  requireParser();  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    parser  =  requireParser();		compilable	  [FE]  AssertionFailedError  	28	7	add
23	[BUG]  [BUGGY]    iLocale  =  chrono.getLocale();  [CE]  cannot  assign  a  value  to  final  variable  iLocale  [FE]                      AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    iLocale  =  chrono.getLocale();  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    iLocale  =  chrono.getLocale();		non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iLocale	28	None	add
24	[BUG]  [BUGGY]    parser.parseInto(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]    AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    parser.parseInto(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    parser.parseInto(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);		non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	28	None	add
25	[BUG]  [BUGGY]    parser.parseInto(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.withZone(chrono);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]      AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    parser.parseInto(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.withZone(chrono);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    parser.parseInto(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.withZone(chrono);		non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	28	None	add
26	[BUG]  [BUGGY]    DateTimeParser  parser  =  requireParser();  iChrono  =  parser.parseInto(instant,  text,  position);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    DateTimeParser  parser  =  requireParser();  iChrono  =  parser.parseInto(instant,  text,  position);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    DateTimeParser  parser  =  requireParser();  iChrono  =  parser.parseInto(instant,  text,  position);		non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	add
27	[BUG]  [BUGGY]    DateTimeParser  parser  =  requireParser();  if(parser  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    DateTimeParser  parser  =  requireParser();  if(parser  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    DateTimeParser  parser  =  requireParser();  if(parser  ==  null)  {  throw  new  IllegalArgumentException( " ");  }		non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	add
28	[BUG]  [BUGGY]    parser.parseInto(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.getChronology();  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    parser.parseInto(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.getChronology();  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    parser.parseInto(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.getChronology();		non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	28	None	add
29	[BUG]  [BUGGY]    DateTimeParser  parser  =  requireParser();  iChrono  =  parser.parseInto(instantLocal,  chrono);  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    DateTimeParser  parser  =  requireParser();  iChrono  =  parser.parseInto(instantLocal,  chrono);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    DateTimeParser  parser  =  requireParser();  iChrono  =  parser.parseInto(instantLocal,  chrono);		non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	add
30	[BUG]  [BUGGY]    parser.parseInto(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.computeMillis(false,  text);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    parser.parseInto(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.computeMillis(false,  text);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    parser.parseInto(instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.computeMillis(false,  text);		non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	28	None	add
31	[BUG]  [BUGGY]    DateTimeParser  parser  =  requireParser();  if(parser  ==  null)  {  throw  new  IllegalArgumentException( "Instant  cannot  be  null. ");  }  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    DateTimeParser  parser  =  requireParser();  if(parser  ==  null)  {  throw  new  IllegalArgumentException( "Instant  cannot  be  null. ");  }  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    DateTimeParser  parser  =  requireParser();  if(parser  ==  null)  {  throw  new  IllegalArgumentException( "Instant  cannot  be  null. ");  }		non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	add
32	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  pivotYear);  [CE]  cannot  find  symbol  pivotYear  [FE]    AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  pivotYear);  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position,  pivotYear);	int  newPos  =  parser.parseInto(bucket,  text,  position);  	non-compiled	[CE]  cannot  find  symbol  pivotYear	29	None	replace
33	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  iPivotYear);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]      AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  iPivotYear);  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position,  iPivotYear);	int  newPos  =  parser.parseInto(bucket,  text,  position);  	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	29	None	replace
34	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  iChrono);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  iChrono);  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position,  iChrono);	int  newPos  =  parser.parseInto(bucket,  text,  position);  	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	29	None	replace
35	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  iZone);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  iZone);  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position,  iZone);	int  newPos  =  parser.parseInto(bucket,  text,  position);  	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	29	None	replace
36	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  instantLocal);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]    AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  instantLocal);  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position,  instantLocal);	int  newPos  =  parser.parseInto(bucket,  text,  position);  	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	29	None	replace
37	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  chrono);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]      AssertionFailedError  [CONTEXT]  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  chrono);  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	710	710	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position,  chrono);	int  newPos  =  parser.parseInto(bucket,  text,  position);  	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	29	None	replace
38	[BUG]  [BUGGY]    parser.parseInto(instantLocal,  text,  position,  iPivotYear,  iDefaultYear);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]    AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    parser.parseInto(instantLocal,  text,  position,  iPivotYear,  iDefaultYear);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    parser.parseInto(instantLocal,  text,  position,  iPivotYear,  iDefaultYear);		non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	28	None	add
39	[BUG]  [BUGGY]    int  text  =  parser.parseInto(instantLocal,  text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    int  text  =  parser.parseInto(instantLocal,  text,  position);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    int  text  =  parser.parseInto(instantLocal,  text,  position);		non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	add
40	[BUG]  [BUGGY]    parser.parseInto(instantLocal,  text,  position,  iLocale);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    parser.parseInto(instantLocal,  text,  position,  iLocale);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    parser.parseInto(instantLocal,  text,  position,  iLocale);		non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	28	None	add
41	[BUG]  [BUGGY]    Integer  iLocale  =  chrono.getLocale();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    Integer  iLocale  =  chrono.getLocale();  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    Integer  iLocale  =  chrono.getLocale();		non-compiled	[CE]  cannot  find  symbol	28	None	add
42	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    instantLocal  =  chrono.getZone().getOffset(instantLocal);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	add	    instantLocal  =  chrono.getZone().getOffset(instantLocal);		compilable	  [FE]  AssertionFailedError  	28	7	add
43	[BUG]  [BUGGY]    instantLocal  =  chrono.getZone().getOffset(instantLocal);  [FE]  AssertionFailedError  [FE]            AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    instantLocal  =  chrono.getZone().getOffset(instantLocal);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    instantLocal  =  chrono.getZone().getOffset(instantLocal);		compilable	  [FE]  AssertionFailedError  	28	7	add
44	[BUG]  [BUGGY]    int  text  =  parser.parseInto(instantLocal,  text,  position);  instantLocal  =  chrono.computeMillis(text,  position);  [CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    int  text  =  parser.parseInto(instantLocal,  text,  position);  instantLocal  =  chrono.computeMillis(text,  position);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    int  text  =  parser.parseInto(instantLocal,  text,  position);  instantLocal  =  chrono.computeMillis(text,  position);		non-compiled	[CE]  variable  text  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	add
45	[BUG]  [BUGGY]    parser.parseInto(instantLocal,  text,  position,  iLocale);  instantLocal  =  chrono.getZone().getOffset(instantLocal);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    parser.parseInto(instantLocal,  text,  position,  iLocale);  instantLocal  =  chrono.getZone().getOffset(instantLocal);  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    parser.parseInto(instantLocal,  text,  position,  iLocale);  instantLocal  =  chrono.getZone().getOffset(instantLocal);		non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	28	None	add
46	[BUG]  [BUGGY]    iChrono  =  chrono.withUTC();  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]                  AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    iChrono  =  chrono.withUTC();  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    iChrono  =  chrono.withUTC();		non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	28	None	add
47	[BUG]  [BUGGY]    parser.parseInto(instantLocal,  text,  position,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.getChronology();  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError  [CONTEXT]  DateTimeParser  parser  =  requireParser();  if  (instant  ==  null)  {  throw  new  IllegalArgumentException( "Instant  must  not  be  null ");  }  long  instantMillis  =  instant.getMillis();  Chronology  chrono  =  instant.getChronology();  long  instantLocal  =  instantMillis  +  chrono.getZone().getOffset(instantMillis);  chrono  =  selectChronology(chrono);  [BUGGY]    parser.parseInto(instantLocal,  text,  position,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.getChronology();  [BUGGY]  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(    instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	708	709	7	replace	    parser.parseInto(instantLocal,  text,  position,  iPivotYear,  iDefaultYear);  instantLocal  =  chrono.getChronology();		non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	28	None	add
