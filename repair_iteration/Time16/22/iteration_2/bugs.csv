bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  instant.setChronology(iChrono);  [CE]  missing  return  statement  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  instant.setChronology(iChrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	instant.setChronology(iChrono);	      	non-compiled	[CE]  missing  return  statement	12	None	replace
2	[BUG]  [BUGGY]  instant.setChronology(chrono);  [CE]  missing  return  statement  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  instant.setChronology(chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	instant.setChronology(chrono);	      	non-compiled	[CE]  missing  return  statement	12	None	replace
3	[BUG]  [BUGGY]  instant.setZone(iChrono);  [CE]  method  setZone  in  interface  ReadWritableInstant  cannot  be  applied  to  given  types;  [FE]                              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  instant.setZone(iChrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	instant.setZone(iChrono);	      	non-compiled	[CE]  method  setZone  in  interface  ReadWritableInstant  cannot  be  applied  to  given  types;	12	None	replace
4	[BUG]  [BUGGY]  instant.setPivotYear(iPivotYear);  [CE]  cannot  find  symbol  [FE]                                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  instant.setPivotYear(iPivotYear);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	instant.setPivotYear(iPivotYear);	      	non-compiled	[CE]  cannot  find  symbol	12	None	replace
5	[BUG]  [BUGGY]  instant.setChronology(iChrono);  iLocale  =  locale;  [CE]  cannot  assign  a  value  to  final  variable  iLocale  [FE]                                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  instant.setChronology(iChrono);  iLocale  =  locale;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	instant.setChronology(iChrono);  iLocale  =  locale;	      	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iLocale	12	None	replace
6	[BUG]  [BUGGY]  iParser.parseInto(instant,  text,  position);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  iParser.parseInto(instant,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	iParser.parseInto(instant,  text,  position);	      	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	12	None	replace
7	[BUG]  [BUGGY]  return  iChrono.parseInto(instant,  text,  position);  [CE]  cannot  find  symbol  [FE]                                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iChrono.parseInto(instant,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iChrono.parseInto(instant,  text,  position);	      	non-compiled	[CE]  cannot  find  symbol	12	None	replace
8	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(bucket.computeMillis(true,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
9	[BUG]  [BUGGY]  parsedOffset  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parsedOffset  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parsedOffset  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
10	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
11	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(true,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
12	[BUG]  [BUGGY]  minute  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  minute  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	minute  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
13	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
14	[BUG]  [BUGGY]  return  position;  instant.setChronology(chrono);  [CE]  unreachable  statement  [FE]        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  instant.setChronology(chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    instant.setChronology(chrono);	  timeout    	non-compiled	[CE]  unreachable  statement	34	None	add
15	[BUG]  [BUGGY]  return  position;  instant.setChronology(iChrono);  [CE]  unreachable  statement  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  instant.setChronology(iChrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    instant.setChronology(iChrono);	  timeout    	non-compiled	[CE]  unreachable  statement	34	None	add
16	[BUG]  [BUGGY]  return  position;  iChrono  =  chrono.withZone(iChrono);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  iChrono  =  chrono.withZone(iChrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    iChrono  =  chrono.withZone(iChrono);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	34	None	add
17	[BUG]  [BUGGY]  return  position;  iParser.parseInto(instant,  text,  position);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  iParser.parseInto(instant,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    iParser.parseInto(instant,  text,  position);	  timeout    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	34	None	add
18	[BUG]  [BUGGY]  return  position;  int  position  =  iChrono.getLocalMillis();  [CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  int  position  =  iChrono.getLocalMillis();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    int  position  =  iChrono.getLocalMillis();	  timeout    	non-compiled	[CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	34	None	add
19	[BUG]  [BUGGY]  return  position;  int  position  =  iChrono.parseInstant(text);  [CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  int  position  =  iChrono.parseInstant(text);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    int  position  =  iChrono.parseInstant(text);	  timeout    	non-compiled	[CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	34	None	add
20	[BUG]  [BUGGY]  return  position;  int  position  =  iChrono.parseInstant(text,  position);  [CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  int  position  =  iChrono.parseInstant(text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    int  position  =  iChrono.parseInstant(text,  position);	  timeout    	non-compiled	[CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	34	None	add
21	[BUG]  [BUGGY]  return  position;  int  position  =  iParser.parseInstant(text,  position);  [CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  int  position  =  iParser.parseInstant(text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    int  position  =  iParser.parseInstant(text,  position);	  timeout    	non-compiled	[CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	34	None	add
22	[BUG]  [BUGGY]  return  position;  int  position  =  iParser.parseInto(bucket,  text,  position);  [CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  int  position  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    int  position  =  iParser.parseInto(bucket,  text,  position);	  timeout    	non-compiled	[CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	34	None	add
23	[BUG]  [BUGGY]  return  position;  int  position  =  iParser.parseInstant(text);  [CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  int  position  =  iParser.parseInstant(text);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    int  position  =  iParser.parseInstant(text);	  timeout    	non-compiled	[CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	34	None	add
24	[BUG]  [BUGGY]  timeout  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(iDefaultYear  <  0)?  this.iPivotYear  :  iDefaultYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	add	return(iDefaultYear  <  0)?  this.iPivotYear  :  iDefaultYear;	  return    this.iPivotYear;    [timeout]    	compilable	timeout	36	1	replace
25	[BUG]  [BUGGY]  return(iDefaultYear  <  0)?  this.iPivotYear  :  iDefaultYear;  timeout  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(iDefaultYear  <  0)?  this.iPivotYear  :  iDefaultYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(iDefaultYear  <  0)?  this.iPivotYear  :  iDefaultYear;	  return    this.iPivotYear;    [timeout]    	compilable	timeout	36	1	replace
26	[BUG]  [BUGGY]  return(iDefaultYear  <  =  0)?  this.iPivotYear  :  iDefaultYear;  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(iDefaultYear  <  =  0)?  this.iPivotYear  :  iDefaultYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(iDefaultYear  <  =  0)?  this.iPivotYear  :  iDefaultYear;	  return    this.iPivotYear;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	36	None	replace
27	[BUG]  [BUGGY]  return  iLocale.intValue();  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iLocale.intValue();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iLocale.intValue();	  return    iLocale;    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
28	[BUG]  [BUGGY]  return  iLocale.getIntValue();  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iLocale.getIntValue();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iLocale.getIntValue();	  return    iLocale;    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
29	[BUG]  [BUGGY]  return  iLocale.getDefaultYear();  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iLocale.getDefaultYear();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iLocale.getDefaultYear();	  return    iLocale;    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
30	[BUG]  [BUGGY]  return  iLocale.withUTC();  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iLocale.withUTC();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iLocale.withUTC();	  return    iLocale;    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
31	[BUG]  [BUGGY]  return  iLocale.getIntValue(iChrono,  parsedOffset,  chrono);  [CE]  cannot  find  symbol  parsedOffset  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iLocale.getIntValue(iChrono,  parsedOffset,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iLocale.getIntValue(iChrono,  parsedOffset,  chrono);	  return    iLocale;    	non-compiled	[CE]  cannot  find  symbol  parsedOffset	7	None	replace
32	[BUG]  [BUGGY]  return  iLocale.getIntValue(iChrono);  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iLocale.getIntValue(iChrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iLocale.getIntValue(iChrono);	  return    iLocale;    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
33	[BUG]  [BUGGY]  return  iLocale.getIntValue(iPivotYear,  parsedOffset,  chrono);  [CE]  cannot  find  symbol  parsedOffset  [FE]                              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iLocale.getIntValue(iPivotYear,  parsedOffset,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iLocale.getIntValue(iPivotYear,  parsedOffset,  chrono);	  return    iLocale;    	non-compiled	[CE]  cannot  find  symbol  parsedOffset	7	None	replace
34	[BUG]  [BUGGY]  return  iLocale.getIntValue(iChrono,  position);  [CE]  cannot  find  symbol  [FE]                                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iLocale.getIntValue(iChrono,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iLocale.getIntValue(iChrono,  position);	  return    iLocale;    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
35	[BUG]  [BUGGY]  timeout  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear  +  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	add	return  iDefaultYear  +  1;	  return    iDefaultYear;    timeout    	compilable	timeout	3	1	replace
36	[BUG]  [BUGGY]  return  iDefaultYear  +  1;  timeout  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear  +  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iDefaultYear  +  1;	  return    iDefaultYear;    timeout    	compilable	timeout	3	1	replace
37	[BUG]  [BUGGY]  timeout  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	add	return  iDefaultYear  -  1;	  return    iDefaultYear;    timeout    	compilable	timeout	3	1	replace
38	[BUG]  [BUGGY]  return  iDefaultYear  -  1;  timeout  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iDefaultYear  -  1;	  return    iDefaultYear;    timeout    	compilable	timeout	3	1	replace
39	[BUG]  [BUGGY]  return  iDefaultYear  -  iPivotYear;  [timeout]  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear  -  iPivotYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iDefaultYear  -  iPivotYear;	  return    iDefaultYear;    timeout    	non-compiled	[timeout]	3	None	replace
40	[BUG]  [BUGGY]  return  iDefaultYear  *  iPivotYear;  [timeout]  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear  *  iPivotYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iDefaultYear  *  iPivotYear;	  return    iDefaultYear;    timeout    	non-compiled	[timeout]	3	None	replace
41	[BUG]  [BUGGY]  return  iDefaultYear  +  parsedOffset;  [CE]  cannot  find  symbol  parsedOffset  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear  +  parsedOffset;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iDefaultYear  +  parsedOffset;	  return    iDefaultYear;    timeout    	non-compiled	[CE]  cannot  find  symbol  parsedOffset	3	None	replace
42	[BUG]  [BUGGY]  return  iDefaultYear  +  chrono.getLocale();  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear  +  chrono.getLocale();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iDefaultYear  +  chrono.getLocale();	  return    iDefaultYear;    timeout    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
43	[BUG]  [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(iChrono.computeMillis(false,  text));	      instant.setMillis(chrono.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
44	[BUG]  [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text,  position));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text,  position));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(chrono.computeMillis(false,  text,  position));	      instant.setMillis(chrono.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
45	[BUG]  [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text),  iLocale);  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text),  iLocale);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(chrono.computeMillis(false,  text),  iLocale);	      instant.setMillis(chrono.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
46	[BUG]  [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text),  position);  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text),  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(chrono.computeMillis(false,  text),  position);	      instant.setMillis(chrono.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
47	[BUG]  [BUGGY]  instant.setMillis(chrono.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(chrono.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(chrono.computeMillis(true,  text));	      instant.setMillis(chrono.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
48	[BUG]  [BUGGY]  instant.setMillis(parsedZone.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(parsedZone.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(parsedZone.computeMillis(false,  text));	      instant.setChronology(chrono);    	non-compiled	[CE]  illegal  start  of  type	16	None	replace
49	[BUG]  [BUGGY]  instant.setChronology(iChrono);  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setChronology(iChrono);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setChronology(iChrono);	      instant.setChronology(chrono);    	non-compiled	[CE]  illegal  start  of  type	16	None	replace
50	[BUG]  [BUGGY]  instant.setMillis(parsedZone.computeMillis(false,  iLocale));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(parsedZone.computeMillis(false,  iLocale));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(parsedZone.computeMillis(false,  iLocale));	      instant.setChronology(chrono);    	non-compiled	[CE]  illegal  start  of  type	16	None	replace
51	[BUG]  [BUGGY]  instant.setLocale(locale);  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setLocale(locale);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setLocale(locale);	      instant.setChronology(chrono);    	non-compiled	[CE]  illegal  start  of  type	16	None	replace
52	[BUG]  [BUGGY]  instant.setMillis(iChrono.parseInto(bucket,  text,  position));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(iChrono.parseInto(bucket,  text,  position));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(iChrono.parseInto(bucket,  text,  position));	      instant.setChronology(chrono);    	non-compiled	[CE]  illegal  start  of  type	16	None	replace
53	[BUG]  [BUGGY]  instant.setPivotYear(iPivotYear);  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setPivotYear(iPivotYear);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setPivotYear(iPivotYear);	      instant.setChronology(chrono);    	non-compiled	[CE]  illegal  start  of  type	16	None	replace
54	[BUG]  [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	add
55	[BUG]  [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    int  iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	add
56	[BUG]  [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	add
57	[BUG]  [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  Integer  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  Integer  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    Integer  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	add
58	[BUG]  [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    int  iLocale  =  iParser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	add
59	[BUG]  [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseIn(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseIn(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    int  iLocale  =  iParser.parseIn(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	add
60	[BUG]  [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    int  iLocale  =  iParser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	add
61	[BUG]  [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseInto(bucket,  context,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseInto(bucket,  context,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    int  iLocale  =  iParser.parseInto(bucket,  context,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	add
62	[BUG]  [BUGGY]  parser.parseInto(bucket,  iChrono,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iChrono,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iChrono,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
63	[BUG]  [BUGGY]  parser.parseInto(bucket,  iPivotYear,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iPivotYear,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iPivotYear,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
64	[BUG]  [BUGGY]  parser.parseInto(bucket,  iChrono,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iChrono,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iChrono,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
65	[BUG]  [BUGGY]  parser.parseInto(bucket,  iLocale,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iLocale,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iLocale,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
66	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  chrono,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
67	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  iLocale,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
68	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  iLocale,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
69	[BUG]  [BUGGY]  parser.parseInto(bucket,  iLocale,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iLocale,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iLocale,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
70	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  iLocale,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
71	[BUG]  [BUGGY]  parser.parseInto(bucket,  iChrono,  text,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iChrono,  text,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iChrono,  text,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iPivotYear);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	33	None	replace
72	[BUG]  [BUGGY]  parser.parseInto(bucket,  iLocale,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iLocale,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iLocale,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iPivotYear);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	33	None	replace
73	[BUG]  [BUGGY]  parser.parseInto(bucket,  iPivotYear,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iPivotYear,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iPivotYear,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iPivotYear);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	33	None	replace
74	[BUG]  [BUGGY]  parser.parseInto(bucket,  iChrono,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iChrono,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iChrono,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iPivotYear);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	33	None	replace
75	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iDefaultYear,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iDefaultYear,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  iDefaultYear,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iPivotYear);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	33	None	replace
76	[BUG]  [BUGGY]  parser.parseInto(bucket,  iParser,  text,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iParser,  text,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iParser,  text,  position,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iPivotYear);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	33	None	replace
77	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iPivotYear,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iPivotYear,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  iPivotYear,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iPivotYear);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	33	None	replace
78	[BUG]  [BUGGY]  parsedZone.parseInto(bucket,  text,  position,  iPivotYear,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parsedZone.parseInto(bucket,  text,  position,  iPivotYear,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parsedZone.parseInto(bucket,  text,  position,  iPivotYear,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iPivotYear);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	33	None	replace
79	[BUG]  [BUGGY]  parser.parseInto(bucket,  iPivotYear,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iPivotYear,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iPivotYear,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iPivotYear);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	33	None	replace
80	[BUG]  [BUGGY]  return  instant.iChrono;  [CE]  cannot  find  symbol  iChrono  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.iChrono;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.iChrono;	  return    this.iChrono;    	non-compiled	[CE]  cannot  find  symbol  iChrono	9	None	replace
81	[BUG]  [BUGGY]  return(iChrono!=  null)?  null  :  chrono.iChrono;  [CE]  cannot  find  symbol  iChrono  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(iChrono!=  null)?  null  :  chrono.iChrono;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(iChrono!=  null)?  null  :  chrono.iChrono;	  return    this.iChrono;    	non-compiled	[CE]  cannot  find  symbol  iChrono	9	None	replace
82	[BUG]  [BUGGY]  return(iChrono!=  null)?  null  :  iChrono;  [CE]  incompatible  types  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(iChrono!=  null)?  null  :  iChrono;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(iChrono!=  null)?  null  :  iChrono;	  return    this.iChrono;    	non-compiled	[CE]  incompatible  types	9	None	replace
83	[BUG]  [BUGGY]  return  this.iChrono.getInstantValue(instant,  text,  position);  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iChrono.getInstantValue(instant,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iChrono.getInstantValue(instant,  text,  position);	  return    this.iChrono;    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
84	[BUG]  [BUGGY]  return  this.iChrono.getInstantMillis();  [CE]  cannot  find  symbol  [FE]                              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iChrono.getInstantMillis();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iChrono.getInstantMillis();	  return    this.iChrono;    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
85	[BUG]  [BUGGY]  return  this.iChrono.insert(instant,  text,  position);  [CE]  cannot  find  symbol  [FE]                                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iChrono.insert(instant,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iChrono.insert(instant,  text,  position);	  return    this.iChrono;    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
86	[BUG]  [BUGGY]  return  instant.getInstantMillis();  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.getInstantMillis();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.getInstantMillis();	  return    instant;    	non-compiled	[CE]  cannot  find  symbol	1	None	replace
87	[BUG]  [BUGGY]  return  instant.getInstant();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.getInstant();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.getInstant();	  return    instant;    	non-compiled	[CE]  cannot  find  symbol	1	None	replace
88	[BUG]  [BUGGY]  return  instant.setChronology(chrono);  [CE]  incompatible  types  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.setChronology(chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.setChronology(chrono);	  return    instant;    	non-compiled	[CE]  incompatible  types	1	None	replace
89	[BUG]  [BUGGY]  return  instant.getInstantValue();  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.getInstantValue();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.getInstantValue();	  return    instant;    	non-compiled	[CE]  cannot  find  symbol	1	None	replace
90	[BUG]  [BUGGY]  return  instant.getChronology();  [CE]  incompatible  types  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.getChronology();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.getChronology();	  return    instant;    	non-compiled	[CE]  incompatible  types	1	None	replace
91	[BUG]  [BUGGY]  return  instant.setChronology(iChrono);  [CE]  incompatible  types  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.setChronology(iChrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.setChronology(iChrono);	  return    instant;    	non-compiled	[CE]  incompatible  types	1	None	replace
92	[BUG]  [BUGGY]  return  instant.getReadWritableInstant();  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.getReadWritableInstant();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.getReadWritableInstant();	  return    instant;    	non-compiled	[CE]  cannot  find  symbol	1	None	replace
93	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	add	        instant.setChronology(chrono);    instant.setChronology(chrono);	  	compilable	  [FE]  AssertionFailedError  	15	7	add
94	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);	  	compilable	  [FE]  AssertionFailedError  	15	7	add
95	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iPivotYear  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iPivotYear  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);  iPivotYear  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	15	None	add
96	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iDefaultYear  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iDefaultYear  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);  iDefaultYear  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	15	None	add
97	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iParser  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iParser  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iParser  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);  iParser  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iParser	15	None	add
98	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iZone  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iZone  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iZone  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);  iZone  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iZone	15	None	add
99	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iParser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	add	        instant.setChronology(chrono);    instant.setChronology(chrono);  iParser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	15	7	add
100	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iParser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iParser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);  iParser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	15	7	add
101	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	add	        instant.setChronology(chrono);    instant.setChronology(chrono);  parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	15	7	add
102	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  parser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);  parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	15	7	add
103	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iPivotYear  =  parser.parseInt(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iPivotYear  =  parser.parseInt(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);  iPivotYear  =  parser.parseInt(bucket,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	15	None	add
104	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iLocale  =  locale.getLocale();  [CE]  cannot  assign  a  value  to  final  variable  iLocale  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iLocale  =  locale.getLocale();  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);  iLocale  =  locale.getLocale();	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iLocale	15	None	add
105	[BUG]  [BUGGY]  if(iPivotYear!=  chrono)  {  return  iPivot;  }  else  {  instant.setChronology(chrono);  }  [CE]  incomparable  types:  Integer  and  Chronology  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  if(iPivotYear!=  chrono)  {  return  iPivot;  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	if(iPivotYear!=  chrono)  {  return  iPivot;  }  else  {  instant.setChronology(chrono);  }	  return    iPivot;    [timeout]    	non-compiled	[CE]  incomparable  types:  Integer  and  Chronology	37	None	replace
106	[BUG]  [BUGGY]  if(iPivotYear!=  null)  {  return  iPivot;  }  else  {  instant.setChronology(chrono);  }  [CE]  cannot  find  symbol  iPivot  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  if(iPivotYear!=  null)  {  return  iPivot;  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	if(iPivotYear!=  null)  {  return  iPivot;  }  else  {  instant.setChronology(chrono);  }	  return    iPivot;    [timeout]    	non-compiled	[CE]  cannot  find  symbol  iPivot	37	None	replace
107	[BUG]  [BUGGY]  if(iPivotYear  ==  chrono)  {  return  iPivot;  }  else  {  instant.setChronology(chrono);  }  [CE]  incomparable  types:  Integer  and  Chronology  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  if(iPivotYear  ==  chrono)  {  return  iPivot;  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	if(iPivotYear  ==  chrono)  {  return  iPivot;  }  else  {  instant.setChronology(chrono);  }	  return    iPivot;    [timeout]    	non-compiled	[CE]  incomparable  types:  Integer  and  Chronology	37	None	replace
108	[BUG]  [BUGGY]  if(iPivotYear  ==  null)  {  return  iPivot;  }  else  {  instant.setChronology(chrono);  }  [CE]  cannot  find  symbol  iPivot  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  if(iPivotYear  ==  null)  {  return  iPivot;  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	if(iPivotYear  ==  null)  {  return  iPivot;  }  else  {  instant.setChronology(chrono);  }	  return    iPivot;    [timeout]    	non-compiled	[CE]  cannot  find  symbol  iPivot	37	None	replace
109	[BUG]  [BUGGY]  if(iPivotYear  >=  chrono)  {  return  iPivot;  }  else  {  instant.setChronology(chrono);  }  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  if(iPivotYear  >=  chrono)  {  return  iPivot;  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	if(iPivotYear  >=  chrono)  {  return  iPivot;  }  else  {  instant.setChronology(chrono);  }	  return    iPivot;    [timeout]    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	37	None	replace
110	[BUG]  [BUGGY]  if(iPivotYear!=  chrono)  {  return  iPivot;  }  else  {  instant.setChrono(chrono);  }  [CE]  incomparable  types:  Integer  and  Chronology  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  if(iPivotYear!=  chrono)  {  return  iPivot;  }  else  {  instant.setChrono(chrono);  }  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	if(iPivotYear!=  chrono)  {  return  iPivot;  }  else  {  instant.setChrono(chrono);  }	  return    iPivot;    [timeout]    	non-compiled	[CE]  incomparable  types:  Integer  and  Chronology	37	None	replace
111	[BUG]  [BUGGY]  if(iPivotYear!=  null)  {  return  iPivot;  }  else  {  instant.setChrono(chrono);  }  [CE]  cannot  find  symbol  iPivot  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  if(iPivotYear!=  null)  {  return  iPivot;  }  else  {  instant.setChrono(chrono);  }  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	if(iPivotYear!=  null)  {  return  iPivot;  }  else  {  instant.setChrono(chrono);  }	  return    iPivot;    [timeout]    	non-compiled	[CE]  cannot  find  symbol  iPivot	37	None	replace
112	[BUG]  [BUGGY]  if(iPivotYear!=  null)  {  return  iPivot;  }  else  {  instant.setZone(chrono);  }  [CE]  cannot  find  symbol  iPivot  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  if(iPivotYear!=  null)  {  return  iPivot;  }  else  {  instant.setZone(chrono);  }  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	if(iPivotYear!=  null)  {  return  iPivot;  }  else  {  instant.setZone(chrono);  }	  return    iPivot;    [timeout]    	non-compiled	[CE]  cannot  find  symbol  iPivot	37	None	replace
113	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  newPos,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  newPos,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  newPos,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    newPos);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	30	None	replace
114	[BUG]  [BUGGY]  parser.parseInto(bucket,  iLocale,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iLocale,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iLocale,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    newPos);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	30	None	replace
115	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  newPos,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  newPos,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  newPos,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    newPos);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	30	None	replace
116	[BUG]  [BUGGY]  parser.parseInto(bucket,  iChrono,  text,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iChrono,  text,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iChrono,  text,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    newPos);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	30	None	replace
117	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  newPos,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  newPos,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  newPos,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    newPos);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	30	None	replace
118	[BUG]  [BUGGY]  parser.parseInto(bucket,  iPivotYear,  text,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iPivotYear,  text,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iPivotYear,  text,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    newPos);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	30	None	replace
119	[BUG]  [BUGGY]  parser.parseInto(bucket,  position,  text,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  position,  text,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  position,  text,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    newPos);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	30	None	replace
120	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iDefaultYear,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iDefaultYear,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  iDefaultYear,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    newPos);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	30	None	replace
121	[BUG]  [BUGGY]  return  iOffset;  [CE]  cannot  find  symbol  iOffset  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iOffset;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iOffset;	  return    parsedOffset;    	non-compiled	[CE]  cannot  find  symbol  iOffset	6	None	replace
122	[BUG]  [BUGGY]  return  iParsedOffset;  [CE]  cannot  find  symbol  iParsedOffset  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iParsedOffset;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iParsedOffset;	  return    parsedOffset;    	non-compiled	[CE]  cannot  find  symbol  iParsedOffset	6	None	replace
123	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	add	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	13	7	add
124	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	13	7	add
125	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(parser.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(parser.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	13	None	add
126	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(iChrono.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(iChrono.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(iChrono.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	13	None	add
127	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	add	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	13	7	add
128	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	13	7	add
129	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(iParser.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(iParser.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(iParser.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	13	None	add
130	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(parsedZone.computeMillis(false,  text));  [CE]  cannot  find  symbol  parsedZone  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(parsedZone.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(parsedZone.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  parsedZone	13	None	add
131	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(chrono.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(chrono.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(chrono.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	13	None	add
132	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(buffer.computeMillis(false,  text));  [CE]  cannot  find  symbol  buffer  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(buffer.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(buffer.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  buffer	13	None	add
133	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
134	[BUG]  [BUGGY]  if(iLocale!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iLocale!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iLocale!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
135	[BUG]  [BUGGY]  Integer  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  Integer  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	Integer  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
136	[BUG]  [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  iParser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
137	[BUG]  [BUGGY]  if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
138	[BUG]  [BUGGY]  long  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  long  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	long  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
139	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position  -  1,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
140	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  iLocale));	      int    newPos    =    parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
141	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(instant,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	43	None	replace
142	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(instant,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	43	None	replace
143	[BUG]  [BUGGY]  parser.parseInto(bucket,  iChrono,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iChrono,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iChrono,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(instant,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	43	None	replace
144	[BUG]  [BUGGY]  parser.parseInto(bucket,  iPivotYear,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iPivotYear,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iPivotYear,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(instant,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	43	None	replace
145	[BUG]  [BUGGY]  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(instant,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	43	None	replace
146	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	add	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	20	7	add
147	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	20	7	add
148	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	add	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	20	13	add
149	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	20	13	add
150	[BUG]  [BUGGY]  [FE]  StringIndexOutOfBoundsException  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	add	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  StringIndexOutOfBoundsException  	20	7	add
151	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  StringIndexOutOfBoundsException  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  StringIndexOutOfBoundsException  	20	7	add
152	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	20	None	add
153	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	20	None	add
154	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	20	None	add
155	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iPivotYear.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iPivotYear.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	20	None	add
156	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	20	None	add
157	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	20	None	add
158	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	add	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	20	7	add
159	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	20	7	add
160	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  iChrono));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    iChrono));    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
161	[BUG]  [BUGGY]  long  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  long  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	long  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    iChrono));    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
162	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  iChrono));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    iChrono));    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
163	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  iChrono));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    iChrono));    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
164	[BUG]  [BUGGY]  if(iChrono!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  }  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iChrono!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iChrono!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    iChrono));    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
165	[BUG]  [BUGGY]  Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [CE]  illegal  start  of  type  [FE]                              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    iChrono));    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
166	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [CE]  illegal  start  of  type  [FE]                                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  iChrono));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    iChrono));    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
167	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [CE]  illegal  start  of  type  [FE]                                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);  instant.setMillis(bucket.computeMillis(false,  iChrono));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    iChrono));    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
168	[BUG]  [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [CE]  illegal  start  of  type  [FE]                                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    iChrono));    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
169	[BUG]  [BUGGY]  return(iDefaultYear  >=  0)?  this.iPivotYear  :  this.iDefaultYear;  [timeout]  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(iDefaultYear  >=  0)?  this.iPivotYear  :  this.iDefaultYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(iDefaultYear  >=  0)?  this.iPivotYear  :  this.iDefaultYear;	  return    this.iDefaultYear;    timeout    	non-compiled	[timeout]	11	None	replace
170	[BUG]  [BUGGY]  return(iDefaultYear  >=  iLocale)?  this.iPivotYear  :  this.iDefaultYear;  [timeout]  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(iDefaultYear  >=  iLocale)?  this.iPivotYear  :  this.iDefaultYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(iDefaultYear  >=  iLocale)?  this.iPivotYear  :  this.iDefaultYear;	  return    this.iDefaultYear;    timeout    	non-compiled	[timeout]	11	None	replace
171	[BUG]  [BUGGY]  return(iDefaultYear  >=  0)?  this.iPivotYear  :  iDefaultYear;  [timeout]  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(iDefaultYear  >=  0)?  this.iPivotYear  :  iDefaultYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(iDefaultYear  >=  0)?  this.iPivotYear  :  iDefaultYear;	  return    this.iDefaultYear;    timeout    	non-compiled	[timeout]	11	None	replace
172	[BUG]  [BUGGY]  return(iDefaultYear  >=  iLocale)?  this.iPivotYear  :  iDefaultYear;  [timeout]  [FE]                              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(iDefaultYear  >=  iLocale)?  this.iPivotYear  :  iDefaultYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(iDefaultYear  >=  iLocale)?  this.iPivotYear  :  iDefaultYear;	  return    this.iDefaultYear;    timeout    	non-compiled	[timeout]	11	None	replace
173	[BUG]  [BUGGY]  timeout  [FE]                                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	add	return  this.iDefaultYear  -  1;	  return    this.iDefaultYear;    timeout    	compilable	timeout	11	1	replace
174	[BUG]  [BUGGY]  return  this.iDefaultYear  -  1;  timeout  [FE]                                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iDefaultYear  -  1;	  return    this.iDefaultYear;    timeout    	compilable	timeout	11	1	replace
175	[BUG]  [BUGGY]  parsedOffset  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parsedOffset  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parsedOffset  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
176	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
177	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
178	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  newPos));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  newPos));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  newPos));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
179	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
180	[BUG]  [BUGGY]  long  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  long  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	long  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position    -    1);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	40	None	replace
181	[BUG]  [BUGGY]  Integer  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  Integer  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	Integer  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position    -    1);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	40	None	replace
182	[BUG]  [BUGGY]  if(iLocale!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iLocale!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iLocale!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position    -    1);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	40	None	replace
183	[BUG]  [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  iParser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position    -    1);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	40	None	replace
184	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position  -  1,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position    -    1);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	40	None	replace
185	[BUG]  [BUGGY]  return  position  -  1;  [timeout]  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  position  -  1;	  return    newPos    -    1;    timeout    	non-compiled	[timeout]	48	None	replace
186	[BUG]  [BUGGY]  return  instant.getPos()  -  1;  [timeout]  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.getPos()  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.getPos()  -  1;	  return    newPos    -    1;    timeout    	non-compiled	[timeout]	48	None	replace
187	[BUG]  [BUGGY]  return  iPivotYear  -  1;  [timeout]  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  -  1;	  return    newPos    -    1;    timeout    	non-compiled	[timeout]	48	None	replace
188	[BUG]  [BUGGY]  return  parsedOffset  -  1;  [timeout]  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  parsedOffset  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  parsedOffset  -  1;	  return    newPos    -    1;    timeout    	non-compiled	[timeout]	48	None	replace
189	[BUG]  [BUGGY]  return  instant.getTimeout()  -  1;  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.getTimeout()  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.getTimeout()  -  1;	  return    newPos    -    1;    timeout    	non-compiled	[CE]  cannot  find  symbol	48	None	replace
190	[BUG]  [BUGGY]  return  instant  -  1;  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant  -  1;	  return    newPos    -    1;    timeout    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	48	None	replace
191	[BUG]  [BUGGY]  return  timeout  -  1;  [CE]  cannot  find  symbol  timeout  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  timeout  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  timeout  -  1;	  return    newPos    -    1;    timeout    	non-compiled	[CE]  cannot  find  symbol  timeout	48	None	replace
192	[BUG]  [BUGGY]  return  this.iDefaultYear;  iParser.parseInto(bucket,  text,  position,  iLocale);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  iParser.parseInto(bucket,  text,  position,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    iParser.parseInto(bucket,  text,  position,  iLocale);	  timeout    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	10	None	add
193	[BUG]  [BUGGY]  return  this.iDefaultYear;  iDefaultYear  =  instant.getParser().parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  iDefaultYear  =  instant.getParser().parseInto(bucket,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    iDefaultYear  =  instant.getParser().parseInto(bucket,  text,  position);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	10	None	add
194	[BUG]  [BUGGY]  return  this.iDefaultYear;  instant.setPivotYear(iPivotYear);  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  instant.setPivotYear(iPivotYear);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    instant.setPivotYear(iPivotYear);	  timeout    	non-compiled	[CE]  cannot  find  symbol	10	None	add
195	[BUG]  [BUGGY]  return  this.iDefaultYear;  iParser.parseInto(bucket,  text,  position);  [CE]  unreachable  statement  [FE]                              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  iParser.parseInto(bucket,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    iParser.parseInto(bucket,  text,  position);	  timeout    	non-compiled	[CE]  unreachable  statement	10	None	add
196	[BUG]  [BUGGY]  return  this.iDefaultYear;  iParser.parseInto(instant,  text,  position,  iLocale);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  iParser.parseInto(instant,  text,  position,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    iParser.parseInto(instant,  text,  position,  iLocale);	  timeout    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	10	None	add
197	[BUG]  [BUGGY]  return  this.iDefaultYear;  iParser.parseInstant(instant,  text,  position,  iLocale);  [CE]  cannot  find  symbol  [FE]                                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  iParser.parseInstant(instant,  text,  position,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    iParser.parseInstant(instant,  text,  position,  iLocale);	  timeout    	non-compiled	[CE]  cannot  find  symbol	10	None	add
198	[BUG]  [BUGGY]  return  this.iDefaultYear;  iParser.parseInto(bucket,  text,  position,  iPivotYear);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  iParser.parseInto(bucket,  text,  position,  iPivotYear);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    iParser.parseInto(bucket,  text,  position,  iPivotYear);	  timeout    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	10	None	add
199	[BUG]  [BUGGY]  return  this.iDefaultYear;  int  newPos  =  getOffset(parsedOffset,  iLocale);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  int  newPos  =  getOffset(parsedOffset,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    int  newPos  =  getOffset(parsedOffset,  iLocale);	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	10	None	add
200	[BUG]  [BUGGY]  return  this.iDefaultYear;  iParser.parseInto(instant,  text,  position,  iPivotYear);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  iParser.parseInto(instant,  text,  position,  iPivotYear);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    iParser.parseInto(instant,  text,  position,  iPivotYear);	  timeout    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	10	None	add
201	[BUG]  [BUGGY]  return  this.iDefaultYear;  instant.setChronology(chrono);  [CE]  unreachable  statement  [FE]                                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  instant.setChronology(chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    instant.setChronology(chrono);	  timeout    	non-compiled	[CE]  unreachable  statement	10	None	add
202	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(true,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	45	None	replace
203	[BUG]  [BUGGY]  long  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  long  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	long  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	45	None	replace
204	[BUG]  [BUGGY]  Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	45	None	replace
205	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(true,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	45	None	replace
206	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(true,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	45	None	replace
207	[BUG]  [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	45	None	replace
208	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(true,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	45	None	replace
209	[BUG]  [BUGGY]  return  instant;  [timeout]  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant;  [timeout]  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant;  [timeout]	  return    iChrono;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	5	None	replace
210	[BUG]  [BUGGY]  if(iChrono!=  null)  {  return  iChrono;  }  else  {  instant.setChronology(chrono);  }  [CE]  incompatible  types  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  if(iChrono!=  null)  {  return  iChrono;  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	if(iChrono!=  null)  {  return  iChrono;  }  else  {  instant.setChronology(chrono);  }	  return    iChrono;    [timeout]    	non-compiled	[CE]  incompatible  types	5	None	replace
211	[BUG]  [BUGGY]  if(iChrono!=  null)  {  return  iChrono;  }  else  {  instant.setZone(chrono);  }  [CE]  incompatible  types  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  if(iChrono!=  null)  {  return  iChrono;  }  else  {  instant.setZone(chrono);  }  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	if(iChrono!=  null)  {  return  iChrono;  }  else  {  instant.setZone(chrono);  }	  return    iChrono;    [timeout]    	non-compiled	[CE]  incompatible  types	5	None	replace
212	[BUG]  [BUGGY]  if(instant!=  null)  {  return  iChrono;  }  else  {  instant.setChronology(chrono);  }  [CE]  incompatible  types  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  if(instant!=  null)  {  return  iChrono;  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	if(instant!=  null)  {  return  iChrono;  }  else  {  instant.setChronology(chrono);  }	  return    iChrono;    [timeout]    	non-compiled	[CE]  incompatible  types	5	None	replace
213	[BUG]  [BUGGY]  if(iChrono!=  null)  {  return  chrono;  }  else  {  instant.setChronology(chrono);  }  [CE]  incompatible  types  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  if(iChrono!=  null)  {  return  chrono;  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	if(iChrono!=  null)  {  return  chrono;  }  else  {  instant.setChronology(chrono);  }	  return    iChrono;    [timeout]    	non-compiled	[CE]  incompatible  types	5	None	replace
214	[BUG]  [BUGGY]  if(iChrono!=  null)  {  return  iChrono;  }  [CE]  incompatible  types  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  if(iChrono!=  null)  {  return  iChrono;  }  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	if(iChrono!=  null)  {  return  iChrono;  }	  return    iChrono;    [timeout]    	non-compiled	[CE]  incompatible  types	5	None	replace
215	[BUG]  [BUGGY]  if(instant!=  null)  {  return  iChrono;  }  else  {  instant.setZone(chrono);  }  [CE]  incompatible  types  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  if(instant!=  null)  {  return  iChrono;  }  else  {  instant.setZone(chrono);  }  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	if(instant!=  null)  {  return  iChrono;  }  else  {  instant.setZone(chrono);  }	  return    iChrono;    [timeout]    	non-compiled	[CE]  incompatible  types	5	None	replace
216	[BUG]  [BUGGY]  if(iChrono!=  null)  {  return  iChrono;  }  else  {  instant.setChronology(chrono);  continue;  }  [CE]  incompatible  types  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  if(iChrono!=  null)  {  return  iChrono;  }  else  {  instant.setChronology(chrono);  continue;  }  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	if(iChrono!=  null)  {  return  iChrono;  }  else  {  instant.setChronology(chrono);  continue;  }	  return    iChrono;    [timeout]    	non-compiled	[CE]  incompatible  types	5	None	replace
217	[BUG]  [BUGGY]  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
218	[BUG]  [BUGGY]  DateTimeParser  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  DateTimeParser  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	DateTimeParser  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
219	[BUG]  [BUGGY]  InstantParser  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  InstantParser  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	InstantParser  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
220	[BUG]  [BUGGY]  Parser  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  Parser  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	Parser  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
221	[BUG]  [BUGGY]  if(iParser!=  null)  {  DateTimeParser  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iParser!=  null)  {  DateTimeParser  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iParser!=  null)  {  DateTimeParser  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      DateTimeParser    parser    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
222	[BUG]  [BUGGY]  iParser  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
223	[BUG]  [BUGGY]  if(iLocale!=  null)  {  DateTimeParser  parser  =  iLocale.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iLocale!=  null)  {  DateTimeParser  parser  =  iLocale.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iLocale!=  null)  {  DateTimeParser  parser  =  iLocale.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      DateTimeParser    parser    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
224	[BUG]  [BUGGY]  parser.parseInto(bucket,  iChrono,  text,  position,  iLocale);  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iChrono,  text,  position,  iLocale);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iChrono,  text,  position,  iLocale);	      parser.parseInto(bucket,    text,    position,    iLocale);    	non-compiled	[CE]  illegal  start  of  type	32	None	replace
225	[BUG]  [BUGGY]  parser.parseInto(bucket,  iPivotYear,  text,  position,  iLocale);  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iPivotYear,  text,  position,  iLocale);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iPivotYear,  text,  position,  iLocale);	      parser.parseInto(bucket,    text,    position,    iLocale);    	non-compiled	[CE]  illegal  start  of  type	32	None	replace
226	[BUG]  [BUGGY]  parser.parseInto(bucket,  iLocale,  text,  position);  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iLocale,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iLocale,  text,  position);	      parser.parseInto(bucket,    text,    position,    iLocale);    	non-compiled	[CE]  illegal  start  of  type	32	None	replace
227	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono,  iLocale);  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono,  iLocale);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  chrono,  iLocale);	      parser.parseInto(bucket,    text,    position,    iLocale);    	non-compiled	[CE]  illegal  start  of  type	32	None	replace
228	[BUG]  [BUGGY]  parser.parseInto(bucket,  position,  text,  iLocale);  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  position,  text,  iLocale);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  position,  text,  iLocale);	      parser.parseInto(bucket,    text,    position,    iLocale);    	non-compiled	[CE]  illegal  start  of  type	32	None	replace
229	[BUG]  [BUGGY]  parser.parseInto(bucket,  iParserBucket,  text,  position,  iLocale);  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iParserBucket,  text,  position,  iLocale);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iParserBucket,  text,  position,  iLocale);	      parser.parseInto(bucket,    text,    position,    iLocale);    	non-compiled	[CE]  illegal  start  of  type	32	None	replace
230	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  iPivotYear);  [CE]  illegal  start  of  type  [FE]                              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  iPivotYear);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  iLocale,  iPivotYear);	      parser.parseInto(bucket,    text,    position,    iLocale);    	non-compiled	[CE]  illegal  start  of  type	32	None	replace
231	[BUG]  [BUGGY]  parser.parseInto(bucket,  instant,  text,  position,  iLocale);  [CE]  illegal  start  of  type  [FE]                                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  instant,  text,  position,  iLocale);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  instant,  text,  position,  iLocale);	      parser.parseInto(bucket,    text,    position,    iLocale);    	non-compiled	[CE]  illegal  start  of  type	32	None	replace
232	[BUG]  [BUGGY]  parser.parseInto(instant,  text,  position,  iLocale);  [CE]  illegal  start  of  type  [FE]                                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(instant,  text,  position,  iLocale);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(instant,  text,  position,  iLocale);	      parser.parseInto(bucket,    text,    position,    iLocale);    	non-compiled	[CE]  illegal  start  of  type	32	None	replace
233	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  null));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  null));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(bucket.computeMillis(false,  null));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    null));    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
234	[BUG]  [BUGGY]  parsedOffset  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parsedOffset  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parsedOffset  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    null));    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
235	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    null));    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
236	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [CE]  illegal  start  of  type  [FE]                              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    null));    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
237	[BUG]  [BUGGY]  minute  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [CE]  illegal  start  of  type  [FE]                                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  minute  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	minute  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    null));    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
238	[BUG]  [BUGGY]  Instant  parsedZone  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [CE]  illegal  start  of  type  [FE]                                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  Instant  parsedZone  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	Instant  parsedZone  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    null));    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
239	[BUG]  [BUGGY]  Instant  instant  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [CE]  illegal  start  of  type  [FE]                                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  Instant  instant  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	Instant  instant  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    null));    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
240	[BUG]  [BUGGY]  return  newPos  -  1;  newPos  -  1;  [CE]  not  a  statement  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  newPos  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    newPos  -  1;	  timeout    	non-compiled	[CE]  not  a  statement	47	None	add
241	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  text.length();  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  text.length();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  text.length();	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
242	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  iPrinter.parseInto(bucket,  text,  position);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  iPrinter.parseInto(bucket,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  iPrinter.parseInto(bucket,  text,  position);	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
243	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  iParser.parseInto(bucket,  text,  position);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  iParser.parseInto(bucket,  text,  position);	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
244	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  iChrono.parseInstant(instant,  text,  position);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  iChrono.parseInstant(instant,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  iChrono.parseInstant(instant,  text,  position);	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
245	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  iParser.parseInstant(instant,  text,  position);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  iParser.parseInstant(instant,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  iParser.parseInstant(instant,  text,  position);	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
246	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  iPrinter.parseInstant(bucket,  text,  position);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  iPrinter.parseInstant(bucket,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  iPrinter.parseInstant(bucket,  text,  position);	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
247	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  iChrono.parseInstant(instant,  text);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  iChrono.parseInstant(instant,  text);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  iChrono.parseInstant(instant,  text);	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
248	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  iChrono.parseInstant(text,  position);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  iChrono.parseInstant(text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  iChrono.parseInstant(text,  position);	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
249	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  iPrinter.parseInstant(instant,  text,  position);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  iPrinter.parseInstant(instant,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  iPrinter.parseInstant(instant,  text,  position);	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
250	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	31	None	replace
251	[BUG]  [BUGGY]  parsedOffset  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parsedOffset  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parsedOffset  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	31	None	replace
252	[BUG]  [BUGGY]  InstantParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  parsedOffset));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  InstantParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  parsedOffset));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	InstantParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  parsedOffset));	      DateTimeParser    parser    =    iPrinter.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	31	None	replace
253	[BUG]  [BUGGY]  parser  =  iPrinter.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser  =  iPrinter.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser  =  iPrinter.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	31	None	replace
254	[BUG]  [BUGGY]  InstantParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  parsedZone));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  InstantParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  parsedZone));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	InstantParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  parsedZone));	      DateTimeParser    parser    =    iPrinter.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	31	None	replace
255	[BUG]  [BUGGY]  InstantParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  InstantParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	InstantParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));	      DateTimeParser    parser    =    iPrinter.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	31	None	replace
256	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	31	None	replace
257	[BUG]  [BUGGY]  return  instant  +  1;  [timeout]  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant  +  1;  [timeout]  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant  +  1;  [timeout]	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	49	None	replace
258	[BUG]  [BUGGY]  return  position  +  1;  [timeout]  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position  +  1;  [timeout]  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  position  +  1;  [timeout]	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	49	None	replace
259	[BUG]  [BUGGY]  timeout  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position  +  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	add	return  position  +  1;	  return    newPos    +    1;    [timeout]    	compilable	timeout	49	1	replace
260	[BUG]  [BUGGY]  return  position  +  1;  timeout  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position  +  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  position  +  1;	  return    newPos    +    1;    [timeout]    	compilable	timeout	49	1	replace
261	[BUG]  [BUGGY]  return  instant.getPos()  +  1;  [timeout]  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.getPos()  +  1;  [timeout]  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.getPos()  +  1;  [timeout]	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	49	None	replace
262	[BUG]  [BUGGY]  return  iPivotYear  +  1;  [timeout]  ==  AssertionFailedError(instant,  parsedOffset,  chrono);  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  +  1;  [timeout]  ==  AssertionFailedError(instant,  parsedOffset,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  +  1;  [timeout]  ==  AssertionFailedError(instant,  parsedOffset,  chrono);	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	49	None	replace
263	[BUG]  [BUGGY]  return  iPivotYear  +  1;  [timeout]  ==  AssertionFailedError.show(instant,  text,  position,  chrono);  [CE]  illegal  start  of  expression  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  +  1;  [timeout]  ==  AssertionFailedError.show(instant,  text,  position,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  +  1;  [timeout]  ==  AssertionFailedError.show(instant,  text,  position,  chrono);	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	49	None	replace
264	[BUG]  [BUGGY]  return  iPivotYear  +  1;  [timeout]  ==  AssertionFailedError(instant,  text,  position,  chrono);  [CE]  illegal  start  of  expression  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  +  1;  [timeout]  ==  AssertionFailedError(instant,  text,  position,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  +  1;  [timeout]  ==  AssertionFailedError(instant,  text,  position,  chrono);	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	49	None	replace
265	[BUG]  [BUGGY]  return  iPivotYear  +  1;  [timeout]  ==  AssertionFailedError.showInstant(instant,  text,  position,  chrono);  [CE]  illegal  start  of  expression  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  +  1;  [timeout]  ==  AssertionFailedError.showInstant(instant,  text,  position,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  +  1;  [timeout]  ==  AssertionFailedError.showInstant(instant,  text,  position,  chrono);	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	49	None	replace
266	[BUG]  [BUGGY]  long  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  long  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	long  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	38	None	replace
267	[BUG]  [BUGGY]  if(iLocale!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iLocale!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iLocale!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	38	None	replace
268	[BUG]  [BUGGY]  Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	Integer  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	38	None	replace
269	[BUG]  [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	38	None	replace
270	[BUG]  [BUGGY]  long  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  long  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	long  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
271	[BUG]  [BUGGY]  if(iLocale!=  null)  {  int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iLocale!=  null)  {  int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iLocale!=  null)  {  int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
272	[BUG]  [BUGGY]  if(iLocale  ==  null)  {  int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iLocale  ==  null)  {  int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iLocale  ==  null)  {  int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
273	[BUG]  [BUGGY]  if(iPivotYear!=  null)  {  int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iPivotYear!=  null)  {  int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iPivotYear!=  null)  {  int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
274	[BUG]  [BUGGY]  int  iLocale  =  iParser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  iLocale  =  iParser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  iLocale  =  iParser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));	      int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
275	[BUG]  [BUGGY]  int  iLocale  =  iParser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  iLocale  =  iParser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  iLocale  =  iParser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));	      int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
276	[BUG]  [BUGGY]  long  iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  long  iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	long  iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
277	[BUG]  [BUGGY]  return  iParser;  [timeout]  ==  AssertionFailedError.show(instant,  text,  position,  chrono);  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iParser;  [timeout]  ==  AssertionFailedError.show(instant,  text,  position,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iParser;  [timeout]  ==  AssertionFailedError.show(instant,  text,  position,  chrono);	  return    iPivotYear;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	4	None	replace
278	[BUG]  [BUGGY]  return  iParser;  [timeout]  ==  AssertionFailedError.show(instant,  text,  position,  parsedOffset,  chrono);  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iParser;  [timeout]  ==  AssertionFailedError.show(instant,  text,  position,  parsedOffset,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iParser;  [timeout]  ==  AssertionFailedError.show(instant,  text,  position,  parsedOffset,  chrono);	  return    iPivotYear;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	4	None	replace
279	[BUG]  [BUGGY]  return  iParser;  [timeout]  ==  AssertionFailedError.showInstant(instant,  text,  position,  chrono);  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iParser;  [timeout]  ==  AssertionFailedError.showInstant(instant,  text,  position,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iParser;  [timeout]  ==  AssertionFailedError.showInstant(instant,  text,  position,  chrono);	  return    iPivotYear;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	4	None	replace
280	[BUG]  [BUGGY]  return  iParser;  [timeout]  ==  AssertionFailedError.show(instant,  parsedOffset,  chrono);  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iParser;  [timeout]  ==  AssertionFailedError.show(instant,  parsedOffset,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iParser;  [timeout]  ==  AssertionFailedError.show(instant,  parsedOffset,  chrono);	  return    iPivotYear;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	4	None	replace
281	[BUG]  [BUGGY]  return  iParser;  [timeout]  ==  AssertionFailedError.show(instant,  text,  position);  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iParser;  [timeout]  ==  AssertionFailedError.show(instant,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iParser;  [timeout]  ==  AssertionFailedError.show(instant,  text,  position);	  return    iPivotYear;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	4	None	replace
282	[BUG]  [BUGGY]  return  iParser;  [timeout]  ==  AssertionFailedError.showInstant(instant,  text,  position,  parsedOffset,  chrono);  [CE]  illegal  start  of  expression  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iParser;  [timeout]  ==  AssertionFailedError.showInstant(instant,  text,  position,  parsedOffset,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iParser;  [timeout]  ==  AssertionFailedError.showInstant(instant,  text,  position,  parsedOffset,  chrono);	  return    iPivotYear;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	4	None	replace
283	[BUG]  [BUGGY]  return  text;  [CE]  incompatible  types  [FE]        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  text;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  text;	  return    position;    timeout    	non-compiled	[CE]  incompatible  types	35	None	replace
284	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  iParser.parseInto(bucket,  text,  position);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
285	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iPrinter.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iPrinter.parseInto(bucket,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  iPrinter.parseInto(bucket,  text,  position);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
286	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parseInstant(text,  position,  iLocale);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parseInstant(text,  position,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  iParser.parseInstant(text,  position,  iLocale);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
287	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  instant.getParser().parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  instant.getParser().parseInto(bucket,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  instant.getParser().parseInto(bucket,  text,  position);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
288	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parseInstant(text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parseInstant(text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  iParser.parseInstant(text,  position);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
289	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parseInstant(text,  position,  iPivotYear);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parseInstant(text,  position,  iPivotYear);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  iParser.parseInstant(text,  position,  iPivotYear);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
290	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parseInto(instant,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parseInto(instant,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  iParser.parseInto(instant,  text,  position);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
291	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  parser.parseInto(bucket,  text,  position);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
292	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parseInto(bucket);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parseInto(bucket);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  iParser.parseInto(bucket);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
293	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iPrinter.parseInstant(instant,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iPrinter.parseInstant(instant,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  iPrinter.parseInstant(instant,  text,  position);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
294	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
295	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
296	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
297	[BUG]  [BUGGY]  iParser.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInto(bucket,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
298	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(true,  text));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
299	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
300	[BUG]  [BUGGY]  return  position  +  parsedOffset;  [CE]  cannot  find  symbol  parsedOffset  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position  +  parsedOffset;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  position  +  parsedOffset;	  return    newPos    +    parsedOffset;    	non-compiled	[CE]  cannot  find  symbol  parsedOffset	8	None	replace
301	[BUG]  [BUGGY]  return  parsedOffset  +  newPos;  [CE]  cannot  find  symbol  parsedOffset  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  parsedOffset  +  newPos;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  parsedOffset  +  newPos;	  return    newPos    +    parsedOffset;    	non-compiled	[CE]  cannot  find  symbol  parsedOffset	8	None	replace
302	[BUG]  [BUGGY]  return  newPos  +  position;  [timeout]  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  +  position;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  newPos  +  position;	  return    newPos    +    parsedOffset;    	non-compiled	[timeout]	8	None	replace
303	[BUG]  [BUGGY]  return  iOffset  +  parsedOffset;  [timeout]  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iOffset  +  parsedOffset;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iOffset  +  parsedOffset;	  return    newPos    +    parsedOffset;    	non-compiled	[timeout]	8	None	replace
304	[BUG]  [BUGGY]  timeout  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  +  iDefaultYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	add	return  newPos  +  iDefaultYear;	  return    newPos    +    parsedOffset;    	compilable	timeout	8	1	replace
305	[BUG]  [BUGGY]  return  newPos  +  iDefaultYear;  timeout  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  +  iDefaultYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  newPos  +  iDefaultYear;	  return    newPos    +    parsedOffset;    	compilable	timeout	8	1	replace
306	[BUG]  [BUGGY]  return  instant.parsedOffset  +  parsedOffset;  [CE]  cannot  find  symbol  parsedOffset  [FE]                              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.parsedOffset  +  parsedOffset;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.parsedOffset  +  parsedOffset;	  return    newPos    +    parsedOffset;    	non-compiled	[CE]  cannot  find  symbol  parsedOffset	8	None	replace
307	[BUG]  [BUGGY]  return  instant  +  parsedOffset;  [CE]  cannot  find  symbol  parsedOffset  [FE]                                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant  +  parsedOffset;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant  +  parsedOffset;	  return    newPos    +    parsedOffset;    	non-compiled	[CE]  cannot  find  symbol  parsedOffset	8	None	replace
308	[BUG]  [BUGGY]  return  point  +  parsedOffset;  [CE]  cannot  find  symbol  point  [FE]                                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  point  +  parsedOffset;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  point  +  parsedOffset;	  return    newPos    +    parsedOffset;    	non-compiled	[CE]  cannot  find  symbol  point	8	None	replace
309	[BUG]  [BUGGY]  long  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  long  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	long  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position    +    1);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
310	[BUG]  [BUGGY]  Integer  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  Integer  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	Integer  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position    +    1);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
311	[BUG]  [BUGGY]  if(iLocale!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iLocale!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iLocale!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position    +    1);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
312	[BUG]  [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  iParser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position    +    1);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
313	[BUG]  [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  iLocale));	      int    newPos    =    parser.parseInto(bucket,    text,    position    +    1);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
314	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  iLocale));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  iLocale));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(bucket.computeMillis(false,  iLocale));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
315	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(instant.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(instant.computeMillis(true,  text));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
316	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
317	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  iLocale);  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  iLocale);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  iLocale);	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
318	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  text),  iLocale);  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  text),  iLocale);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(instant.computeMillis(false,  text),  iLocale);	      instant.setMillis(instant.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
319	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  text),  iDefaultYear);  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  text),  iDefaultYear);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(instant.computeMillis(false,  text),  iDefaultYear);	      instant.setMillis(instant.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
320	[BUG]  [BUGGY]  instant.setMillis(flush.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(flush.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(flush.computeMillis(false,  text));	      instant.setMillis(instant.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
321	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  text),  chrono);  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  text),  chrono);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(instant.computeMillis(false,  text),  chrono);	      instant.setMillis(instant.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
322	[BUG]  [BUGGY]  iPivotYear  =  parser.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iPivotYear  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iPivotYear  =  parser.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	22	None	replace
323	[BUG]  [BUGGY]  instant.setMillis(parser.computeMillis(false,  text));  iPivotYear  =  parser.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(parser.computeMillis(false,  text));  iPivotYear  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(parser.computeMillis(false,  text));  iPivotYear  =  parser.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	22	None	replace
324	[BUG]  [BUGGY]  instant.setMillis(parser.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(parser.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(parser.computeMillis(false,  text));	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	22	None	replace
325	[BUG]  [BUGGY]  instant.setMillis(iParser.computeMillis(false,  text));  iPivotYear  =  parser.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(iParser.computeMillis(false,  text));  iPivotYear  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(iParser.computeMillis(false,  text));  iPivotYear  =  parser.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	22	None	replace
326	[BUG]  [BUGGY]  moment.setMillis(parser.computeMillis(false,  text));  iPivotYear  =  parser.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  moment.setMillis(parser.computeMillis(false,  text));  iPivotYear  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	moment.setMillis(parser.computeMillis(false,  text));  iPivotYear  =  parser.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	22	None	replace
327	[BUG]  [BUGGY]  return  chrono.withChronology(iChrono);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  chrono.withChronology(iChrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  chrono.withChronology(iChrono);	  return    chrono;    	non-compiled	[CE]  cannot  find  symbol	46	None	replace
328	[BUG]  [BUGGY]  return  chrono.getInstant(iChrono,  parsedOffset,  iDefaultYear);  [CE]  cannot  find  symbol  parsedOffset  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  chrono.getInstant(iChrono,  parsedOffset,  iDefaultYear);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  chrono.getInstant(iChrono,  parsedOffset,  iDefaultYear);	  return    chrono;    	non-compiled	[CE]  cannot  find  symbol  parsedOffset	46	None	replace
329	[BUG]  [BUGGY]  return  chrono.withChronology(chrono);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  chrono.withChronology(chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  chrono.withChronology(chrono);	  return    chrono;    	non-compiled	[CE]  cannot  find  symbol	46	None	replace
330	[BUG]  [BUGGY]  return  chrono.getInstant(iChrono,  iLocale);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  chrono.getInstant(iChrono,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  chrono.getInstant(iChrono,  iLocale);	  return    chrono;    	non-compiled	[CE]  cannot  find  symbol	46	None	replace
331	[BUG]  [BUGGY]  return  chrono.withChronology(iChrono,  iLocale);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  chrono.withChronology(iChrono,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  chrono.withChronology(iChrono,  iLocale);	  return    chrono;    	non-compiled	[CE]  cannot  find  symbol	46	None	replace
332	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position  +  1);  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position  +  1);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  parser.parseInto(bucket,  text,  position  +  1);	      iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
333	[BUG]  [BUGGY]  instant.setChrono(parser.parseInto(bucket,  text,  position);  [CE]  ')'  expected  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setChrono(parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setChrono(parser.parseInto(bucket,  text,  position);	      iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  ')'  expected	17	None	replace
334	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  parser.parseInto(bucket,  text,  position,  newPos);	      iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
335	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position  -  1);  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position  -  1);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  parser.parseInto(bucket,  text,  position  -  1);	      iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
336	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position,  chrono);  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position,  chrono);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  parser.parseInto(bucket,  text,  position,  chrono);	      iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
337	[BUG]  [BUGGY]  iChrono  =  iParser.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  iParser.parseInto(bucket,  text,  position);	      iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
338	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position,  iLocale);  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position,  iLocale);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  parser.parseInto(bucket,  text,  position,  iLocale);	      iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
339	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position,  iPivotYear);  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position,  iPivotYear);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  parser.parseInto(bucket,  text,  position,  iPivotYear);	      iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
340	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    parsedZone));    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
341	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    parsedZone));    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
342	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    parsedZone));    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
343	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  newPos));  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  newPos));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  newPos));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    parsedZone));    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
344	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iDefaultYear));  [CE]  illegal  start  of  type  [FE]                              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iDefaultYear));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iDefaultYear));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    parsedZone));    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
345	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  timeZone));  [CE]  illegal  start  of  type  [FE]                                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  timeZone));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  timeZone));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    parsedZone));    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
346	[BUG]  [BUGGY]  return  iDefaultYear  +  chrono.getChronology().timeout;  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear  +  chrono.getChronology().timeout;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iDefaultYear  +  chrono.getChronology().timeout;	  return    iDefaultYear;    timeout    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
347	[BUG]  [BUGGY]  return  iDefaultYear  +  chrono;  [CE]  bad  operand  types  for  binary  operator  '+'  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear  +  chrono;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iDefaultYear  +  chrono;	  return    iDefaultYear;    timeout    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '+'	3	None	replace
348	[BUG]  [BUGGY]  if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	38	None	replace
349	[BUG]  [BUGGY]  Instant  instant  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  Instant  instant  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	Instant  instant  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
350	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
351	[BUG]  [BUGGY]  parsedZone  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parsedZone  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parsedZone  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
352	[BUG]  [BUGGY]  return  instant.getWritableInstant();  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.getWritableInstant();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.getWritableInstant();	  return    instant;    	non-compiled	[CE]  cannot  find  symbol	1	None	replace
353	[BUG]  [BUGGY]  return  instant.getReadableInstant();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.getReadableInstant();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.getReadableInstant();	  return    instant;    	non-compiled	[CE]  cannot  find  symbol	1	None	replace
354	[BUG]  [BUGGY]  instant.setMillis(iZone.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(iZone.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(iZone.computeMillis(false,  text));	      instant.setMillis(instant.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
355	[BUG]  [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  long  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  long  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    long  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	add
356	[BUG]  [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseInto(bucket,  text,  position);  [CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    int  iLocale  =  iParser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	add
357	[BUG]  [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    int  iLocale  =  iParser.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	add
358	[BUG]  [BUGGY]  instant.setPivot(iPivotYear);  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setPivot(iPivotYear);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setPivot(iPivotYear);	      instant.setChronology(chrono);    	non-compiled	[CE]  illegal  start  of  type	16	None	replace
359	[BUG]  [BUGGY]  instant.setPos(iPivotYear);  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setPos(iPivotYear);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setPos(iPivotYear);	      instant.setChronology(chrono);    	non-compiled	[CE]  illegal  start  of  type	16	None	replace
360	[BUG]  [BUGGY]  instant.setZone(iChrono);  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setZone(iChrono);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setZone(iChrono);	      instant.setChronology(chrono);    	non-compiled	[CE]  illegal  start  of  type	16	None	replace
361	[BUG]  [BUGGY]  instant.setTime(parsedOffset);  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setTime(parsedOffset);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setTime(parsedOffset);	      instant.setChronology(chrono);    	non-compiled	[CE]  illegal  start  of  type	16	None	replace
362	[BUG]  [BUGGY]  return  iChrono.parseInstant(instant,  text,  position);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iChrono.parseInstant(instant,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iChrono.parseInstant(instant,  text,  position);	  return    iChrono;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
363	[BUG]  [BUGGY]  return  iChrono.withZone(chrono);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iChrono.withZone(chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iChrono.withZone(chrono);	  return    iChrono;    [timeout]    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	5	None	replace
364	[BUG]  [BUGGY]  return  iChrono.parseInstant(instant);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iChrono.parseInstant(instant);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iChrono.parseInstant(instant);	  return    iChrono;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
365	[BUG]  [BUGGY]  return  iChrono.getInstant();  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iChrono.getInstant();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iChrono.getInstant();	  return    iChrono;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
366	[BUG]  [BUGGY]  return  iChrono.getInstant(instant);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iChrono.getInstant(instant);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iChrono.getInstant(instant);	  return    iChrono;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
367	[BUG]  [BUGGY]  return  iChrono.parseInstant(instant,  text);  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iChrono.parseInstant(instant,  text);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iChrono.parseInstant(instant,  text);	  return    iChrono;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
368	[BUG]  [BUGGY]  return  iChrono.insert(instant,  chrono);  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iChrono.insert(instant,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iChrono.insert(instant,  chrono);	  return    iChrono;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
369	[BUG]  [BUGGY]  return  iLocal;  [CE]  cannot  find  symbol  iLocal  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iLocal;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iLocal;	  return    parsedOffset;    	non-compiled	[CE]  cannot  find  symbol  iLocal	6	None	replace
370	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  position);	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
371	[BUG]  [BUGGY]  instant.setPos(parsedOffset);  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setPos(parsedOffset);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setPos(parsedOffset);	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
372	[BUG]  [BUGGY]  return  this.iPivotYear  -  1;  [timeout]  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iPivotYear  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iPivotYear  -  1;	  return    this.iPivotYear;    [timeout]    	non-compiled	[timeout]	36	None	replace
373	[BUG]  [BUGGY]  return  this.iPivotYear  -  chrono;  [timeout]  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iPivotYear  -  chrono;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iPivotYear  -  chrono;	  return    this.iPivotYear;    [timeout]    	non-compiled	[timeout]	36	None	replace
374	[BUG]  [BUGGY]  return  this.iPivotYear  +  1;  [timeout]  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iPivotYear  +  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iPivotYear  +  1;	  return    this.iPivotYear;    [timeout]    	non-compiled	[timeout]	36	None	replace
375	[BUG]  [BUGGY]  return  this.iPivotYear  +  chrono;  [timeout]  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iPivotYear  +  chrono;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iPivotYear  +  chrono;	  return    this.iPivotYear;    [timeout]    	non-compiled	[timeout]	36	None	replace
376	[BUG]  [BUGGY]  return  this.iPivotYear  +  iDefaultYear;  [timeout]  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iPivotYear  +  iDefaultYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iPivotYear  +  iDefaultYear;	  return    this.iPivotYear;    [timeout]    	non-compiled	[timeout]	36	None	replace
377	[BUG]  [BUGGY]  int  iLocale  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  iLocale  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  iLocale  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));	      int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
378	[BUG]  [BUGGY]  iParser  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
379	[BUG]  [BUGGY]  iParser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInstant(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
380	[BUG]  [BUGGY]  return  iPivotYear  +  chrono;  [CE]  bad  operand  types  for  binary  operator  '+'  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  +  chrono;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  +  chrono;	  return    iPivotYear;    [timeout]    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '+'	4	None	replace
381	[BUG]  [BUGGY]  return  iPivotYear  +  chrono.getLocale();  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  +  chrono.getLocale();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  +  chrono.getLocale();	  return    iPivotYear;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
382	[BUG]  [BUGGY]  return  iPivotYear  -  chrono;  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  -  chrono;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  -  chrono;	  return    iPivotYear;    [timeout]    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	4	None	replace
383	[BUG]  [BUGGY]  return  iPivotYear  +  chrono.getChronology().timeout;  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  +  chrono.getChronology().timeout;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  +  chrono.getChronology().timeout;	  return    iPivotYear;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
384	[BUG]  [BUGGY]  return  iPivotYear  +  chrono.getChronology();  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  +  chrono.getChronology();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  +  chrono.getChronology();	  return    iPivotYear;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
385	[BUG]  [BUGGY]  return  iLocale.get(instant);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iLocale.get(instant);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iLocale.get(instant);	  return    iLocale;    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
386	[BUG]  [BUGGY]  return  iLocale.getDefault();  [CE]  incompatible  types  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iLocale.getDefault();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iLocale.getDefault();	  return    iLocale;    	non-compiled	[CE]  incompatible  types	7	None	replace
387	[BUG]  [BUGGY]  return  iLocale.getInstant();  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iLocale.getInstant();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iLocale.getInstant();	  return    iLocale;    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
388	[BUG]  [BUGGY]  return  iLocale.fromInt(position,  chrono);  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iLocale.fromInt(position,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iLocale.fromInt(position,  chrono);	  return    iLocale;    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
389	[BUG]  [BUGGY]  instant.setPivot(iPivotYear);  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  instant.setPivot(iPivotYear);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	instant.setPivot(iPivotYear);	      	non-compiled	[CE]  cannot  find  symbol	12	None	replace
390	[BUG]  [BUGGY]  parsedOffset  =  instant.getOffsetInteger();  [CE]  cannot  find  symbol  parsedOffset  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  parsedOffset  =  instant.getOffsetInteger();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	parsedOffset  =  instant.getOffsetInteger();	      	non-compiled	[CE]  cannot  find  symbol  parsedOffset	12	None	replace
391	[BUG]  [BUGGY]  parser.parseInto(instant,  text,  position,  iLocale);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  parser.parseInto(instant,  text,  position,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	parser.parseInto(instant,  text,  position,  iLocale);	      	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	12	None	replace
392	[BUG]  [BUGGY]  return  chrono.withChronology(instant);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  chrono.withChronology(instant);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  chrono.withChronology(instant);	  return    chrono;    	non-compiled	[CE]  cannot  find  symbol	46	None	replace
393	[BUG]  [BUGGY]  return  chrono.getInstantChronology();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  chrono.getInstantChronology();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  chrono.getInstantChronology();	  return    chrono;    	non-compiled	[CE]  cannot  find  symbol	46	None	replace
394	[BUG]  [BUGGY]  return  chrono.withChronology(iChrono,  instant);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  chrono.withChronology(iChrono,  instant);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  chrono.withChronology(iChrono,  instant);	  return    chrono;    	non-compiled	[CE]  cannot  find  symbol	46	None	replace
395	[BUG]  [BUGGY]  return  chrono.iChrono;  [CE]  cannot  find  symbol  iChrono  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  chrono.iChrono;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  chrono.iChrono;	  return    chrono;    	non-compiled	[CE]  cannot  find  symbol  iChrono	46	None	replace
396	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  chrono,  iPivotYear);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iPivotYear);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	33	None	replace
397	[BUG]  [BUGGY]  if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position    -    1);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	40	None	replace
398	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iChrono.withZone(iPivotYear);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iChrono.withZone(iPivotYear);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  iChrono.withZone(iPivotYear);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
399	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parse(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parse(bucket,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  iParser.parse(bucket,  text,  position);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
400	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iPrinter.parse(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iPrinter.parse(bucket,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  iPrinter.parse(bucket,  text,  position);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
401	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iPrinter.parseInto(bucket,  text,  position,  iLocale);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iPrinter.parseInto(bucket,  text,  position,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  iPrinter.parseInto(bucket,  text,  position,  iLocale);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
402	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iPivotYear;  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iPivotYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  iPivotYear;	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
403	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parseInto(bucket,  text,  position,  iLocale);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parseInto(bucket,  text,  position,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  iParser.parseInto(bucket,  text,  position,  iLocale);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
404	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  newPos,  iLocale);  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  newPos,  iLocale);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  newPos,  iLocale);	      parser.parseInto(bucket,    text,    position,    newPos);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	30	None	replace
405	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iPivotYear,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iPivotYear,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  iPivotYear,  newPos);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    newPos);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	30	None	replace
406	[BUG]  [BUGGY]  return  newPos  +  iOffset;  [CE]  cannot  find  symbol  iOffset  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  +  iOffset;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  newPos  +  iOffset;	  return    newPos    +    parsedOffset;    	non-compiled	[CE]  cannot  find  symbol  iOffset	8	None	replace
407	[BUG]  [BUGGY]  return  newPos  +  iLocale;  [CE]  bad  operand  types  for  binary  operator  '+'  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  +  iLocale;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  newPos  +  iLocale;	  return    newPos    +    parsedOffset;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '+'	8	None	replace
408	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  null));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  null));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  null));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    null));    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
409	[BUG]  [BUGGY]  Instant  instant  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  Instant  instant  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	Instant  instant  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    null));    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
410	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  null);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  null);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  null);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(instant,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	43	None	replace
411	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  newPos);  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  newPos);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  newPos);	      parser.parseInto(instant,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	43	None	replace
412	[BUG]  [BUGGY]  parser.parseInto(instant,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(instant,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(instant,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(instant,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	43	None	replace
413	[BUG]  [BUGGY]  return  iPivotYear  +  1;  [timeout]  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  +  1;  [timeout]  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  +  1;  [timeout]	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	49	None	replace
414	[BUG]  [BUGGY]  return  iPivotYear  +  1;  [timeout]  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  +  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  +  1;	  return    newPos    +    1;    [timeout]    	non-compiled	[timeout]	49	None	replace
415	[BUG]  [BUGGY]  return  instant  +  1;  [timeout]  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant  +  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant  +  1;	  return    newPos    +    1;    [timeout]    	non-compiled	[timeout]	49	None	replace
416	[BUG]  [BUGGY]  return  newPos  /  1;  [timeout]  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  /  1;  [timeout]  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  newPos  /  1;  [timeout]	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	49	None	replace
417	[BUG]  [BUGGY]  return  this.iChrono  +  1;  [CE]  bad  operand  types  for  binary  operator  '+'  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iChrono  +  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iChrono  +  1;	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '+'	49	None	replace
418	[BUG]  [BUGGY]  return  newPos  +  1;  instant.setTimeout(timeout);  [CE]  cannot  find  symbol  timeout  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  +  1;  instant.setTimeout(timeout);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  newPos  +  1;  instant.setTimeout(timeout);	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  cannot  find  symbol  timeout	49	None	replace
419	[BUG]  [BUGGY]  if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
420	[BUG]  [BUGGY]  iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    newPos    =    parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
421	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iPivotYear  =  iParser.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iPivotYear  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);  iPivotYear  =  iParser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	15	None	add
422	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iParser  =  iParser.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iParser  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iParser  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);  iParser  =  iParser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iParser	15	None	add
423	[BUG]  [BUGGY]      instant.setChronology(chrono);  Instant  instant.setChronology(chrono);  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  Instant  instant.setChronology(chrono);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    Instant  instant.setChronology(chrono);	  	non-compiled	[CE]  ';'  expected	15	None	add
424	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iPivotYear  =  iPrinter.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iPivotYear  =  iPrinter.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);  iPivotYear  =  iPrinter.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	15	None	add
425	[BUG]  [BUGGY]  timeout  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(this.iPivotYear!=  null?  this.iPivotYear  :  iDefaultYear);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	add	return(this.iPivotYear!=  null?  this.iPivotYear  :  iDefaultYear);	  return    this.iDefaultYear;    timeout    	compilable	timeout	11	1	replace
426	[BUG]  [BUGGY]  return(this.iPivotYear!=  null?  this.iPivotYear  :  iDefaultYear);  timeout  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(this.iPivotYear!=  null?  this.iPivotYear  :  iDefaultYear);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(this.iPivotYear!=  null?  this.iPivotYear  :  iDefaultYear);	  return    this.iDefaultYear;    timeout    	compilable	timeout	11	1	replace
427	[BUG]  [BUGGY]  return(this.iPivotYear  >=  iLocale?  this.iPivotYear  :  iDefaultYear);  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(this.iPivotYear  >=  iLocale?  this.iPivotYear  :  iDefaultYear);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(this.iPivotYear  >=  iLocale?  this.iPivotYear  :  iDefaultYear);	  return    this.iDefaultYear;    timeout    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	11	None	replace
428	[BUG]  [BUGGY]  return(this.iPivotYear  >=  iDefaultYear)?  this.iPivotYear  :  this.iDefaultYear;  [timeout]  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(this.iPivotYear  >=  iDefaultYear)?  this.iPivotYear  :  this.iDefaultYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(this.iPivotYear  >=  iDefaultYear)?  this.iPivotYear  :  this.iDefaultYear;	  return    this.iDefaultYear;    timeout    	non-compiled	[timeout]	11	None	replace
429	[BUG]  [BUGGY]  return(this.iPivotYear  ==  iDefaultYear)?  this.iPivotYear  :  this.iDefaultYear;  [timeout]  [FE]                              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(this.iPivotYear  ==  iDefaultYear)?  this.iPivotYear  :  this.iDefaultYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(this.iPivotYear  ==  iDefaultYear)?  this.iPivotYear  :  this.iDefaultYear;	  return    this.iDefaultYear;    timeout    	non-compiled	[timeout]	11	None	replace
430	[BUG]  [BUGGY]  return(this.iPivotYear  >=  iDefaultYear)?  this.iPivotYear  :  iDefaultYear;  [timeout]  [FE]                                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(this.iPivotYear  >=  iDefaultYear)?  this.iPivotYear  :  iDefaultYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(this.iPivotYear  >=  iDefaultYear)?  this.iPivotYear  :  iDefaultYear;	  return    this.iDefaultYear;    timeout    	non-compiled	[timeout]	11	None	replace
431	[BUG]  [BUGGY]  return(this.iPivotYear!=  iDefaultYear)?  this.iPivotYear  :  this.iDefaultYear;  [timeout]  [FE]                                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(this.iPivotYear!=  iDefaultYear)?  this.iPivotYear  :  this.iDefaultYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(this.iPivotYear!=  iDefaultYear)?  this.iPivotYear  :  this.iDefaultYear;	  return    this.iDefaultYear;    timeout    	non-compiled	[timeout]	11	None	replace
432	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    parsedZone));    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
433	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iZone));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iZone));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iZone));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    parsedZone));    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
434	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iPivotYear));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iPivotYear));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iPivotYear));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    parsedZone));    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
435	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iDefaultYear));  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iDefaultYear));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iDefaultYear));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    parsedZone));    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
436	[BUG]  [BUGGY]  InstantParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  InstantParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	InstantParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	31	None	replace
437	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	31	None	replace
438	[BUG]  [BUGGY]  DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	31	None	replace
439	[BUG]  [BUGGY]  InstantParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  InstantParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	InstantParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      DateTimeParser    parser    =    iPrinter.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	31	None	replace
440	[BUG]  [BUGGY]  Integer  newPos  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  Integer  newPos  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	Integer  newPos  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	31	None	replace
441	[BUG]  [BUGGY]  iChrono  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	31	None	replace
442	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono);  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  chrono);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  chrono);	      parser.parseInto(bucket,    text,    position,    iLocale);    	non-compiled	[CE]  illegal  start  of  type	32	None	replace
443	[BUG]  [BUGGY]  parser.parseInto(bucket,  iZone,  text,  position,  iLocale);  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iZone,  text,  position,  iLocale);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iZone,  text,  position,  iLocale);	      parser.parseInto(bucket,    text,    position,    iLocale);    	non-compiled	[CE]  illegal  start  of  type	32	None	replace
444	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  instant);  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  instant);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  iLocale,  instant);	      parser.parseInto(bucket,    text,    position,    iLocale);    	non-compiled	[CE]  illegal  start  of  type	32	None	replace
445	[BUG]  [BUGGY]  parser.parseInto(bucket,  iLocale,  position,  text);  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  iLocale,  position,  text);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  iLocale,  position,  text);	      parser.parseInto(bucket,    text,    position,    iLocale);    	non-compiled	[CE]  illegal  start  of  type	32	None	replace
446	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	20	None	add
447	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	20	None	add
448	[BUG]  [BUGGY]  [FE]  StringIndexOutOfBoundsException  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	add	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  StringIndexOutOfBoundsException  	20	7	add
449	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  StringIndexOutOfBoundsException  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  StringIndexOutOfBoundsException  	20	7	add
450	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  iParser.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    iParser.parse(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	20	None	add
451	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  iChrono.parseInto(bucket,  text,  position);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  iChrono.parseInto(bucket,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  iChrono.parseInto(bucket,  text,  position);	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
452	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  getOffset(bucket.getOffsetInteger(),  parsedOffset);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  getOffset(bucket.getOffsetInteger(),  parsedOffset);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  getOffset(bucket.getOffsetInteger(),  parsedOffset);	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
453	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  iChrono.parseInstant(bucket,  text,  position);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  iChrono.parseInstant(bucket,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  iChrono.parseInstant(bucket,  text,  position);	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
454	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  iChrono.parseInstant(instant);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  iChrono.parseInstant(instant);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  iChrono.parseInstant(instant);	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
455	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  instant.getPivotYear();  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  instant.getPivotYear();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  instant.getPivotYear();	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
456	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  getOffset(bucket.getOffsetInteger());  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  getOffset(bucket.getOffsetInteger());  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  getOffset(bucket.getOffsetInteger());	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
457	[BUG]  [BUGGY]  iChrono  =  chrono.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  chrono.parseInto(bucket,  text,  position);	      iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
458	[BUG]  [BUGGY]  if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  }  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    iChrono));    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
459	[BUG]  [BUGGY]  if(iChrono!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iChrono!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iChrono!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    iChrono));    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
460	[BUG]  [BUGGY]  return  this.iDefaultYear;  int  newPos  =  instant.getOffsetInteger();  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  int  newPos  =  instant.getOffsetInteger();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    int  newPos  =  instant.getOffsetInteger();	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	10	None	add
461	[BUG]  [BUGGY]  return  this.iDefaultYear;  instant.setChrono(iChrono);  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  instant.setChrono(iChrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    instant.setChrono(iChrono);	  timeout    	non-compiled	[CE]  cannot  find  symbol	10	None	add
462	[BUG]  [BUGGY]  return  this.iDefaultYear;  iPivotYear  =  parsedZone.getParser();  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  iPivotYear  =  parsedZone.getParser();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    iPivotYear  =  parsedZone.getParser();	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	10	None	add
463	[BUG]  [BUGGY]  return  this.iDefaultYear;  int  newPos  =  text.length();  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  int  newPos  =  text.length();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    int  newPos  =  text.length();	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	10	None	add
464	[BUG]  [BUGGY]  return  position  -  chrono;  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position  -  chrono;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  position  -  chrono;	  return    position;    timeout    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	35	None	replace
465	[BUG]  [BUGGY]  return  position  -  chrono.parseInto(bucket,  iLocale);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position  -  chrono.parseInto(bucket,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  position  -  chrono.parseInto(bucket,  iLocale);	  return    position;    timeout    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
466	[BUG]  [BUGGY]  return  position  -  chrono.getLocale();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position  -  chrono.getLocale();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  position  -  chrono.getLocale();	  return    position;    timeout    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
467	[BUG]  [BUGGY]  return  position  -  chrono.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position  -  chrono.parseInto(bucket,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  position  -  chrono.parseInto(bucket,  text,  position);	  return    position;    timeout    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
468	[BUG]  [BUGGY]  return  position  +  chrono.getLocale();  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position  +  chrono.getLocale();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  position  +  chrono.getLocale();	  return    position;    timeout    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
469	[BUG]  [BUGGY]  return  position  -  chrono.parseInto(bucket,  iPivotYear);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position  -  chrono.parseInto(bucket,  iPivotYear);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  position  -  chrono.parseInto(bucket,  iPivotYear);	  return    position;    timeout    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
470	[BUG]  [BUGGY]  Instant  instant  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  Instant  instant  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	Instant  instant  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
471	[BUG]  [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(true,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
472	[BUG]  [BUGGY]  return  instant.getPos  -  1;  [CE]  cannot  find  symbol  getPos  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.getPos  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.getPos  -  1;	  return    newPos    -    1;    timeout    	non-compiled	[CE]  cannot  find  symbol  getPos	48	None	replace
473	[BUG]  [BUGGY]  return  instant.iPivotYear  -  1;  [CE]  cannot  find  symbol  iPivotYear  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.iPivotYear  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.iPivotYear  -  1;	  return    newPos    -    1;    timeout    	non-compiled	[CE]  cannot  find  symbol  iPivotYear	48	None	replace
474	[BUG]  [BUGGY]  return  iPivot.insert(instant,  chrono);  [CE]  cannot  find  symbol  iPivot  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivot.insert(instant,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivot.insert(instant,  chrono);	  return    iPivot;    [timeout]    	non-compiled	[CE]  cannot  find  symbol  iPivot	37	None	replace
475	[BUG]  [BUGGY]  return  iPivot.insertInt(instant,  chrono);  [CE]  cannot  find  symbol  iPivot  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivot.insertInt(instant,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivot.insertInt(instant,  chrono);	  return    iPivot;    [timeout]    	non-compiled	[CE]  cannot  find  symbol  iPivot	37	None	replace
476	[BUG]  [BUGGY]  return  iPivot.insert(instantMillis,  chrono);  [CE]  cannot  find  symbol  iPivot  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivot.insert(instantMillis,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivot.insert(instantMillis,  chrono);	  return    iPivot;    [timeout]    	non-compiled	[CE]  cannot  find  symbol  iPivot	37	None	replace
477	[BUG]  [BUGGY]  return  iPivot.insert(instant);  [CE]  cannot  find  symbol  iPivot  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivot.insert(instant);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivot.insert(instant);	  return    iPivot;    [timeout]    	non-compiled	[CE]  cannot  find  symbol  iPivot	37	None	replace
478	[BUG]  [BUGGY]  DateTimeParser  parser  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  DateTimeParser  parser  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	DateTimeParser  parser  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
479	[BUG]  [BUGGY]  iParser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
480	[BUG]  [BUGGY]  return  position;  int  position  =  iChrono.parseInstant(instant,  text);  [CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  int  position  =  iChrono.parseInstant(instant,  text);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    int  position  =  iChrono.parseInstant(instant,  text);	  timeout    	non-compiled	[CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	34	None	add
481	[BUG]  [BUGGY]  return  position;  int  position  =  iChrono.parseInstant(instant,  text,  position);  [CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  int  position  =  iChrono.parseInstant(instant,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    int  position  =  iChrono.parseInstant(instant,  text,  position);	  timeout    	non-compiled	[CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	34	None	add
482	[BUG]  [BUGGY]  return  position;  int  position  =  iChrono.parseInstant(instant);  [CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  int  position  =  iChrono.parseInstant(instant);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    int  position  =  iChrono.parseInstant(instant);	  timeout    	non-compiled	[CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	34	None	add
483	[BUG]  [BUGGY]  return  position;  timeout  =  System.currentTimeMillis();  [CE]  cannot  find  symbol  timeout  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  timeout  =  System.currentTimeMillis();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    timeout  =  System.currentTimeMillis();	  timeout    	non-compiled	[CE]  cannot  find  symbol  timeout	34	None	add
484	[BUG]  [BUGGY]  return  position;  int  position  =  iChrono.parseInto(bucket,  text,  position);  [CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  int  position  =  iChrono.parseInto(bucket,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    int  position  =  iChrono.parseInto(bucket,  text,  position);	  timeout    	non-compiled	[CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	34	None	add
485	[BUG]  [BUGGY]  return  position;  iChrono  =  parsedZone.withChronology(chrono);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  iChrono  =  parsedZone.withChronology(chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    iChrono  =  parsedZone.withChronology(chrono);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	34	None	add
486	[BUG]  [BUGGY]  if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	45	None	replace
487	[BUG]  [BUGGY]  if(iLocale!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iLocale!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iLocale!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	45	None	replace
488	[BUG]  [BUGGY]  instant.setMillis(parser.computeMillis(false,  text),  position);  iPivotYear  =  parser.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(parser.computeMillis(false,  text),  position);  iPivotYear  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(parser.computeMillis(false,  text),  position);  iPivotYear  =  parser.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	22	None	replace
489	[BUG]  [BUGGY]  if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iPivotYear!=  null)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position    +    1);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
490	[BUG]  [BUGGY]  if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position    +    1);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	39	None	replace
491	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(flush.computeMillis(false,  text));  [CE]  cannot  find  symbol  flush  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(flush.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(flush.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  flush	13	None	add
492	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(str.computeMillis(false,  text));  [CE]  cannot  find  symbol  str  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(str.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(str.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  str	13	None	add
493	[BUG]  [BUGGY]  return  this.iChrono.insertInt(instant,  iLocale);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iChrono.insertInt(instant,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iChrono.insertInt(instant,  iLocale);	  return    this.iChrono;    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
494	[BUG]  [BUGGY]  return  this.iChrono.insert(instant,  iLocale);  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iChrono.insert(instant,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iChrono.insert(instant,  iLocale);	  return    this.iChrono;    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
495	[BUG]  [BUGGY]  return  this.iChrono.getInstant(instant,  iLocale);  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iChrono.getInstant(instant,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iChrono.getInstant(instant,  iLocale);	  return    this.iChrono;    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
496	[BUG]  [BUGGY]  return  this.iChrono.setChronology(chrono);  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iChrono.setChronology(chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iChrono.setChronology(chrono);	  return    this.iChrono;    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
497	[BUG]  [BUGGY]  return  new  ReadWritableInstant(instant,  this.iChrono);  [CE]  ReadWritableInstant  is  abstract;  cannot  be  instantiated  [FE]                              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  new  ReadWritableInstant(instant,  this.iChrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  new  ReadWritableInstant(instant,  this.iChrono);	  return    this.iChrono;    	non-compiled	[CE]  ReadWritableInstant  is  abstract;  cannot  be  instantiated	9	None	replace
498	[BUG]  [BUGGY]  return  this.iChrono.insertInt(instant,  0,  iLocale);  [CE]  cannot  find  symbol  [FE]                                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iChrono.insertInt(instant,  0,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iChrono.insertInt(instant,  0,  iLocale);	  return    this.iChrono;    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
499	[BUG]  [BUGGY]  return  this.iChrono.getInstantValue(instant,  iLocale);  [CE]  cannot  find  symbol  [FE]                                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iChrono.getInstantValue(instant,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iChrono.getInstantValue(instant,  iLocale);	  return    this.iChrono;    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
500	[BUG]  [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position,  iLocale);  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position,  iLocale);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  iParser.parseInto(bucket,  text,  position,  iLocale);	      int    newPos    =    parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	41	None	replace
501	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iChrono,  iLocale);  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iChrono,  iLocale);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  iChrono,  iLocale);	      parser.parseInto(bucket,    text,    position,    iLocale);    	non-compiled	[CE]  illegal  start  of  type	32	None	replace
502	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  iDefaultYear);  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  iDefaultYear);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  iLocale,  iDefaultYear);	      parser.parseInto(bucket,    text,    position,    iLocale);    	non-compiled	[CE]  illegal  start  of  type	32	None	replace
503	[BUG]  [BUGGY]  if(iChrono!=  null)  {  DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iChrono!=  null)  {  DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iChrono!=  null)  {  DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      DateTimeParser    parser    =    iPrinter.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	31	None	replace
504	[BUG]  [BUGGY]  if(iParser!=  null)  {  DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iParser!=  null)  {  DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iParser!=  null)  {  DateTimeParser  parser  =  iPrinter.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      DateTimeParser    parser    =    iPrinter.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	31	None	replace
505	[BUG]  [BUGGY]  DateTimeParser  parser  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  DateTimeParser  parser  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	DateTimeParser  parser  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    iPrinter.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	31	None	replace
506	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  instant.getParser().parseInto(bucket,  text,  position,  iLocale);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  instant.getParser().parseInto(bucket,  text,  position,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  instant.getParser().parseInto(bucket,  text,  position,  iLocale);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
507	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  instant.getParser().parseInto(bucket,  text,  position);  return  iDefaultYear;  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  instant.getParser().parseInto(bucket,  text,  position);  return  iDefaultYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  instant.getParser().parseInto(bucket,  text,  position);  return  iDefaultYear;	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
508	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parseInto(bucket,  text,  position);  return  iDefaultYear;  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iParser.parseInto(bucket,  text,  position);  return  iDefaultYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  iParser.parseInto(bucket,  text,  position);  return  iDefaultYear;	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
509	[BUG]  [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iChrono.parseInstant(text,  position,  iLocale);  [CE]  cannot  assign  a  value  to  final  variable  iDefaultYear  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear;  iDefaultYear  =  iChrono.parseInstant(text,  position,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    iDefaultYear;    iDefaultYear  =  iChrono.parseInstant(text,  position,  iLocale);	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iDefaultYear	2	None	add
510	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  getOffset(bucket.getOffsetInteger(),  parsedOffset);  return  newPos  -  1;  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  getOffset(bucket.getOffsetInteger(),  parsedOffset);  return  newPos  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  getOffset(bucket.getOffsetInteger(),  parsedOffset);  return  newPos  -  1;	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
511	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  iChrono.parseInto(bucket,  text,  position);  return  newPos  -  1;  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  iChrono.parseInto(bucket,  text,  position);  return  newPos  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  iChrono.parseInto(bucket,  text,  position);  return  newPos  -  1;	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
512	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  getOffset(bucket.getOffset(),  parsedOffset);  return  newPos  -  1;  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  getOffset(bucket.getOffset(),  parsedOffset);  return  newPos  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  getOffset(bucket.getOffset(),  parsedOffset);  return  newPos  -  1;	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
513	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  getOffset(bucket.getOffsetInteger(),  position);  return  newPos  -  1;  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  getOffset(bucket.getOffsetInteger(),  position);  return  newPos  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  getOffset(bucket.getOffsetInteger(),  position);  return  newPos  -  1;	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
514	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  getOffset(bucket.getLocalMillis(),  position);  return  newPos  -  1;  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  getOffset(bucket.getLocalMillis(),  position);  return  newPos  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  getOffset(bucket.getLocalMillis(),  position);  return  newPos  -  1;	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
515	[BUG]  [BUGGY]  return  newPos  -  1;  int  newPos  =  getOffset(bucket.getOffsetInteger(),  position);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  newPos  -  1;  int  newPos  =  getOffset(bucket.getOffsetInteger(),  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    newPos    -    1;    int  newPos  =  getOffset(bucket.getOffsetInteger(),  position);	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	47	None	add
516	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  iLocale,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  iLocale,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    iLocale);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	28	None	replace
517	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    parsedZone));    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
518	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  parsedZone));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  parsedZone));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  parsedZone));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    parsedZone));    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
519	[BUG]  [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  oldPos));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  oldPos));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  oldPos));	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    parsedZone));    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
520	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  newPos);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  newPos);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  newPos);  instant.setMillis(bucket.computeMillis(true,  text));	      parser.parseInto(instant,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	43	None	replace
521	[BUG]  [BUGGY]  parser.parseInto(instant,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(instant,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(instant,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(instant,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	43	None	replace
522	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  oldPos);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  oldPos);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  oldPos);  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(instant,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	43	None	replace
523	[BUG]  [BUGGY]  return  position;  instant.setChronology(chrono);  return  position;  [CE]  unreachable  statement  [FE]        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  instant.setChronology(chrono);  return  position;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    instant.setChronology(chrono);  return  position;	  timeout    	non-compiled	[CE]  unreachable  statement	34	None	add
524	[BUG]  [BUGGY]  return  position;  int  position  =  iChrono.getLocalMillis(parsedOffset);  [CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  int  position  =  iChrono.getLocalMillis(parsedOffset);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    int  position  =  iChrono.getLocalMillis(parsedOffset);	  timeout    	non-compiled	[CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	34	None	add
525	[BUG]  [BUGGY]  return  position;  int  position  =  parsedOffset  -  text.length();  [CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  int  position  =  parsedOffset  -  text.length();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    int  position  =  parsedOffset  -  text.length();	  timeout    	non-compiled	[CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	34	None	add
526	[BUG]  [BUGGY]  return  position;  int  position  =  iChrono.parseInsertion(text,  position);  [CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  int  position  =  iChrono.parseInsertion(text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    int  position  =  iChrono.parseInsertion(text,  position);	  timeout    	non-compiled	[CE]  variable  position  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	34	None	add
527	[BUG]  [BUGGY]  return  position;  iLocale  =  locale.getLocale();  [CE]  cannot  assign  a  value  to  final  variable  iLocale  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position;  iLocale  =  locale.getLocale();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    position;    iLocale  =  locale.getLocale();	  timeout    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iLocale	34	None	add
528	[BUG]  [BUGGY]  return  iChrono.parseInstant(instant,  text,  position,  chrono);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iChrono.parseInstant(instant,  text,  position,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iChrono.parseInstant(instant,  text,  position,  chrono);	  return    iChrono;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
529	[BUG]  [BUGGY]  return  iChrono.parseInstant(text,  position,  chrono);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iChrono.parseInstant(text,  position,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iChrono.parseInstant(text,  position,  chrono);	  return    iChrono;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
530	[BUG]  [BUGGY]  return  iChrono.insertInt(instant,  chrono.getLocale());  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iChrono.insertInt(instant,  chrono.getLocale());  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iChrono.insertInt(instant,  chrono.getLocale());	  return    iChrono;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
531	[BUG]  [BUGGY]  return  iChrono.parseInto(bucket,  text,  position,  chrono);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iChrono.parseInto(bucket,  text,  position,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iChrono.parseInto(bucket,  text,  position,  chrono);	  return    iChrono;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
532	[BUG]  [BUGGY]  return  iChrono.parseInto(instant,  text,  position,  chrono);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iChrono.parseInto(instant,  text,  position,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iChrono.parseInto(instant,  text,  position,  chrono);	  return    iChrono;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
533	[BUG]  [BUGGY]  return  iPivotYear  +  1;  [timeout]  >>  AssertionFailedError,  chrono);  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  +  1;  [timeout]  >>  AssertionFailedError,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  +  1;  [timeout]  >>  AssertionFailedError,  chrono);	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	49	None	replace
534	[BUG]  [BUGGY]  return  this.iPivotYear  +  1;  [timeout]  >>  AssertionFailedError,  iChrono,  chrono);  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iPivotYear  +  1;  [timeout]  >>  AssertionFailedError,  iChrono,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iPivotYear  +  1;  [timeout]  >>  AssertionFailedError,  iChrono,  chrono);	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	49	None	replace
535	[BUG]  [BUGGY]  return  this.iPivotYear  +  1;  [timeout]  >>  AssertionFailedError,  chrono);  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iPivotYear  +  1;  [timeout]  >>  AssertionFailedError,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iPivotYear  +  1;  [timeout]  >>  AssertionFailedError,  chrono);	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	49	None	replace
536	[BUG]  [BUGGY]  return  this.iPivotYear  +  1;  [timeout]  >>  AssertionFailedError?  instant.getChronology()  :  chrono;  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iPivotYear  +  1;  [timeout]  >>  AssertionFailedError?  instant.getChronology()  :  chrono;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iPivotYear  +  1;  [timeout]  >>  AssertionFailedError?  instant.getChronology()  :  chrono;	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	49	None	replace
537	[BUG]  [BUGGY]  return  this.iPivotYear  +  1;  [timeout]  >>  AssertionFailedError?  instant.getChronology()  :  null;  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iPivotYear  +  1;  [timeout]  >>  AssertionFailedError?  instant.getChronology()  :  null;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iPivotYear  +  1;  [timeout]  >>  AssertionFailedError?  instant.getChronology()  :  null;	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	49	None	replace
538	[BUG]  [BUGGY]  return  this.iPivotYear  +  1;  [timeout]  >>  AssertionFailedError  &&  chrono.hasChronology(chrono);  [CE]  illegal  start  of  expression  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iPivotYear  +  1;  [timeout]  >>  AssertionFailedError  &&  chrono.hasChronology(chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iPivotYear  +  1;  [timeout]  >>  AssertionFailedError  &&  chrono.hasChronology(chrono);	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	49	None	replace
539	[BUG]  [BUGGY]  return  this.iPivotYear  +  1;  [timeout]  [Delete]  AssertionFailedError?  instant.getChronology()  :  null;  [CE]  illegal  start  of  expression  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iPivotYear  +  1;  [timeout]  [Delete]  AssertionFailedError?  instant.getChronology()  :  null;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iPivotYear  +  1;  [timeout]  [Delete]  AssertionFailedError?  instant.getChronology()  :  null;	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	49	None	replace
540	[BUG]  [BUGGY]  return  iPivotYear  +  1;  [timeout]  >>  AssertionFailedError,  parsedOffset,  chrono);  [CE]  illegal  start  of  expression  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  +  1;  [timeout]  >>  AssertionFailedError,  parsedOffset,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  +  1;  [timeout]  >>  AssertionFailedError,  parsedOffset,  chrono);	  return    newPos    +    1;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	49	None	replace
541	[BUG]  [BUGGY]  iChrono  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
542	[BUG]  [BUGGY]  Instant  instant  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  Instant  instant  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	Instant  instant  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
543	[BUG]  [BUGGY]  iChrono  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
544	[BUG]  [BUGGY]  parsedZone  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parsedZone  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parsedZone  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	18	None	replace
545	[BUG]  [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    int  iLocale  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	add
546	[BUG]  [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    int  iLocale  =  iParser.parseTo(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	add
547	[BUG]  [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseFrom(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  int  iLocale  =  iParser.parseFrom(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    int  iLocale  =  iParser.parseFrom(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  variable  iLocale  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	add
548	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iLocale  =  Locale.getDefault();  [CE]  cannot  assign  a  value  to  final  variable  iLocale  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iLocale  =  Locale.getDefault();  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);  iLocale  =  Locale.getDefault();	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iLocale	15	None	add
549	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);instant.setPivotYear(iPivotYear);  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);instant.setPivotYear(iPivotYear);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);instant.setPivotYear(iPivotYear);	  	non-compiled	[CE]  cannot  find  symbol	15	None	add
550	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iLocale  =  locale;  [CE]  cannot  assign  a  value  to  final  variable  iLocale  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iLocale  =  locale;  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);  iLocale  =  locale;	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iLocale	15	None	add
551	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iLocale  =  locale.getDefaultYear();  [CE]  cannot  assign  a  value  to  final  variable  iLocale  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  iLocale  =  locale.getDefaultYear();  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);  iLocale  =  locale.getDefaultYear();	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iLocale	15	None	add
552	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);instant.setPivotYear(pivotYear);  [CE]  cannot  find  symbol  pivotYear  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);instant.setPivotYear(pivotYear);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);instant.setPivotYear(pivotYear);	  	non-compiled	[CE]  cannot  find  symbol  pivotYear	15	None	add
553	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setPivotYear(iParser);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setChronology(chrono);  instant.setPivotYear(iParser);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setChronology(chrono);    instant.setPivotYear(iParser);	  	non-compiled	[CE]  cannot  find  symbol	15	None	add
554	[BUG]  [BUGGY]  return  position  -  chrono.getLocalMillis();  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position  -  chrono.getLocalMillis();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  position  -  chrono.getLocalMillis();	  return    position;    timeout    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
555	[BUG]  [BUGGY]  return  position  -  chrono.getStartMillis();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position  -  chrono.getStartMillis();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  position  -  chrono.getStartMillis();	  return    position;    timeout    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
556	[BUG]  [BUGGY]  return  position  +  chrono.getLocalMillis();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position  +  chrono.getLocalMillis();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  position  +  chrono.getLocalMillis();	  return    position;    timeout    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
557	[BUG]  [BUGGY]  return  position  -  chrono.parseInto(instant,  text,  position);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position  -  chrono.parseInto(instant,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  position  -  chrono.parseInto(instant,  text,  position);	  return    position;    timeout    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
558	[BUG]  [BUGGY]  return(iDefaultYear  <  =  iDefaultYear)?  this.iPivotYear  :  chrono;  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(iDefaultYear  <  =  iDefaultYear)?  this.iPivotYear  :  chrono;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(iDefaultYear  <  =  iDefaultYear)?  this.iPivotYear  :  chrono;	  return    this.iPivotYear;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	36	None	replace
559	[BUG]  [BUGGY]  return(iDefaultYear  <  0)?  this.iPivotYear  :  chrono;  [CE]  incompatible  types  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(iDefaultYear  <  0)?  this.iPivotYear  :  chrono;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(iDefaultYear  <  0)?  this.iPivotYear  :  chrono;	  return    this.iPivotYear;    [timeout]    	non-compiled	[CE]  incompatible  types	36	None	replace
560	[BUG]  [BUGGY]  return(iDefaultYear  <  =  0)?  this.iPivotYear  :  chrono;  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(iDefaultYear  <  =  0)?  this.iPivotYear  :  chrono;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(iDefaultYear  <  =  0)?  this.iPivotYear  :  chrono;	  return    this.iPivotYear;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	36	None	replace
561	[BUG]  [BUGGY]  return(iDefaultYear  >=  chrono?  this.iPivotYear  :  iDefaultYear);  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(iDefaultYear  >=  chrono?  this.iPivotYear  :  iDefaultYear);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(iDefaultYear  >=  chrono?  this.iPivotYear  :  iDefaultYear);	  return    this.iPivotYear;    [timeout]    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	36	None	replace
562	[BUG]  [BUGGY]  return(iDefaultYear  >=  chrono)?  this.iPivotYear  :  chrono;  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(iDefaultYear  >=  chrono)?  this.iPivotYear  :  chrono;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(iDefaultYear  >=  chrono)?  this.iPivotYear  :  chrono;	  return    this.iPivotYear;    [timeout]    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	36	None	replace
563	[BUG]  [BUGGY]  return(iDefaultYear  <  =  iDefaultYear)?  this.iPivotYear  :  null;  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(iDefaultYear  <  =  iDefaultYear)?  this.iPivotYear  :  null;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(iDefaultYear  <  =  iDefaultYear)?  this.iPivotYear  :  null;	  return    this.iPivotYear;    [timeout]    	non-compiled	[CE]  illegal  start  of  expression	36	None	replace
564	[BUG]  [BUGGY]  return  this.iChrono.insertInt(instant,  parsedOffset,  chrono.iLocale);  [CE]  cannot  find  symbol  parsedOffset  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iChrono.insertInt(instant,  parsedOffset,  chrono.iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iChrono.insertInt(instant,  parsedOffset,  chrono.iLocale);	  return    this.iChrono;    	non-compiled	[CE]  cannot  find  symbol  parsedOffset	9	None	replace
565	[BUG]  [BUGGY]  return  this.iChrono.insertInt(instant,  chrono.getLocale());  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iChrono.insertInt(instant,  chrono.getLocale());  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iChrono.insertInt(instant,  chrono.getLocale());	  return    this.iChrono;    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
566	[BUG]  [BUGGY]  return  this.iChrono.insertInt(instant,  parsedOffset,  chrono.getLocale());  [CE]  cannot  find  symbol  parsedOffset  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iChrono.insertInt(instant,  parsedOffset,  chrono.getLocale());  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iChrono.insertInt(instant,  parsedOffset,  chrono.getLocale());	  return    this.iChrono;    	non-compiled	[CE]  cannot  find  symbol  parsedOffset	9	None	replace
567	[BUG]  [BUGGY]  return  this.iChrono.insertInt(instant,  chrono.iLocale);  [CE]  cannot  find  symbol  iLocale  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iChrono.insertInt(instant,  chrono.iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iChrono.insertInt(instant,  chrono.iLocale);	  return    this.iChrono;    	non-compiled	[CE]  cannot  find  symbol  iLocale	9	None	replace
568	[BUG]  [BUGGY]  return  this.iDefaultYear;  instant.setChronology(chrono);  return  this.iDefaultYear;  [CE]  unreachable  statement  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  instant.setChronology(chrono);  return  this.iDefaultYear;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    instant.setChronology(chrono);  return  this.iDefaultYear;	  timeout    	non-compiled	[CE]  unreachable  statement	10	None	add
569	[BUG]  [BUGGY]  return  this.iDefaultYear;  int  newPos  =  iPivotYear.getOffsetInteger();  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  int  newPos  =  iPivotYear.getOffsetInteger();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    int  newPos  =  iPivotYear.getOffsetInteger();	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	10	None	add
570	[BUG]  [BUGGY]  return  this.iDefaultYear;  long  newPos  =  getOffset(parsedOffset,  iLocale);  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  long  newPos  =  getOffset(parsedOffset,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    long  newPos  =  getOffset(parsedOffset,  iLocale);	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	10	None	add
571	[BUG]  [BUGGY]  return  this.iDefaultYear;  long  newPos  =  instant.getOffsetInteger();  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  long  newPos  =  instant.getOffsetInteger();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    long  newPos  =  instant.getOffsetInteger();	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	10	None	add
572	[BUG]  [BUGGY]  return  this.iDefaultYear;  int  newPos  =  getOffsetInteger();  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  int  newPos  =  getOffsetInteger();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    int  newPos  =  getOffsetInteger();	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	10	None	add
573	[BUG]  [BUGGY]  return  this.iDefaultYear;  int  newPos  =  text.lastIndexOf('.');  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iDefaultYear;  int  newPos  =  text.lastIndexOf('.');  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return    this.iDefaultYear;    int  newPos  =  text.lastIndexOf('.');	  timeout    	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	10	None	add
574	[BUG]  [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text,  iLocale));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text,  iLocale));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(chrono.computeMillis(false,  text,  iLocale));	      instant.setMillis(chrono.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	42	None	replace
575	[BUG]  [BUGGY]  return  chrono.insertInt(position,  iChrono);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  chrono.insertInt(position,  iChrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  chrono.insertInt(position,  iChrono);	  return    chrono;    	non-compiled	[CE]  cannot  find  symbol	46	None	replace
576	[BUG]  [BUGGY]  return  chrono.insertInt(position,  iLocale);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  chrono.insertInt(position,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  chrono.insertInt(position,  iLocale);	  return    chrono;    	non-compiled	[CE]  cannot  find  symbol	46	None	replace
577	[BUG]  [BUGGY]  return  chrono.getInstantValue(position,  iChrono);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  chrono.getInstantValue(position,  iChrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  chrono.getInstantValue(position,  iChrono);	  return    chrono;    	non-compiled	[CE]  cannot  find  symbol	46	None	replace
578	[BUG]  [BUGGY]  return  chrono.getInstance(instant,  iLocale);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  chrono.getInstance(instant,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  chrono.getInstance(instant,  iLocale);	  return    chrono;    	non-compiled	[CE]  cannot  find  symbol	46	None	replace
579	[BUG]  [BUGGY]  return  chrono.getChronology();  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  chrono.getChronology();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  chrono.getChronology();	  return    chrono;    	non-compiled	[CE]  cannot  find  symbol	46	None	replace
580	[BUG]  [BUGGY]  if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	38	None	replace
581	[BUG]  [BUGGY]  return  this.iOffset  +  parsedOffset;  [CE]  cannot  find  symbol  iOffset  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iOffset  +  parsedOffset;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iOffset  +  parsedOffset;	  return    newPos    +    parsedOffset;    	non-compiled	[CE]  cannot  find  symbol  iOffset	8	None	replace
582	[BUG]  [BUGGY]  return  offset  +  parsedOffset;  [CE]  cannot  find  symbol  offset  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  offset  +  parsedOffset;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  offset  +  parsedOffset;	  return    newPos    +    parsedOffset;    	non-compiled	[CE]  cannot  find  symbol  offset	8	None	replace
583	[BUG]  [BUGGY]  return  position  +  bysedOffset;  [CE]  cannot  find  symbol  bysedOffset  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  position  +  bysedOffset;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  position  +  bysedOffset;	  return    newPos    +    parsedOffset;    	non-compiled	[CE]  cannot  find  symbol  bysedOffset	8	None	replace
584	[BUG]  [BUGGY]  iChrono  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
585	[BUG]  [BUGGY]  Instant  instant  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  Instant  instant  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	Instant  instant  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
586	[BUG]  [BUGGY]  iChrono  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]                              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
587	[BUG]  [BUGGY]  return  iPivotYear;  instant.setChronology(chrono);  [CE]  unreachable  statement  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear;  instant.setChronology(chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear;  instant.setChronology(chrono);	  return    iPivot;    [timeout]    	non-compiled	[CE]  unreachable  statement	37	None	replace
588	[BUG]  [BUGGY]  return  iPivot.insertInt(-1,  chrono.insertInt(position));  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivot.insertInt(-1,  chrono.insertInt(position));  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivot.insertInt(-1,  chrono.insertInt(position));	  return    iPivot;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
589	[BUG]  [BUGGY]  return  iPivot.insertInt(0,  chrono.insertInt(position));  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivot.insertInt(0,  chrono.insertInt(position));  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivot.insertInt(0,  chrono.insertInt(position));	  return    iPivot;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
590	[BUG]  [BUGGY]  return  iPivot.insertInt(-1,  chrono.insertInt(position  +  1));  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivot.insertInt(-1,  chrono.insertInt(position  +  1));  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivot.insertInt(-1,  chrono.insertInt(position  +  1));	  return    iPivot;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
591	[BUG]  [BUGGY]  iChrono  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    null));    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
592	[BUG]  [BUGGY]  iChrono  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [CE]  illegal  start  of  type  [FE]                          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  iChrono  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	iChrono  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    null));    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
593	[BUG]  [BUGGY]  Instant  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [CE]  illegal  start  of  type  [FE]                            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  Instant  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	Instant  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  null));	      iChrono    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    null));    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
594	[BUG]  [BUGGY]  instant.setPos(bucket.computePosition(position,  text));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setPos(bucket.computePosition(position,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setPos(bucket.computePosition(position,  text));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
595	[BUG]  [BUGGY]  instant.setPos(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setPos(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setPos(bucket.computeMillis(true,  text));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
596	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  position));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text,  position));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(bucket.computeMillis(false,  text,  position));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	14	None	replace
597	[BUG]  [BUGGY]  return  this.iOffset;  [CE]  cannot  find  symbol  iOffset  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  this.iOffset;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  this.iOffset;	  return    parsedOffset;    	non-compiled	[CE]  cannot  find  symbol  iOffset	6	None	replace
598	[BUG]  [BUGGY]  instant.setMillis(parser.computeMillis(false,  text));  iPivotYear  =  iParser.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(parser.computeMillis(false,  text));  iPivotYear  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(parser.computeMillis(false,  text));  iPivotYear  =  iParser.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    iPivotYear    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	22	None	replace
599	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(matcher.computeMillis(false,  text));  [CE]  cannot  find  symbol  matcher  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(matcher.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(matcher.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  matcher	13	None	add
600	[BUG]  [BUGGY]  return  chrono.withLocale(iLocale);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  chrono.withLocale(iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  chrono.withLocale(iLocale);	  return    iLocale;    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
601	[BUG]  [BUGGY]  return  iLocale.get(chrono);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iLocale.get(chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iLocale.get(chrono);	  return    iLocale;    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
602	[BUG]  [BUGGY]  return  iLocale.toString();  [CE]  incompatible  types  [FE]                      AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iLocale.toString();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iLocale.toString();	  return    iLocale;    	non-compiled	[CE]  incompatible  types	7	None	replace
603	[BUG]  [BUGGY]  return  iLocale.getIntValue(chrono);  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iLocale.getIntValue(chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iLocale.getIntValue(chrono);	  return    iLocale;    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
604	[BUG]  [BUGGY]  return  iLocale.getInstanceUTC();  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iLocale.getInstanceUTC();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iLocale.getInstanceUTC();	  return    iLocale;    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
605	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  newPos,  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  ')'  expected  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  newPos,  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  newPos,  instant.setMillis(bucket.computeMillis(false,  text));	      parser.parseInto(bucket,    text,    position,    newPos);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  ')'  expected	30	None	replace
606	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position,  newPos,  chrono);  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position,  newPos,  chrono);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position,  newPos,  chrono);	      parser.parseInto(bucket,    text,    position,    newPos);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	30	None	replace
607	[BUG]  [BUGGY]  if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,    text));    	non-compiled	[CE]  illegal  start  of  type	45	None	replace
608	[BUG]  [BUGGY]  int  iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  iLocale  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
609	[BUG]  [BUGGY]  int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  iLocale  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      int    iLocale    =    iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	27	None	replace
610	[BUG]  [BUGGY]  return  instant.iDefaultYear  -  1;  [CE]  cannot  find  symbol  iDefaultYear  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.iDefaultYear  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.iDefaultYear  -  1;	  return    newPos    -    1;    timeout    	non-compiled	[CE]  cannot  find  symbol  iDefaultYear	48	None	replace
611	[BUG]  [BUGGY]  return  chrono  -  1;  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  chrono  -  1;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  chrono  -  1;	  return    newPos    -    1;    timeout    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	48	None	replace
612	[BUG]  [BUGGY]  if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position    -    1);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	40	None	replace
613	[BUG]  [BUGGY]  parser.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser.parseInto(bucket,  text,  position);	      iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
614	[BUG]  [BUGGY]  instant  =  parser.parseInto(bucket,  text,  position);  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant  =  parser.parseInto(bucket,  text,  position);	      iChrono    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  illegal  start  of  type	17	None	replace
615	[BUG]  [BUGGY]  if(iChrono!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iChrono!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iChrono!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
616	[BUG]  [BUGGY]  if(iLocale!=  locale)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iLocale!=  locale)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iLocale!=  locale)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
617	[BUG]  [BUGGY]  if(iPivotYear!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iPivotYear!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iPivotYear!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
618	[BUG]  [BUGGY]  if(iChrono!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iChrono!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iChrono!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
619	[BUG]  [BUGGY]  if(iPivotYear!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iPivotYear!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iPivotYear!=  null)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
620	[BUG]  [BUGGY]  if(iLocale!=  locale)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iLocale!=  locale)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iLocale!=  locale)  {  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setChronology(chrono);  }	      iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	21	None	replace
621	[BUG]  [BUGGY]  parsedOffset  =  iChrono.getOffsetMillis(parsedOffset);  [CE]  cannot  find  symbol  parsedOffset  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  parsedOffset  =  iChrono.getOffsetMillis(parsedOffset);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	parsedOffset  =  iChrono.getOffsetMillis(parsedOffset);	      	non-compiled	[CE]  cannot  find  symbol  parsedOffset	12	None	replace
622	[BUG]  [BUGGY]  parsedOffset  =  iChrono.getOffset(parsedOffset);  [CE]  cannot  find  symbol  parsedOffset  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  parsedOffset  =  iChrono.getOffset(parsedOffset);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	parsedOffset  =  iChrono.getOffset(parsedOffset);	      	non-compiled	[CE]  cannot  find  symbol  parsedOffset	12	None	replace
623	[BUG]  [BUGGY]  instant.setLocale(locale);  [CE]  cannot  find  symbol  locale  [FE]                              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  instant.setLocale(locale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	instant.setLocale(locale);	      	non-compiled	[CE]  cannot  find  symbol  locale	12	None	replace
624	[BUG]  [BUGGY]  instant.setChronology(chrono);  iLocale  =  locale;  [CE]  cannot  assign  a  value  to  final  variable  iLocale  [FE]                                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  instant.setChronology(chrono);  iLocale  =  locale;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	instant.setChronology(chrono);  iLocale  =  locale;	      	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iLocale	12	None	replace
625	[BUG]  [BUGGY]  return(iDefaultYear  >=  chrono)?  this  :  new  ReadWritableInstant(instant,  text,  position,  iLocale);  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]                        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(iDefaultYear  >=  chrono)?  this  :  new  ReadWritableInstant(instant,  text,  position,  iLocale);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(iDefaultYear  >=  chrono)?  this  :  new  ReadWritableInstant(instant,  text,  position,  iLocale);	  return    this.iDefaultYear;    timeout    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	11	None	replace
626	[BUG]  [BUGGY]  return(this.iPivotYear  ==  chrono?  this.iPivotYear  :  iDefaultYear);  [CE]  incomparable  types:  Integer  and  Chronology  [FE]                          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(this.iPivotYear  ==  chrono?  this.iPivotYear  :  iDefaultYear);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(this.iPivotYear  ==  chrono?  this.iPivotYear  :  iDefaultYear);	  return    this.iDefaultYear;    timeout    	non-compiled	[CE]  incomparable  types:  Integer  and  Chronology	11	None	replace
627	[BUG]  [BUGGY]  return(this.iPivotYear  >=  iDefaultYear)?  this.iPivotYear  :  chrono;  [CE]  incompatible  types  [FE]                            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return(this.iPivotYear  >=  iDefaultYear)?  this.iPivotYear  :  chrono;  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return(this.iPivotYear  >=  iDefaultYear)?  this.iPivotYear  :  chrono;	  return    this.iDefaultYear;    timeout    	non-compiled	[CE]  incompatible  types	11	None	replace
628	[BUG]  [BUGGY]  instant.setMillis(parser.parseInto(bucket,  text,  position,  chrono));  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(parser.parseInto(bucket,  text,  position,  chrono));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(parser.parseInto(bucket,  text,  position,  chrono));	      instant.setChronology(chrono);    	non-compiled	[CE]  illegal  start  of  type	16	None	replace
629	[BUG]  [BUGGY]  instant.setMillis(parser.parseInto(bucket,  text,  position));  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(parser.parseInto(bucket,  text,  position));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(parser.parseInto(bucket,  text,  position));	      instant.setChronology(chrono);    	non-compiled	[CE]  illegal  start  of  type	16	None	replace
630	[BUG]  [BUGGY]  instant.setMillis(iChrono.computeMillis(true,  text));  [CE]  illegal  start  of  type  [FE]        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(iChrono.computeMillis(true,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(iChrono.computeMillis(true,  text));	      instant.setChronology(chrono);    	non-compiled	[CE]  illegal  start  of  type	16	None	replace
631	[BUG]  [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text),  position);  [CE]  illegal  start  of  type  [FE]          AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text),  position);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(iChrono.computeMillis(false,  text),  position);	      instant.setChronology(chrono);    	non-compiled	[CE]  illegal  start  of  type	16	None	replace
632	[BUG]  [BUGGY]  instant.setMillis(parser.parseInto(bucket,  text,  position),  chrono);  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(parser.parseInto(bucket,  text,  position),  chrono);  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(parser.parseInto(bucket,  text,  position),  chrono);	      instant.setChronology(chrono);    	non-compiled	[CE]  illegal  start  of  type	16	None	replace
633	[BUG]  [BUGGY]  return  iDefaultYear  -  chrono.setChronology(chrono);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear  -  chrono.setChronology(chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iDefaultYear  -  chrono.setChronology(chrono);	  return    iDefaultYear;    timeout    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
634	[BUG]  [BUGGY]  return  iDefaultYear  +  chrono.getChronology().intValue();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear  +  chrono.getChronology().intValue();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iDefaultYear  +  chrono.getChronology().intValue();	  return    iDefaultYear;    timeout    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
635	[BUG]  [BUGGY]  return  iDefaultYear  -  chrono.setChrono(chrono);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iDefaultYear  -  chrono.setChrono(chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iDefaultYear  -  chrono.setChrono(chrono);	  return    iDefaultYear;    timeout    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
636	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.parseInto(bucket,  text,  position,  iLocale);  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	20	None	add
637	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	add	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	20	7	add
638	[BUG]  [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]      iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	        iParser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	20	7	add
639	[BUG]  [BUGGY]  if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  }  [CE]  illegal  start  of  type  [FE]                    AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  }  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	if(iLocale!=  locale)  {  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iChrono));  }	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    iChrono));    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
640	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  iChrono));  [CE]  illegal  start  of  type  [FE]                      AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  iChrono));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(bucket.computeMillis(false,  iChrono));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    iChrono));    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
641	[BUG]  [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));  [CE]  illegal  start  of  type  [FE]                        AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  int  newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	int  newPos  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));	      int    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    iChrono));    	non-compiled	[CE]  illegal  start  of  type	44	None	replace
642	[BUG]  [BUGGY]  Instant  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]            AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  Instant  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	Instant  parser  =  iParser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
643	[BUG]  [BUGGY]  parser  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]              AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  parser  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	parser  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      DateTimeParser    parser    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	29	None	replace
644	[BUG]  [BUGGY]  return  iPivotYear  -  chrono.setChronology(chrono);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  -  chrono.setChronology(chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  -  chrono.setChronology(chrono);	  return    iPivotYear;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
645	[BUG]  [BUGGY]  return  iPivotYear  -  chrono.insertInt(position,  chrono.intValue());  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  -  chrono.insertInt(position,  chrono.intValue());  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  -  chrono.insertInt(position,  chrono.intValue());	  return    iPivotYear;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
646	[BUG]  [BUGGY]  return  iPivotYear  +  chrono.getChronology().intValue();  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  +  chrono.getChronology().intValue();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  +  chrono.getChronology().intValue();	  return    iPivotYear;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
647	[BUG]  [BUGGY]  return  iPivotYear  +  chrono.getChronology().set(instant,  chrono);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  iPivotYear  +  chrono.getChronology().set(instant,  chrono);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  iPivotYear  +  chrono.getChronology().set(instant,  chrono);	  return    iPivotYear;    [timeout]    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
648	[BUG]  [BUGGY]  return  instant.getInstantValue(iChrono,  text,  position);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.getInstantValue(iChrono,  text,  position);  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.getInstantValue(iChrono,  text,  position);	  return    instant;    	non-compiled	[CE]  cannot  find  symbol	1	None	replace
649	[BUG]  [BUGGY]  return  instant.getInstantLocalMillis();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }    [BUGGY]  return  instant.getInstantLocalMillis();  [BUGGY]    }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	723	723	7	replace	return  instant.getInstantLocalMillis();	  return    instant;    	non-compiled	[CE]  cannot  find  symbol	1	None	replace
650	[BUG]  [BUGGY]  instant.setMillis(computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(computeMillis(false,  text));	      instant.setMillis(instant.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
651	[BUG]  [BUGGY]  instant.setMillis(iPrinter.computeMillis(false,  text));  [CE]  illegal  start  of  type  [FE]                  AssertionFailedError    [CONTEXT]    int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);    [BUGGY]  instant.setMillis(iPrinter.computeMillis(false,  text));  [BUGGY]    if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	720	720	7	replace	instant.setMillis(iPrinter.computeMillis(false,  text));	      instant.setMillis(instant.computeMillis(false,    text));    	non-compiled	[CE]  illegal  start  of  type	19	None	replace
