bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.withChronology(chrono.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.withChronology(chrono.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.withChronology(chrono.getZone());	  chrono    =    chrono.withChronology(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	replace
2	[BUG]  [BUGGY]  chrono  =  bucket.withChronology(chrono.getZone());  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  bucket.withChronology(chrono.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  bucket.withChronology(chrono.getZone());	  chrono    =    chrono.withChronology(bucket.getZone());    	non-compiled	[CE]  cannot  find  symbol	26	None	replace
3	[BUG]  [BUGGY]  chrono  =  iChrono.withChronology(bucket.getZone());  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  iChrono.withChronology(bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  iChrono.withChronology(bucket.getZone());	  chrono    =    chrono.withChronology(bucket.getZone());    	non-compiled	[CE]  cannot  find  symbol	26	None	replace
4	[BUG]  [BUGGY]  Chronology  chrono  =  iChrono.withChronology(bucket.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  iChrono.withChronology(bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  iChrono.withChronology(bucket.getZone());	  chrono    =    chrono.withChronology(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	replace
5	[BUG]  [BUGGY]  chrono  =  graph.withChronology(bucket.getZone());  [CE]  cannot  find  symbol  graph  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  graph.withChronology(bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  graph.withChronology(bucket.getZone());	  chrono    =    chrono.withChronology(bucket.getZone());    	non-compiled	[CE]  cannot  find  symbol  graph	26	None	replace
6	[BUG]  [BUGGY]  Chronology  chrono  =  graph.withChronology(bucket.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  graph.withChronology(bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  graph.withChronology(bucket.getZone());	  chrono    =    chrono.withChronology(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	26	None	replace
7	[BUG]  [BUGGY]  chrono  =  bucket.withZone(chrono.getLocalMillis());  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  bucket.withZone(chrono.getLocalMillis());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  bucket.withZone(chrono.getLocalMillis());	  chrono    =    chrono.withZone(bucket.getLocalMillis());    	non-compiled	[CE]  cannot  find  symbol	43	None	replace
8	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.withZone(chrono.getLocalMillis());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.withZone(chrono.getLocalMillis());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.withZone(chrono.getLocalMillis());	  chrono    =    chrono.withZone(bucket.getLocalMillis());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	43	None	replace
9	[BUG]  [BUGGY]  chrono  =  iChrono.withZone(bucket.getLocalMillis());  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  iChrono.withZone(bucket.getLocalMillis());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  iChrono.withZone(bucket.getLocalMillis());	  chrono    =    chrono.withZone(bucket.getLocalMillis());    	non-compiled	[CE]  cannot  find  symbol	43	None	replace
10	[BUG]  [BUGGY]  Chronology  chrono  =  iChrono.withZone(bucket.getLocalMillis());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  iChrono.withZone(bucket.getLocalMillis());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  iChrono.withZone(bucket.getLocalMillis());	  chrono    =    chrono.withZone(bucket.getLocalMillis());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	43	None	replace
11	[BUG]  [BUGGY]  chrono  =  parsedZone.withZone(bucket.getLocalMillis());  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  parsedZone.withZone(bucket.getLocalMillis());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  parsedZone.withZone(bucket.getLocalMillis());	  chrono    =    chrono.withZone(bucket.getLocalMillis());    	non-compiled	[CE]  cannot  find  symbol	43	None	replace
12	[BUG]  [BUGGY]  chrono  =  graph.withZone(bucket.getLocalMillis());  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  graph.withZone(bucket.getLocalMillis());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  graph.withZone(bucket.getLocalMillis());	  chrono    =    chrono.withZone(bucket.getLocalMillis());    	non-compiled	[CE]  cannot  find  symbol	43	None	replace
13	[BUG]  [BUGGY]  Chronology  chrono  =  parsedZone.withZone(bucket.getLocalMillis());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  parsedZone.withZone(bucket.getLocalMillis());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  parsedZone.withZone(bucket.getLocalMillis());	  chrono    =    chrono.withZone(bucket.getLocalMillis());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	43	None	replace
14	[BUG]  [BUGGY]  Chronology  chrono  =  graph.withZone(bucket.getLocalMillis());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  graph.withZone(bucket.getLocalMillis());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  graph.withZone(bucket.getLocalMillis());	  chrono    =    chrono.withZone(bucket.getLocalMillis());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	43	None	replace
15	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.withChronology(chrono.getChronology());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.withChronology(chrono.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.withChronology(chrono.getChronology());	  chrono    =    chrono.withChronology(bucket.getChronology());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	21	None	replace
16	[BUG]  [BUGGY]  chrono  =  bucket.withChronology(chrono.getChronology());  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  bucket.withChronology(chrono.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  bucket.withChronology(chrono.getChronology());	  chrono    =    chrono.withChronology(bucket.getChronology());    	non-compiled	[CE]  cannot  find  symbol	21	None	replace
17	[BUG]  [BUGGY]  chrono  =  iChrono.withChronology(bucket.getChronology());  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  iChrono.withChronology(bucket.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  iChrono.withChronology(bucket.getChronology());	  chrono    =    chrono.withChronology(bucket.getChronology());    	non-compiled	[CE]  cannot  find  symbol	21	None	replace
18	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.getChronology().withChronology(chrono.getChronology());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.getChronology().withChronology(chrono.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.getChronology().withChronology(chrono.getChronology());	  chrono    =    chrono.withChronology(bucket.getChronology());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	21	None	replace
19	[BUG]  [BUGGY]  Chronology  chrono  =  iChrono.withChronology(bucket.getChronology());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  iChrono.withChronology(bucket.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  iChrono.withChronology(bucket.getChronology());	  chrono    =    chrono.withChronology(bucket.getChronology());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	21	None	replace
20	[BUG]  [BUGGY]  chrono  =  graph.withChronology(bucket.getChronology());  [CE]  cannot  find  symbol  graph  [FE]                              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  graph.withChronology(bucket.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  graph.withChronology(bucket.getChronology());	  chrono    =    chrono.withChronology(bucket.getChronology());    	non-compiled	[CE]  cannot  find  symbol  graph	21	None	replace
21	[BUG]  [BUGGY]  Chronology  chrono  =  graph.withChronology(bucket.getChronology());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  graph.withChronology(bucket.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  graph.withChronology(bucket.getChronology());	  chrono    =    chrono.withChronology(bucket.getChronology());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	21	None	replace
22	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	newPos  =  parser.parseInto(bucket,  text,  position);	      newPos    =    iChrono.parseInto(bucket,    text,    position);    	compilable	  [FE]  AssertionFailedError  	32	8	replace
23	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parser.parseInto(bucket,  text,  position);	      newPos    =    iChrono.parseInto(bucket,    text,    position);    	compilable	  [FE]  AssertionFailedError  	32	8	replace
24	[BUG]  [BUGGY]  newPos  =  chrono.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  chrono.parseInto(bucket,  text,  position);	      newPos    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	32	None	replace
25	[BUG]  [BUGGY]  newPos  =  text.parseInto(bucket,  iChrono,  position);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  text.parseInto(bucket,  iChrono,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  text.parseInto(bucket,  iChrono,  position);	      newPos    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	32	None	replace
26	[BUG]  [BUGGY]  newPos  =  iChrono.parseInto(bucket,  text,  position,  parsedOffset);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  iChrono.parseInto(bucket,  text,  position,  parsedOffset);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  iChrono.parseInto(bucket,  text,  position,  parsedOffset);	      newPos    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	32	None	replace
27	[BUG]  [BUGGY]  newPos  =  iChrono.parseInto(bucket,  text,  position  +  1);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  iChrono.parseInto(bucket,  text,  position  +  1);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  iChrono.parseInto(bucket,  text,  position  +  1);	      newPos    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	32	None	replace
28	[BUG]  [BUGGY]  newPos  =  graph.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  graph  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  graph.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  graph.parseInto(bucket,  text,  position);	      newPos    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol  graph	32	None	replace
29	[BUG]  [BUGGY]  newPos  =  bucket.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  bucket.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  bucket.parseInto(bucket,  text,  position);	      newPos    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	32	None	replace
30	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  [CE]  unreachable  statement  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;	  	non-compiled	[CE]  unreachable  statement	12	None	add
31	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  instant.setMillis(bucket.computeMillis(true,  text));  return  newPos;  [CE]  unreachable  statement  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  instant.setMillis(bucket.computeMillis(true,  text));  return  newPos;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    instant.setMillis(bucket.computeMillis(true,  text));  return  newPos;	  	non-compiled	[CE]  unreachable  statement	12	None	add
32	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  Instant  instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  Instant  instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    Instant  instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;	  	non-compiled	[CE]  ';'  expected	12	None	add
33	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  moment.setMillis(bucket.computeMillis(false,  text));  return  newPos;  [CE]  cannot  find  symbol  moment  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  moment.setMillis(bucket.computeMillis(false,  text));  return  newPos;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    moment.setMillis(bucket.computeMillis(false,  text));  return  newPos;	  	non-compiled	[CE]  cannot  find  symbol  moment	12	None	add
34	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  minute.setMillis(bucket.computeMillis(false,  text));  return  newPos;  [CE]  cannot  find  symbol  minute  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  minute.setMillis(bucket.computeMillis(false,  text));  return  newPos;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    minute.setMillis(bucket.computeMillis(false,  text));  return  newPos;	  	non-compiled	[CE]  cannot  find  symbol  minute	12	None	add
35	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  instant.setMillis(bucket.computeMillis(False,  text));  return  newPos;  [CE]  cannot  find  symbol  False  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  instant.setMillis(bucket.computeMillis(False,  text));  return  newPos;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    instant.setMillis(bucket.computeMillis(False,  text));  return  newPos;	  	non-compiled	[CE]  cannot  find  symbol  False	12	None	add
36	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  unreachable  statement  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  unreachable  statement	12	None	add
37	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.withZone(parsedZone.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.withZone(parsedZone.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.withZone(parsedZone.getZone());	  Chronology    chrono    =    bucket.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	replace
38	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.withZone(parsedZone);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.withZone(parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.withZone(parsedZone);	  Chronology    chrono    =    bucket.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	replace
39	[BUG]  [BUGGY]  Chronology  chrono  =  parsedZone.withZone(bucket.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  parsedZone.withZone(bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  parsedZone.withZone(bucket.getZone());	  Chronology    chrono    =    bucket.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	replace
40	[BUG]  [BUGGY]  Chronology  chrono  =  instant.withZone(bucket.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  instant.withZone(bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  instant.withZone(bucket.getZone());	  Chronology    chrono    =    bucket.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	replace
41	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.withChronology(iChrono,  parsedZone.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.withChronology(iChrono,  parsedZone.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.withChronology(iChrono,  parsedZone.getZone());	  Chronology    chrono    =    bucket.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	replace
42	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.withZone(parsedZone,  bucket.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.withZone(parsedZone,  bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.withZone(parsedZone,  bucket.getZone());	  Chronology    chrono    =    bucket.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	replace
43	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.withChronology(parsedZone.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.withChronology(parsedZone.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.withChronology(parsedZone.getZone());	  Chronology    chrono    =    bucket.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	replace
44	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.withChronology(parsedZone,  bucket.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.withChronology(parsedZone,  bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.withChronology(parsedZone,  bucket.getZone());	  Chronology    chrono    =    bucket.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	replace
45	[BUG]  [BUGGY]  bucket.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  bucket.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	bucket.setMillis(bucket.computeMillis(false,  text));	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setZone(parsedZone);    }    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
46	[BUG]  [BUGGY]  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setZone(parsedZone);    }    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
47	[BUG]  [BUGGY]  moment  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  moment  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  moment  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	moment  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setZone(parsedZone);    }    	non-compiled	[CE]  cannot  find  symbol  moment	37	None	replace
48	[BUG]  [BUGGY]  Chronology  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  Chronology  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	Chronology  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setZone(parsedZone);    }    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	37	None	replace
49	[BUG]  [BUGGY]  instant  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  [CE]  incompatible  types  [FE]                            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setZone(parsedZone);    }    	non-compiled	[CE]  incompatible  types	37	None	replace
50	[BUG]  [BUGGY]  bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setZone(parsedZone);    }    	non-compiled	[CE]  <identifier>  expected	37	None	replace
51	[BUG]  [BUGGY]  chrono  =  chrono.withZone(iChrono.getChronology());  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(iChrono.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(iChrono.getChronology());	  chrono    =    chrono.withZone(parsedZone.getChronology());    	non-compiled	[CE]  cannot  find  symbol	20	None	replace
52	[BUG]  [BUGGY]  Chronology  chrono  =  chrono.withZone(bucket.getChronology());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  chrono.withZone(bucket.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  chrono.withZone(bucket.getChronology());	  chrono    =    chrono.withZone(parsedZone.getChronology());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
53	[BUG]  [BUGGY]  Chronology  chrono  =  parsedZone.withZone(chrono.getChronology());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  parsedZone.withZone(chrono.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  parsedZone.withZone(chrono.getChronology());	  chrono    =    chrono.withZone(parsedZone.getChronology());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
54	[BUG]  [BUGGY]  chrono  =  chrono.withZone(chrono.getChronology());  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(chrono.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(chrono.getChronology());	  chrono    =    chrono.withZone(parsedZone.getChronology());    	non-compiled	[CE]  cannot  find  symbol	20	None	replace
55	[BUG]  [BUGGY]  Chronology  chrono  =  chrono.withZone(parsedZone.getChronology());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  chrono.withZone(parsedZone.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  chrono.withZone(parsedZone.getChronology());	  chrono    =    chrono.withZone(parsedZone.getChronology());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	20	None	replace
56	[BUG]  [BUGGY]  chrono  =  chrono.withZone(jChrono.getChronology());  [CE]  cannot  find  symbol  jChrono  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(jChrono.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(jChrono.getChronology());	  chrono    =    chrono.withZone(parsedZone.getChronology());    	non-compiled	[CE]  cannot  find  symbol  jChrono	20	None	replace
57	[BUG]  [BUGGY]  chrono  =  chrono.withZone(str.getChronology());  [CE]  cannot  find  symbol  str  [FE]                              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(str.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(str.getChronology());	  chrono    =    chrono.withZone(parsedZone.getChronology());    	non-compiled	[CE]  cannot  find  symbol  str	20	None	replace
58	[BUG]  [BUGGY]  instant.setMillis(selectChronology(chrono));  [CE]  no  suitable  method  found  for  setMillis(Chronology)  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(selectChronology(chrono));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(selectChronology(chrono));	      instant.setChronology(chrono);    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(Chronology)	4	None	replace
59	[BUG]  [BUGGY]  instant.setTime(parsedOffset);  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setTime(parsedOffset);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setTime(parsedOffset);	      instant.setChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
60	[BUG]  [BUGGY]  instant.setZone(chrono);  [CE]  method  setZone  in  interface  ReadWritableInstant  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setZone(chrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setZone(chrono);	      instant.setChronology(chrono);    	non-compiled	[CE]  method  setZone  in  interface  ReadWritableInstant  cannot  be  applied  to  given  types;	4	None	replace
61	[BUG]  [BUGGY]  instant.setMillis(selectChronology(chrono),  parsedOffset);  [CE]  no  suitable  method  found  for  setMillis(Chronology,int)  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(selectChronology(chrono),  parsedOffset);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(selectChronology(chrono),  parsedOffset);	      instant.setChronology(chrono);    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(Chronology,int)	4	None	replace
62	[BUG]  [BUGGY]  instant.setMillis(selectChronology(instantLocal,  parsedOffset,  chrono));  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(selectChronology(instantLocal,  parsedOffset,  chrono));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(selectChronology(instantLocal,  parsedOffset,  chrono));	      instant.setChronology(chrono);    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	4	None	replace
63	[BUG]  [BUGGY]  instant.setMillis(selectChronology(chrono),  parsedOffset,  parsedOffset);  [CE]  no  suitable  method  found  for  setMillis(Chronology,int,int)  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(selectChronology(chrono),  parsedOffset,  parsedOffset);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(selectChronology(chrono),  parsedOffset,  parsedOffset);	      instant.setChronology(chrono);    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(Chronology,int,int)	4	None	replace
64	[BUG]  [BUGGY]  instant.setMillis(selectChronology(iChrono,  parsedOffset));  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(selectChronology(iChrono,  parsedOffset));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(selectChronology(iChrono,  parsedOffset));	      instant.setChronology(chrono);    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	4	None	replace
65	[BUG]  [BUGGY]  chrono  =  chrono.withZone(iChrono,  bucket.getZone());  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(iChrono,  bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(iChrono,  bucket.getZone());	  chrono    =    chrono.withZone(parsedZone,    bucket.getZone());    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	44	None	replace
66	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket,  parsedZone.getZone());  [CE]  cannot  find  symbol  parsedZone  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket,  parsedZone.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket,  parsedZone.getZone());	  chrono    =    chrono.withZone(parsedZone,    bucket.getZone());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	44	None	replace
67	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.withZone(parsedZone,  chrono.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.withZone(parsedZone,  chrono.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.withZone(parsedZone,  chrono.getZone());	  chrono    =    chrono.withZone(parsedZone,    bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	44	None	replace
68	[BUG]  [BUGGY]  chrono  =  parsedZone.withZone(chrono,  bucket.getZone());  [CE]  cannot  find  symbol  parsedZone  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  parsedZone.withZone(chrono,  bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  parsedZone.withZone(chrono,  bucket.getZone());	  chrono    =    chrono.withZone(parsedZone,    bucket.getZone());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	44	None	replace
69	[BUG]  [BUGGY]  chrono  =  iChrono.withZone(parsedZone,  bucket.getZone());  [CE]  cannot  find  symbol  parsedZone  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  iChrono.withZone(parsedZone,  bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  iChrono.withZone(parsedZone,  bucket.getZone());	  chrono    =    chrono.withZone(parsedZone,    bucket.getZone());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	44	None	replace
70	[BUG]  [BUGGY]  chrono  =  chrono.withZone(iLocale,  bucket.getZone());  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(iLocale,  bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(iLocale,  bucket.getZone());	  chrono    =    chrono.withZone(parsedZone,    bucket.getZone());    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	44	None	replace
71	[BUG]  [BUGGY]  chrono  =  bucket.withZone(parsedZone,  chrono.getZone());  [CE]  cannot  find  symbol  parsedZone  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  bucket.withZone(parsedZone,  chrono.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  bucket.withZone(parsedZone,  chrono.getZone());	  chrono    =    chrono.withZone(parsedZone,    bucket.getZone());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	44	None	replace
72	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  iChrono  =  chrono;  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  iChrono  =  chrono;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text));  iChrono  =  chrono;	      instant.setMillis(bucket.computeMillis(false,    text));    iChrono    =    parsedZone;    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	10	None	replace
73	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  parsedOffset));  iChrono  =  parsedZone;  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  parsedOffset));  iChrono  =  parsedZone;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  parsedOffset));  iChrono  =  parsedZone;	      instant.setMillis(bucket.computeMillis(false,    text));    iChrono    =    parsedZone;    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	10	None	replace
74	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  iChrono  =  parsedZone;  [CE]  ')'  expected  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  iChrono  =  parsedZone;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  iChrono  =  parsedZone;	      instant.setMillis(bucket.computeMillis(false,    text));    iChrono    =    parsedZone;    	non-compiled	[CE]  ')'  expected	10	None	replace
75	[BUG]  [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text,  iLocale));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text,  iLocale));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(iChrono.computeMillis(false,  text,  iLocale));	      instant.setMillis(iChrono.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	45	None	replace
76	[BUG]  [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text,  iOffsetParsed));  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text,  iOffsetParsed));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(iChrono.computeMillis(false,  text,  iOffsetParsed));	      instant.setMillis(iChrono.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	45	None	replace
77	[BUG]  [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text),  iLocale);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text),  iLocale);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(iChrono.computeMillis(false,  text),  iLocale);	      instant.setMillis(iChrono.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	45	None	replace
78	[BUG]  [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text),  chrono);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text),  chrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(iChrono.computeMillis(false,  text),  chrono);	      instant.setMillis(iChrono.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	45	None	replace
79	[BUG]  [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text,  chrono));  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text,  chrono));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(iChrono.computeMillis(false,  text,  chrono));	      instant.setMillis(iChrono.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	45	None	replace
80	[BUG]  [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text,  parsedOffset));  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text,  parsedOffset));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(iChrono.computeMillis(false,  text,  parsedOffset));	      instant.setMillis(iChrono.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	45	None	replace
81	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  bucket.getOffset();  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	parsedOffset  =  bucket.getOffset();	      parsedOffset    =    parsedZone.getOffset();    	compilable	  [FE]  AssertionFailedError  	7	8	replace
82	[BUG]  [BUGGY]  parsedOffset  =  bucket.getOffset();  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  bucket.getOffset();  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	parsedOffset  =  bucket.getOffset();	      parsedOffset    =    parsedZone.getOffset();    	compilable	  [FE]  AssertionFailedError  	7	8	replace
83	[BUG]  [BUGGY]  parsedOffset  =  parsedZone.getOffset()  -  1;  [CE]  no  suitable  method  found  for  getOffset()  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  parsedZone.getOffset()  -  1;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	parsedOffset  =  parsedZone.getOffset()  -  1;	      parsedOffset    =    parsedZone.getOffset();    	non-compiled	[CE]  no  suitable  method  found  for  getOffset()	7	None	replace
84	[BUG]  [BUGGY]  parsedOffset  =  iChrono.getOffset();  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  iChrono.getOffset();  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	parsedOffset  =  iChrono.getOffset();	      parsedOffset    =    parsedZone.getOffset();    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
85	[BUG]  [BUGGY]  parsedOffset  =  iZone.getOffset();  [CE]  no  suitable  method  found  for  getOffset()  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  iZone.getOffset();  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	parsedOffset  =  iZone.getOffset();	      parsedOffset    =    parsedZone.getOffset();    	non-compiled	[CE]  no  suitable  method  found  for  getOffset()	7	None	replace
86	[BUG]  [BUGGY]  parsedOffset  =  parsedZone.getOffset(),  newPos;  [CE]  ';'  expected  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  parsedZone.getOffset(),  newPos;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	parsedOffset  =  parsedZone.getOffset(),  newPos;	      parsedOffset    =    parsedZone.getOffset();    	non-compiled	[CE]  ';'  expected	7	None	replace
87	[BUG]  [BUGGY]  parsedOffset  =  parsedZone.getOffset()  +  1;  [CE]  no  suitable  method  found  for  getOffset()  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  parsedZone.getOffset()  +  1;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	parsedOffset  =  parsedZone.getOffset()  +  1;	      parsedOffset    =    parsedZone.getOffset();    	non-compiled	[CE]  no  suitable  method  found  for  getOffset()	7	None	replace
88	[BUG]  [BUGGY]  parsedOffset  =  iParsedZone.getOffset();  [CE]  cannot  find  symbol  iParsedZone  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  iParsedZone.getOffset();  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	parsedOffset  =  iParsedZone.getOffset();	      parsedOffset    =    parsedZone.getOffset();    	non-compiled	[CE]  cannot  find  symbol  iParsedZone	7	None	replace
89	[BUG]  [BUGGY]  ParsedOffset  parsedOffset  =  bucket.getOffset();  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  ParsedOffset  parsedOffset  =  bucket.getOffset();  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	ParsedOffset  parsedOffset  =  bucket.getOffset();	      parsedOffset    =    parsedZone.getOffset();    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
90	[BUG]  [BUGGY]  parsedOffset  =  parsedZone.getOffsetInteger();  [CE]  cannot  find  symbol  [FE]                              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  parsedZone.getOffsetInteger();  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	parsedOffset  =  parsedZone.getOffsetInteger();	      parsedOffset    =    parsedZone.getOffset();    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
91	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  parsedOffset);  [CE]  cannot  find  symbol  parsedOffset  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  parsedOffset);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getZone(),  parsedOffset);	  chrono    =    chrono.withZone(bucket.getZone(),    parsedZone);    	non-compiled	[CE]  cannot  find  symbol  parsedOffset	42	None	replace
92	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  position);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  position);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getZone(),  position);	  chrono    =    chrono.withZone(bucket.getZone(),    parsedZone);    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	42	None	replace
93	[BUG]  [BUGGY]  Chronology  chrono  =  chrono.withZone(bucket.getZone(),  parsedZone);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  chrono.withZone(bucket.getZone(),  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  chrono.withZone(bucket.getZone(),  parsedZone);	  chrono    =    chrono.withZone(bucket.getZone(),    parsedZone);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	42	None	replace
94	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  offset);  [CE]  cannot  find  symbol  offset  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  offset);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getZone(),  offset);	  chrono    =    chrono.withZone(bucket.getZone(),    parsedZone);    	non-compiled	[CE]  cannot  find  symbol  offset	42	None	replace
95	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  point);  [CE]  cannot  find  symbol  point  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  point);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getZone(),  point);	  chrono    =    chrono.withZone(bucket.getZone(),    parsedZone);    	non-compiled	[CE]  cannot  find  symbol  point	42	None	replace
96	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  newPos);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  newPos);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getZone(),  newPos);	  chrono    =    chrono.withZone(bucket.getZone(),    parsedZone);    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	42	None	replace
97	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  timeZone);  [CE]  cannot  find  symbol  timeZone  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  timeZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getZone(),  timeZone);	  chrono    =    chrono.withZone(bucket.getZone(),    parsedZone);    	non-compiled	[CE]  cannot  find  symbol  timeZone	42	None	replace
98	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  parsedLocal);  [CE]  cannot  find  symbol  parsedLocal  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  parsedLocal);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getZone(),  parsedLocal);	  chrono    =    chrono.withZone(bucket.getZone(),    parsedZone);    	non-compiled	[CE]  cannot  find  symbol  parsedLocal	42	None	replace
99	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      newPos    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	compilable	  [FE]  AssertionFailedError  	33	8	replace
100	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      newPos    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	compilable	  [FE]  AssertionFailedError  	33	8	replace
101	[BUG]  [BUGGY]  if(iChrono!=  null)  {  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      newPos    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	33	None	replace
102	[BUG]  [BUGGY]  iChrono  =  bucket.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  iChrono  =  bucket.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	iChrono  =  bucket.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      newPos    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	33	None	replace
103	[BUG]  [BUGGY]  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      newPos    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	33	None	replace
104	[BUG]  [BUGGY]  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));	      newPos    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	33	None	replace
105	[BUG]  [BUGGY]  if(iChrono.parseInto(bucket,  text,  position))  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono.parseInto(bucket,  text,  position))  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono.parseInto(bucket,  text,  position))  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      newPos    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	33	None	replace
106	[BUG]  [BUGGY]  if(iChrono.parseInto(bucket,  text,  position))  {  newPos  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono.parseInto(bucket,  text,  position))  {  newPos  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono.parseInto(bucket,  text,  position))  {  newPos  =  parser.parseInto(bucket,  position,  text);  instant.setMillis(bucket.computeMillis(false,  text));  }	      newPos    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	33	None	replace
107	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedZone);  bucket.setMillis(bucket.computeMillis(false,  text));  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedZone);  bucket.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedZone);  bucket.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	31	None	replace
108	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedOffset);  bucket.setMillis(bucket.computeMillis(false,  text));  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedOffset);  bucket.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedOffset);  bucket.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	31	None	replace
109	[BUG]  [BUGGY]  priode  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  p  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  priode  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	priode  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol  p	31	None	replace
110	[BUG]  [BUGGY]  Chronology  chrono  =  parsedZone.withZone(iChrono.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  parsedZone.withZone(iChrono.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  parsedZone.withZone(iChrono.getZone());	  chrono    =    chrono.withZone(iChrono.getZone());    [timeout]    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
111	[BUG]  [BUGGY]  Chronology  chrono  =  iChrono.withZone(parsedZone);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  iChrono.withZone(parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  iChrono.withZone(parsedZone);	  chrono    =    chrono.withZone(iChrono.getZone());    [timeout]    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
112	[BUG]  [BUGGY]  Chronology  chrono  =  iChrono.withZone(chrono.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  iChrono.withZone(chrono.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  iChrono.withZone(chrono.getZone());	  chrono    =    chrono.withZone(iChrono.getZone());    [timeout]    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
113	[BUG]  [BUGGY]  Chronology  chrono  =  iChrono.getChronology(chrono);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  iChrono.getChronology(chrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  iChrono.getChronology(chrono);	  chrono    =    chrono.withZone(iChrono.getZone());    [timeout]    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
114	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	add	        instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	24	7	add
115	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	        instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	24	7	add
116	[BUG]  [BUGGY]      instant.setZone(chrono);  [CE]  method  setZone  in  interface  ReadWritableInstant  cannot  be  applied  to  given  types;  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]      instant.setZone(chrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	        instant.setZone(chrono);	  	non-compiled	[CE]  method  setZone  in  interface  ReadWritableInstant  cannot  be  applied  to  given  types;	24	None	add
117	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]      instant.setChronology(chrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	add	        instant.setChronology(chrono);	  	compilable	  [FE]  AssertionFailedError  	24	7	add
118	[BUG]  [BUGGY]      instant.setChronology(chrono);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]      instant.setChronology(chrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	        instant.setChronology(chrono);	  	compilable	  [FE]  AssertionFailedError  	24	7	add
119	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  iChrono  =  chrono.withZone(parsedZone);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  iChrono  =  chrono.withZone(parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	        instant.setMillis(bucket.computeMillis(false,  text));  iChrono  =  chrono.withZone(parsedZone);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	24	None	add
120	[BUG]  [BUGGY]      iChrono  =  chrono.withZone(parsedOffset);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]      iChrono  =  chrono.withZone(parsedOffset);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	        iChrono  =  chrono.withZone(parsedOffset);	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	24	None	add
121	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  iPivotYear  =  pivotYear;  [CE]  cannot  assign  a  value  to  final  variable  iPivotYear  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  iPivotYear  =  pivotYear;  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	        instant.setMillis(bucket.computeMillis(false,  text));  iPivotYear  =  pivotYear;	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iPivotYear	24	None	add
122	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  iLocale  =  locale;  [CE]  cannot  assign  a  value  to  final  variable  iLocale  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  iLocale  =  locale;  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	        instant.setMillis(bucket.computeMillis(false,  text));  iLocale  =  locale;	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iLocale	24	None	add
123	[BUG]  [BUGGY]      parsedOffset  =  bucket.getOffsetInteger();  [CE]  cannot  find  symbol  parsedOffset  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]      parsedOffset  =  bucket.getOffsetInteger();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	        parsedOffset  =  bucket.getOffsetInteger();	  	non-compiled	[CE]  cannot  find  symbol  parsedOffset	24	None	add
124	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  parsedOffset));  [CE]  cannot  find  symbol  parsedOffset  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  parsedOffset));  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	        instant.setMillis(bucket.computeMillis(false,  parsedOffset));	  	non-compiled	[CE]  cannot  find  symbol  parsedOffset	24	None	add
125	[BUG]  [BUGGY]      instant.setMillis(bucket.getZone().computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]      instant.setMillis(bucket.getZone().computeMillis(false,  text));  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	        instant.setMillis(bucket.getZone().computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	24	None	add
126	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position);  chrono.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position);  chrono.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parser.parseInto(bucket,  text,  position);  chrono.setMillis(bucket.computeMillis(false,  text));	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
127	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedOffset);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedOffset);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedOffset);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	35	None	replace
128	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    }    	compilable	  [FE]  AssertionFailedError  	35	8	replace
129	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [FE]  AssertionFailedError  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    }    	compilable	  [FE]  AssertionFailedError  	35	8	replace
130	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedZone);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedZone);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedZone);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	35	None	replace
131	[BUG]  [BUGGY]  instant  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  incompatible  types  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  incompatible  types	35	None	replace
132	[BUG]  [BUGGY]  instant  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  incompatible  types  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  incompatible  types	35	None	replace
133	[BUG]  [BUGGY]  chrono  =  chrono.withZone(iChrono);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(iChrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(iChrono);	  chrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	16	None	replace
134	[BUG]  [BUGGY]  Chronology  chrono  =  chrono.withZone(iChrono);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  chrono.withZone(iChrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  chrono.withZone(iChrono);	  chrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	16	None	replace
135	[BUG]  [BUGGY]  chrono  =  chrono.withZone(iLocale);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(iLocale);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(iLocale);	  chrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	16	None	replace
136	[BUG]  [BUGGY]  chrono  =  chrono.withZone(iPivotYear);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(iPivotYear);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(iPivotYear);	  chrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	16	None	replace
137	[BUG]  [BUGGY]  chrono  =  chrono.withZone(iOffsetParsed);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(iOffsetParsed);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(iOffsetParsed);	  chrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	16	None	replace
138	[BUG]  [BUGGY]  chrono  =  chrono.withZone(iChrono,  parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(iChrono,  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(iChrono,  parsedZone);	  chrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  cannot  find  symbol  parsedZone	16	None	replace
139	[BUG]  [BUGGY]  chrono  =  chrono.withZone(timeZone);  [CE]  cannot  find  symbol  timeZone  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(timeZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(timeZone);	  chrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  cannot  find  symbol  timeZone	16	None	replace
140	[BUG]  [BUGGY]  Chronology  chrono  =  chrono.withZone(parsedZone);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  chrono.withZone(parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  chrono.withZone(parsedZone);	  chrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	16	None	replace
141	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  parsedOffset);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  parsedOffset);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parser.parseInto(bucket,  text,  position,  parsedOffset);	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	8	None	replace
142	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  parsedZone);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  parsedZone);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parser.parseInto(bucket,  text,  position,  parsedZone);	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	8	None	replace
143	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  bucket.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	parsedOffset  =  bucket.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	compilable	  [FE]  AssertionFailedError  	8	8	replace
144	[BUG]  [BUGGY]  parsedOffset  =  bucket.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  bucket.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	parsedOffset  =  bucket.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	compilable	  [FE]  AssertionFailedError  	8	8	replace
145	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	8	None	replace
146	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parser.parseInto(bucket,  text,  position,  iDefaultYear);	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	8	None	replace
147	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	newPos  =  parser.parseInto(bucket,  text,  position  -  1);	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	compilable	  [FE]  AssertionFailedError  	8	8	replace
148	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  [FE]  AssertionFailedError  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parser.parseInto(bucket,  text,  position  -  1);	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	compilable	  [FE]  AssertionFailedError  	8	8	replace
149	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  iOffsetParsed);  [CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;  [FE]                            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  iOffsetParsed);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parser.parseInto(bucket,  text,  position,  iOffsetParsed);	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  method  parseInto  in  interface  DateTimeParser  cannot  be  applied  to  given  types;	8	None	replace
150	[BUG]  [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  parsedOffsetParsed);  [CE]  cannot  find  symbol  parsedOffsetParsed  [FE]                              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parser.parseInto(bucket,  text,  position,  parsedOffsetParsed);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parser.parseInto(bucket,  text,  position,  parsedOffsetParsed);	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol  parsedOffsetParsed	8	None	replace
151	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  chrono  =  chrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	add	chrono    =    chrono.withUTC();    chrono  =  chrono.withUTC();	  	compilable	  [FE]  AssertionFailedError  	40	7	add
152	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  chrono  =  chrono.withUTC();  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  chrono  =  chrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    chrono  =  chrono.withUTC();	  	compilable	  [FE]  AssertionFailedError  	40	7	add
153	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  Chronology  chrono  =  chrono.withUTC();  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  Chronology  chrono  =  chrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    Chronology  chrono  =  chrono.withUTC();	  	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	40	None	add
154	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  instant  =  chrono.withUTC();  [CE]  incompatible  types  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  instant  =  chrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    instant  =  chrono.withUTC();	  	non-compiled	[CE]  incompatible  types	40	None	add
155	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  Chrono  chrono  =  chrono.withUTC();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  Chrono  chrono  =  chrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    Chrono  chrono  =  chrono.withUTC();	  	non-compiled	[CE]  cannot  find  symbol	40	None	add
156	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  parsedOffset  =  parsedZone.getOffset();  chrono  =  chrono.withUTC();  [CE]  cannot  find  symbol  parsedOffset  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  parsedOffset  =  parsedZone.getOffset();  chrono  =  chrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    parsedOffset  =  parsedZone.getOffset();  chrono  =  chrono.withUTC();	  	non-compiled	[CE]  cannot  find  symbol  parsedOffset	40	None	add
157	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  parsedOffset  =  parsedZone.getOffset()  -  parsedOffset;  chrono  =  chrono.withUTC();  [CE]  cannot  find  symbol  parsedOffset  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  parsedOffset  =  parsedZone.getOffset()  -  parsedOffset;  chrono  =  chrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    parsedOffset  =  parsedZone.getOffset()  -  parsedOffset;  chrono  =  chrono.withUTC();	  	non-compiled	[CE]  cannot  find  symbol  parsedOffset	40	None	add
158	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  parsedOffset  =  parsedZone.getOffset(parsedOffset);  chrono  =  chrono.withUTC();  [CE]  cannot  find  symbol  parsedOffset  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  parsedOffset  =  parsedZone.getOffset(parsedOffset);  chrono  =  chrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    parsedOffset  =  parsedZone.getOffset(parsedOffset);  chrono  =  chrono.withUTC();	  	non-compiled	[CE]  cannot  find  symbol  parsedOffset	40	None	add
159	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  parsedOffset  =  parsedZone.getOffsetInteger();  chrono  =  chrono.withUTC();  [CE]  cannot  find  symbol  parsedOffset  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  parsedOffset  =  parsedZone.getOffsetInteger();  chrono  =  chrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    parsedOffset  =  parsedZone.getOffsetInteger();  chrono  =  chrono.withUTC();	  	non-compiled	[CE]  cannot  find  symbol  parsedOffset	40	None	add
160	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  iChrono  =  chrono.withUTC();  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  iChrono  =  chrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    iChrono  =  chrono.withUTC();	  	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	40	None	add
161	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  parsedOffset  =  parsedZone.getLocalMillis();  chrono  =  chrono.withUTC();  [CE]  cannot  find  symbol  parsedOffset  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  parsedOffset  =  parsedZone.getLocalMillis();  chrono  =  chrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    parsedOffset  =  parsedZone.getLocalMillis();  chrono  =  chrono.withUTC();	  	non-compiled	[CE]  cannot  find  symbol  parsedOffset	40	None	add
162	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  newPos  =  chrono.parseInto(bucket,  text,  position);  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  newPos  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  position);  newPos  =  chrono.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    chrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	9	None	replace
163	[BUG]  [BUGGY]  iLocale.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  iLocale.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	iLocale.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    chrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
164	[BUG]  [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(chrono.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    chrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
165	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	        instant.setChronology(chrono);    instant.setChronology(chrono);	  	compilable	  [FE]  AssertionFailedError  	3	7	add
166	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(chrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setChronology(chrono);	  	compilable	  [FE]  AssertionFailedError  	3	7	add
167	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	        instant.setChronology(chrono);    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	3	7	add
168	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	3	7	add
169	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	3	None	add
170	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  parsedOffset));  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  parsedOffset));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(bucket.computeMillis(false,  parsedOffset));	  	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	3	None	add
171	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(instant.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(instant.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(instant.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	3	None	add
172	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(bucket.computeMillis(false,  iLocale));	  	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)	3	None	add
173	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(instantLocal,  parsedOffset,  parsedZone));  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(instantLocal,  parsedOffset,  parsedZone));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(selectChronology(instantLocal,  parsedOffset,  parsedZone));	  	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	3	None	add
174	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(iChrono));  [CE]  no  suitable  method  found  for  setMillis(Chronology)  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(iChrono));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(selectChronology(iChrono));	  	non-compiled	[CE]  no  suitable  method  found  for  setMillis(Chronology)	3	None	add
175	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(instantLocal,  parsedZone));  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(instantLocal,  parsedZone));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(selectChronology(instantLocal,  parsedZone));	  	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	3	None	add
176	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(instantLocal,  parsedOffset,  chrono));  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(instantLocal,  parsedOffset,  chrono));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(selectChronology(instantLocal,  parsedOffset,  chrono));	  	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	3	None	add
177	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iChrono  =  chrono.withZone(parsedZone);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iChrono  =  chrono.withZone(parsedZone);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  iChrono  =  chrono.withZone(parsedZone);	      instant.setMillis(bucket.computeMillis(false,    text));    iChrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	14	None	replace
178	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  iChrono  =  chrono.withZone(parsedZone);  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]                            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  iChrono  =  chrono.withZone(parsedZone);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  position);  iChrono  =  chrono.withZone(parsedZone);	      instant.setMillis(bucket.computeMillis(false,    text));    iChrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	14	None	replace
179	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  parsedOffset));  iChrono  =  chrono.withZone(parsedZone);  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  parsedOffset));  iChrono  =  chrono.withZone(parsedZone);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  parsedOffset));  iChrono  =  chrono.withZone(parsedZone);	      instant.setMillis(bucket.computeMillis(false,    text));    iChrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	14	None	replace
180	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  parsedOffset);  iChrono  =  chrono.withZone(parsedZone);  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]                                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  parsedOffset);  iChrono  =  chrono.withZone(parsedZone);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  parsedOffset);  iChrono  =  chrono.withZone(parsedZone);	      instant.setMillis(bucket.computeMillis(false,    text));    iChrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	14	None	replace
181	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  instant.setChrono  =  chrono.withZone(parsedZone);  [CE]  cannot  find  symbol  setChrono  [FE]                                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  instant.setChrono  =  chrono.withZone(parsedZone);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text));  instant.setChrono  =  chrono.withZone(parsedZone);	      instant.setMillis(bucket.computeMillis(false,    text));    iChrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  cannot  find  symbol  setChrono	14	None	replace
182	[BUG]  [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text,  position));  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text,  position));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(chrono.computeMillis(false,  text,  position));	      instant.setMillis(chrono.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	46	None	replace
183	[BUG]  [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text),  iLocale);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text),  iLocale);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(chrono.computeMillis(false,  text),  iLocale);	      instant.setMillis(chrono.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	46	None	replace
184	[BUG]  [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text,  iLocale));  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text,  iLocale));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(chrono.computeMillis(false,  text,  iLocale));	      instant.setMillis(chrono.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	46	None	replace
185	[BUG]  [BUGGY]  instant.setMillis(chrono.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(chrono.computeMillis(true,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(chrono.computeMillis(true,  text));	      instant.setMillis(chrono.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	46	None	replace
186	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	instant.setMillis(bucket.computeMillis(true,  text));	      instant.setMillis(bucket.computeMillis(false,    text));    	compilable	  [FE]  AssertionFailedError  	2	8	replace
187	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(true,  text));	      instant.setMillis(bucket.computeMillis(false,    text));    	compilable	  [FE]  AssertionFailedError  	2	8	replace
188	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  chrono));  [CE]  no  suitable  method  found  for  computeMillis(boolean,Chronology)  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  chrono));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  chrono));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,Chronology)	2	None	replace
189	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  parsedOffset));  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  parsedOffset));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  parsedOffset));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	2	None	replace
190	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  iLocale));  [CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  iLocale));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  iLocale));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,Locale)	2	None	replace
191	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  iChrono));  [CE]  no  suitable  method  found  for  computeMillis(boolean,Chronology)  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  iChrono));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  iChrono));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,Chronology)	2	None	replace
192	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  newPos));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  newPos));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	2	None	replace
193	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	        instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	5	7	add
194	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	5	7	add
195	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.withZone(parsedZone);  [CE]  incompatible  types  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.withZone(parsedZone);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.withZone(parsedZone);	  	non-compiled	[CE]  incompatible  types	5	None	add
196	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	        instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	5	7	add
197	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	5	7	add
198	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  Instant  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  Instant  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    Instant  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  ';'  expected	5	None	add
199	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(parser.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(parser.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  find  symbol	5	None	add
200	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  location);  [CE]  cannot  find  symbol  location  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  location);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  location);	  	non-compiled	[CE]  cannot  find  symbol  location	5	None	add
201	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  moment.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  moment  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  moment.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    moment.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  find  symbol  moment	5	None	add
202	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  find  symbol	5	None	add
203	[BUG]  [BUGGY]  iChrono.setMillis(chrono.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  iChrono.setMillis(chrono.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	iChrono.setMillis(chrono.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);	      instant.setMillis(iChrono.computeMillis(false,    text));    newPos    =    chrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	48	None	replace
204	[BUG]  [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(iChrono.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);	      instant.setMillis(iChrono.computeMillis(false,    text));    newPos    =    chrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	48	None	replace
205	[BUG]  [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text),  position);  newPos  =  chrono.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(iChrono.computeMillis(false,  text),  position);  newPos  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(iChrono.computeMillis(false,  text),  position);  newPos  =  chrono.parseInto(bucket,  text,  position);	      instant.setMillis(iChrono.computeMillis(false,    text));    newPos    =    chrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	48	None	replace
206	[BUG]  [BUGGY]  iChrono.setMillis(iChrono.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  iChrono.setMillis(iChrono.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	iChrono.setMillis(iChrono.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);	      instant.setMillis(iChrono.computeMillis(false,    text));    newPos    =    chrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	48	None	replace
207	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getChronology(),  parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getChronology(),  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getChronology(),  parsedZone);	  chrono    =    chrono.withZone(bucket.getChronology());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	22	None	replace
208	[BUG]  [BUGGY]  Chronology  chrono  =  chrono.withZone(bucket.getChronology(),  parsedZone);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  chrono.withZone(bucket.getChronology(),  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  chrono.withZone(bucket.getChronology(),  parsedZone);	  chrono    =    chrono.withZone(bucket.getChronology());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
209	[BUG]  [BUGGY]  chrono  =  chrono.withZone(parsedZone,  bucket.getChronology());  [CE]  cannot  find  symbol  parsedZone  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(parsedZone,  bucket.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(parsedZone,  bucket.getChronology());	  chrono    =    chrono.withZone(bucket.getChronology());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	22	None	replace
210	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket,  parsedZone.getChronology());  [CE]  cannot  find  symbol  parsedZone  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket,  parsedZone.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket,  parsedZone.getChronology());	  chrono    =    chrono.withZone(bucket.getChronology());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	22	None	replace
211	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.withZone(chrono.getChronology());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.withZone(chrono.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.withZone(chrono.getChronology());	  chrono    =    chrono.withZone(bucket.getChronology());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	22	None	replace
212	[BUG]  [BUGGY]  chrono  =  chrono.withZone(chrono,  bucket.getChronology());  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(chrono,  bucket.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(chrono,  bucket.getChronology());	  chrono    =    chrono.withZone(bucket.getChronology());    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	22	None	replace
213	[BUG]  [BUGGY]  chrono  =  chrono.withZone(chrono.getChronology(),  parsedZone);  [CE]  cannot  find  symbol  [FE]                                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(chrono.getChronology(),  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(chrono.getChronology(),  parsedZone);	  chrono    =    chrono.withZone(bucket.getChronology());    	non-compiled	[CE]  cannot  find  symbol	22	None	replace
214	[BUG]  [BUGGY]  chrono  =  chrono.withZone(iChrono,  bucket.getChronology());  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(iChrono,  bucket.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(iChrono,  bucket.getChronology());	  chrono    =    chrono.withZone(bucket.getChronology());    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	22	None	replace
215	[BUG]  [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parsedZone.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  chrono));	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	34	None	replace
216	[BUG]  [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position,  chrono.setMillis(bucket.computeMillis(false,  text));  [CE]  ')'  expected  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position,  chrono.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parsedZone.parseInto(bucket,  text,  position,  chrono.setMillis(bucket.computeMillis(false,  text));	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  ')'  expected	34	None	replace
217	[BUG]  [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parsedZone.parseInto(bucket,  text,  position  -  1);  instant.setMillis(bucket.computeMillis(false,  text));	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	34	None	replace
218	[BUG]  [BUGGY]  parsedZone  =  bucket.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedZone  =  bucket.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	parsedZone  =  bucket.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	34	None	replace
219	[BUG]  [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parsedZone.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  iLocale));	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	34	None	replace
220	[BUG]  [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position);  chrono.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position);  chrono.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parsedZone.parseInto(bucket,  text,  position);  chrono.setMillis(bucket.computeMillis(false,  text));	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	34	None	replace
221	[BUG]  [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parsedZone.parseInto(bucket,  text,  position  +  1);  instant.setMillis(bucket.computeMillis(false,  text));	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	34	None	replace
222	[BUG]  [BUGGY]  chrono  =  chrono.withZone(instant,  parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(instant,  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(instant,  parsedZone);	  chrono    =    chrono.withZone(chrono);    	non-compiled	[CE]  cannot  find  symbol  parsedZone	29	None	replace
223	[BUG]  [BUGGY]  chrono  =  chrono.withZone(parsedZone,  chrono);  [CE]  cannot  find  symbol  parsedZone  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(parsedZone,  chrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(parsedZone,  chrono);	  chrono    =    chrono.withZone(chrono);    	non-compiled	[CE]  cannot  find  symbol  parsedZone	29	None	replace
224	[BUG]  [BUGGY]  chrono  =  chrono.withZone(instantLocal,  parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(instantLocal,  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(instantLocal,  parsedZone);	  chrono    =    chrono.withZone(chrono);    	non-compiled	[CE]  cannot  find  symbol  parsedZone	29	None	replace
225	[BUG]  [BUGGY]  chrono  =  chrono.withZone(parsedZone,  parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(parsedZone,  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(parsedZone,  parsedZone);	  chrono    =    chrono.withZone(chrono);    	non-compiled	[CE]  cannot  find  symbol  parsedZone	29	None	replace
226	[BUG]  [BUGGY]  chrono  =  chrono.withZone(chrono,  parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(chrono,  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(chrono,  parsedZone);	  chrono    =    chrono.withZone(chrono);    	non-compiled	[CE]  cannot  find  symbol  parsedZone	29	None	replace
227	[BUG]  [BUGGY]  chrono  =  iChrono.withZone(chrono);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  iChrono.withZone(chrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  iChrono.withZone(chrono);	  chrono    =    chrono.withZone(chrono);    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	29	None	replace
228	[BUG]  [BUGGY]  chrono  =  chrono.withLocal(bucket.getZone());  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withLocal(bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withLocal(bucket.getZone());	  chrono    =    chrono.withLocal(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
229	[BUG]  [BUGGY]  chrono  =  chrono.withLocal(iChrono.getZone());  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withLocal(iChrono.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withLocal(iChrono.getZone());	  chrono    =    chrono.withLocal(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
230	[BUG]  [BUGGY]  Chronology  chrono  =  chrono.withLocal(parsedZone.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  chrono.withLocal(parsedZone.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  chrono.withLocal(parsedZone.getZone());	  chrono    =    chrono.withLocal(parsedZone.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
231	[BUG]  [BUGGY]  Chronology  chrono  =  chrono.withLocal(bucket.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  chrono.withLocal(bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  chrono.withLocal(bucket.getZone());	  chrono    =    chrono.withLocal(parsedZone.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	23	None	replace
232	[BUG]  [BUGGY]  chrono  =  chrono.withLocal(parsedZone.getChronology());  [CE]  cannot  find  symbol  parsedZone  [FE]                                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withLocal(parsedZone.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withLocal(parsedZone.getChronology());	  chrono    =    chrono.withLocal(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	23	None	replace
233	[BUG]  [BUGGY]  chrono  =  chrono.withLocal(iZone.getZone());  [CE]  cannot  find  symbol  [FE]                                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withLocal(iZone.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withLocal(iZone.getZone());	  chrono    =    chrono.withLocal(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
234	[BUG]  [BUGGY]  chrono  =  chrono.withLocal(chrono.getZone());  [CE]  cannot  find  symbol  [FE]                                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withLocal(chrono.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withLocal(chrono.getZone());	  chrono    =    chrono.withLocal(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol	23	None	replace
235	[BUG]  [BUGGY]  chrono  =  chrono.withLocal(mv.getZone());  [CE]  cannot  find  symbol  mv  [FE]                                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withLocal(mv.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withLocal(mv.getZone());	  chrono    =    chrono.withLocal(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol  mv	23	None	replace
236	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  iLocale);  [CE]  no  suitable  method  found  for  setMillis(long,Locale)  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  iLocale);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  iLocale);	      instant.setMillis(bucket.computeMillis(false,    text));    iLocale    =    locale;    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,Locale)	11	None	replace
237	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  parsedOffset));  iLocale  =  locale;  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  parsedOffset));  iLocale  =  locale;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  parsedOffset));  iLocale  =  locale;	      instant.setMillis(bucket.computeMillis(false,    text));    iLocale    =    locale;    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	11	None	replace
238	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iLocale  =  locale;  [CE]  cannot  assign  a  value  to  final  variable  iLocale  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iLocale  =  locale;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  iLocale  =  locale;	      instant.setMillis(bucket.computeMillis(false,    text));    iLocale    =    locale;    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iLocale	11	None	replace
239	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  chrono  =  locale;  [CE]  cannot  find  symbol  locale  [FE]                            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  chrono  =  locale;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text));  chrono  =  locale;	      instant.setMillis(bucket.computeMillis(false,    text));    iLocale    =    locale;    	non-compiled	[CE]  cannot  find  symbol  locale	11	None	replace
240	[BUG]  [BUGGY]  Chronology  chrono  =  iChrono.withZone(parsedZone.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  iChrono.withZone(parsedZone.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  iChrono.withZone(parsedZone.getZone());	  Chronology    chrono    =    iChrono.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	18	None	replace
241	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.withZone(iChrono.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.withZone(iChrono.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.withZone(iChrono.getZone());	  Chronology    chrono    =    iChrono.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	18	None	replace
242	[BUG]  [BUGGY]  Chronology  chrono  =  iChrono.withZone(bucket.getZone(),  parsedZone);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  iChrono.withZone(bucket.getZone(),  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  iChrono.withZone(bucket.getZone(),  parsedZone);	  Chronology    chrono    =    iChrono.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	18	None	replace
243	[BUG]  [BUGGY]  Chronology  chrono  =  iChrono.withZone(bucket.getZone(),  parsedOffset);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  iChrono.withZone(bucket.getZone(),  parsedOffset);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  iChrono.withZone(bucket.getZone(),  parsedOffset);	  Chronology    chrono    =    iChrono.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	18	None	replace
244	[BUG]  [BUGGY]  Chronology  chrono  =  instant.getChronology().withZone(bucket.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  instant.getChronology().withZone(bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  instant.getChronology().withZone(bucket.getZone());	  Chronology    chrono    =    iChrono.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	18	None	replace
245	[BUG]  [BUGGY]  Chronology  chrono  =  iChrono.withZone(bucket.getChronology());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  iChrono.withZone(bucket.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  iChrono.withZone(bucket.getChronology());	  Chronology    chrono    =    iChrono.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	18	None	replace
246	[BUG]  [BUGGY]  Chronology  chrono  =  instant.getChronology().withZone(iChrono.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  instant.getChronology().withZone(iChrono.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  instant.getChronology().withZone(iChrono.getZone());	  Chronology    chrono    =    iChrono.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	18	None	replace
247	[BUG]  [BUGGY]  Chronology  chrono  =  chrono.withZone(bucket.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  chrono.withZone(bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  chrono.withZone(bucket.getZone());	  chrono    =    chrono.withZone(parsedZone.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	15	None	replace
248	[BUG]  [BUGGY]  Chronology  chrono  =  chrono.withZone(parsedZone.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  chrono.withZone(parsedZone.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  chrono.withZone(parsedZone.getZone());	  chrono    =    chrono.withZone(parsedZone.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	15	None	replace
249	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(chrono.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	add	chrono  =  chrono.withZone(chrono.getZone());	  chrono    =    chrono.withZone(parsedZone.getZone());    	compilable	  [FE]  AssertionFailedError  	15	7	replace
250	[BUG]  [BUGGY]  chrono  =  chrono.withZone(chrono.getZone());  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(chrono.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(chrono.getZone());	  chrono    =    chrono.withZone(parsedZone.getZone());    	compilable	  [FE]  AssertionFailedError  	15	7	replace
251	[BUG]  [BUGGY]  chrono  =  chrono.withZone(button.getZone());  [CE]  cannot  find  symbol  button  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(button.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(button.getZone());	  chrono    =    chrono.withZone(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol  button	15	None	replace
252	[BUG]  [BUGGY]  chrono  =  chrono.withZone(str.getZone());  [CE]  cannot  find  symbol  str  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(str.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(str.getZone());	  chrono    =    chrono.withZone(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol  str	15	None	replace
253	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
254	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
255	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
256	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(true,  text));	  	compilable	  [FE]  AssertionFailedError  	1	7	add
257	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  Instant  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  Instant  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    Instant  instant.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  ';'  expected	1	None	add
258	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  moment.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  moment  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  moment.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    moment.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  moment	1	None	add
259	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(parsedZone.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(parsedZone.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(parsedZone.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	1	None	add
260	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(chrono.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(chrono.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(chrono.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	1	None	add
261	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(False,  text));  [CE]  cannot  find  symbol  False  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(False,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(False,  text));	  	non-compiled	[CE]  cannot  find  symbol  False	1	None	add
262	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(buf.computeMillis(false,  text));  [CE]  cannot  find  symbol  buf  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(buf.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(buf.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  buf	1	None	add
263	[BUG]  [BUGGY]  chrono  =  bucket.withUTC();  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  bucket.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  bucket.withUTC();	  chrono    =    chrono.withUTC();    	non-compiled	[CE]  cannot  find  symbol	41	None	replace
264	[BUG]  [BUGGY]  chrono  =  bucket.withZone(parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  bucket.withZone(parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  bucket.withZone(parsedZone);	  chrono    =    chrono.withUTC();    	non-compiled	[CE]  cannot  find  symbol  parsedZone	41	None	replace
265	[BUG]  [BUGGY]  chrono  =  iChrono.withUTC();  [timeout]  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  iChrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  iChrono.withUTC();	  chrono    =    chrono.withUTC();    	non-compiled	[timeout]	41	None	replace
266	[BUG]  [BUGGY]  chrono  =  new  ReadWritableInstant(instantLocal,  parsedZone,  iLocale,  iPivotYear,  iDefaultYear);  [timeout]  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  new  ReadWritableInstant(instantLocal,  parsedZone,  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  new  ReadWritableInstant(instantLocal,  parsedZone,  iLocale,  iPivotYear,  iDefaultYear);	  chrono    =    chrono.withUTC();    	non-compiled	[timeout]	41	None	replace
267	[BUG]  [BUGGY]  chrono  =  new  ReadWritableInstant(instantLocal,  parsedZone,  iPivotYear,  iDefaultYear);  [CE]  cannot  find  symbol  parsedZone  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  new  ReadWritableInstant(instantLocal,  parsedZone,  iPivotYear,  iDefaultYear);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  new  ReadWritableInstant(instantLocal,  parsedZone,  iPivotYear,  iDefaultYear);	  chrono    =    chrono.withUTC();    	non-compiled	[CE]  cannot  find  symbol  parsedZone	41	None	replace
268	[BUG]  [BUGGY]  chrono  =  parsedZone.withUTC();  [CE]  cannot  find  symbol  parsedZone  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  parsedZone.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  parsedZone.withUTC();	  chrono    =    chrono.withUTC();    	non-compiled	[CE]  cannot  find  symbol  parsedZone	41	None	replace
269	[BUG]  [BUGGY]  chrono  =  bucket.withZone(chrono);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  bucket.withZone(chrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  bucket.withZone(chrono);	  chrono    =    chrono.withUTC();    	non-compiled	[CE]  cannot  find  symbol	41	None	replace
270	[BUG]  [BUGGY]  chrono  =  new  ReadWritableInstant(instantLocal,  chrono.getChronology(),  parsedOffset,  parsedZone);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  new  ReadWritableInstant(instantLocal,  chrono.getChronology(),  parsedOffset,  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  new  ReadWritableInstant(instantLocal,  chrono.getChronology(),  parsedOffset,  parsedZone);	  chrono    =    chrono.withUTC();    	non-compiled	[CE]  cannot  find  symbol	41	None	replace
271	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    	compilable	  [FE]  AssertionFailedError  	6	8	replace
272	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    	compilable	  [FE]  AssertionFailedError  	6	8	replace
273	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iOffsetParsed  &&  chrono!=  null)  {  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	if(iOffsetParsed  &&  chrono!=  null)  {  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  }	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    	compilable	  [FE]  AssertionFailedError  	6	8	replace
274	[BUG]  [BUGGY]  if(iOffsetParsed  &&  chrono!=  null)  {  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iOffsetParsed  &&  chrono!=  null)  {  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iOffsetParsed  &&  chrono!=  null)  {  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  }	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    	compilable	  [FE]  AssertionFailedError  	6	8	replace
275	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iLocale!=  null)  {  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	if(iLocale!=  null)  {  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  }	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    	compilable	  [FE]  AssertionFailedError  	6	8	replace
276	[BUG]  [BUGGY]  if(iLocale!=  null)  {  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iLocale!=  null)  {  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iLocale!=  null)  {  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  }	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    	compilable	  [FE]  AssertionFailedError  	6	8	replace
277	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  position);  newPos  =  parser.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	6	None	replace
278	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	6	None	replace
279	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position  -  1);	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    	compilable	  [FE]  AssertionFailedError  	6	8	replace
280	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position  -  1);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position  -  1);	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    	compilable	  [FE]  AssertionFailedError  	6	8	replace
281	[BUG]  [BUGGY]  chrono  =  bucket.withZone(iChrono.getZone());  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  bucket.withZone(iChrono.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  bucket.withZone(iChrono.getZone());	  chrono    =    iChrono.withZone(bucket.getZone());    [timeout]    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
282	[BUG]  [BUGGY]  chrono  =  iChrono.withZone(parsedZone.getZone());  [CE]  cannot  find  symbol  parsedZone  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  iChrono.withZone(parsedZone.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  iChrono.withZone(parsedZone.getZone());	  chrono    =    iChrono.withZone(bucket.getZone());    [timeout]    	non-compiled	[CE]  cannot  find  symbol  parsedZone	27	None	replace
283	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  bucket.getChronology();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	add	chrono  =  bucket.getChronology();	  chrono    =    iChrono.withZone(bucket.getZone());    [timeout]    	compilable	  [FE]  AssertionFailedError  	27	13	replace
284	[BUG]  [BUGGY]  chrono  =  bucket.getChronology();  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  bucket.getChronology();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  bucket.getChronology();	  chrono    =    iChrono.withZone(bucket.getZone());    [timeout]    	compilable	  [FE]  AssertionFailedError  	27	13	replace
285	[BUG]  [BUGGY]  chrono  =  parsedZone.withZone(bucket.getZone());  [CE]  cannot  find  symbol  parsedZone  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  parsedZone.withZone(bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  parsedZone.withZone(bucket.getZone());	  chrono    =    iChrono.withZone(bucket.getZone());    [timeout]    	non-compiled	[CE]  cannot  find  symbol  parsedZone	27	None	replace
286	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.getChronology();  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.getChronology();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.getChronology();	  chrono    =    iChrono.withZone(bucket.getZone());    [timeout]    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
287	[BUG]  [BUGGY]  chrono  =  iChrono.withZone(parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  iChrono.withZone(parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  iChrono.withZone(parsedZone);	  chrono    =    iChrono.withZone(bucket.getZone());    [timeout]    	non-compiled	[CE]  cannot  find  symbol  parsedZone	27	None	replace
288	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  return  newPos;  [CE]  unreachable  statement  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  return  newPos;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  return  newPos;	      instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    	non-compiled	[CE]  unreachable  statement	13	None	replace
289	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  parsedOffset));  return  newPos;  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  parsedOffset));  return  newPos;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  parsedOffset));  return  newPos;	      instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	13	None	replace
290	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  chrono));  return  newPos;  [CE]  no  suitable  method  found  for  computeMillis(boolean,Chronology)  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  chrono));  return  newPos;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  chrono));  return  newPos;	      instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,Chronology)	13	None	replace
291	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  return  newPos  +  1;  [CE]  unreachable  statement  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  return  newPos  +  1;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  return  newPos  +  1;	      instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    	non-compiled	[CE]  unreachable  statement	13	None	replace
292	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  return  newPos  -  1;  [CE]  unreachable  statement  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  return  newPos  -  1;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  return  newPos  -  1;	      instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    	non-compiled	[CE]  unreachable  statement	13	None	replace
293	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  return  newPos;  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  return  newPos;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  position);  return  newPos;	      instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	13	None	replace
294	[BUG]  [BUGGY]  Chronology  chrono  =  iChrono.withChronology(chrono);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  iChrono.withChronology(chrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  iChrono.withChronology(chrono);	  chrono    =    chrono.withChronology(chrono);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
295	[BUG]  [BUGGY]  chrono  =  iChrono.withChronology(chrono);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  iChrono.withChronology(chrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  iChrono.withChronology(chrono);	  chrono    =    chrono.withChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol	30	None	replace
296	[BUG]  [BUGGY]  Chronology  chrono  =  parsedZone.withChronology(chrono);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  parsedZone.withChronology(chrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  parsedZone.withChronology(chrono);	  chrono    =    chrono.withChronology(chrono);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
297	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.withChronology(chrono);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.withChronology(chrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.withChronology(chrono);	  chrono    =    chrono.withChronology(chrono);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
298	[BUG]  [BUGGY]  chrono  =  parsedZone.withChronology(chrono);  [CE]  cannot  find  symbol  parsedZone  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  parsedZone.withChronology(chrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  parsedZone.withChronology(chrono);	  chrono    =    chrono.withChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol  parsedZone	30	None	replace
299	[BUG]  [BUGGY]  Chronology  chrono  =  graph.withChronology(chrono);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  graph.withChronology(chrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  graph.withChronology(chrono);	  chrono    =    chrono.withChronology(chrono);    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	30	None	replace
300	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(iChrono);  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(iChrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(iChrono);	  chrono    =    chrono.withChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol	30	None	replace
301	[BUG]  [BUGGY]  chrono  =  bucket.withChronology(chrono);  [CE]  cannot  find  symbol  [FE]                              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  bucket.withChronology(chrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  bucket.withChronology(chrono);	  chrono    =    chrono.withChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol	30	None	replace
302	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(iChrono.getChronology());  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(iChrono.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(iChrono.getChronology());	  chrono    =    chrono.withChronology(parsedZone.getChronology());    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
303	[BUG]  [BUGGY]  Chronology  chrono  =  parsedZone.withChronology(chrono.getChronology());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  parsedZone.withChronology(chrono.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  parsedZone.withChronology(chrono.getChronology());	  chrono    =    chrono.withChronology(parsedZone.getChronology());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	17	None	replace
304	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(chrono.getChronology());  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(chrono.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(chrono.getChronology());	  chrono    =    chrono.withChronology(parsedZone.getChronology());    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
305	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(instant.getChronology());  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(instant.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(instant.getChronology());	  chrono    =    chrono.withChronology(parsedZone.getChronology());    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
306	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(bucketZone.getChronology());  [CE]  cannot  find  symbol  bucketZone  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(bucketZone.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(bucketZone.getChronology());	  chrono    =    chrono.withChronology(parsedZone.getChronology());    	non-compiled	[CE]  cannot  find  symbol  bucketZone	17	None	replace
307	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(jp.getChronology());  [CE]  cannot  find  symbol  jp  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(jp.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(jp.getChronology());	  chrono    =    chrono.withChronology(parsedZone.getChronology());    	non-compiled	[CE]  cannot  find  symbol  jp	17	None	replace
308	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(tmp.getChronology());  [CE]  cannot  find  symbol  tmp  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(tmp.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(tmp.getChronology());	  chrono    =    chrono.withChronology(parsedZone.getChronology());    	non-compiled	[CE]  cannot  find  symbol  tmp	17	None	replace
309	[BUG]  [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position  -  1);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position  -  1);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parsedZone.parseInto(bucket,  text,  position  -  1);	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	36	None	replace
310	[BUG]  [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position,  iLocale);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position,  iLocale);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parsedZone.parseInto(bucket,  text,  position,  iLocale);	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	36	None	replace
311	[BUG]  [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position  +  1);  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position  +  1);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parsedZone.parseInto(bucket,  text,  position  +  1);	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	36	None	replace
312	[BUG]  [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position,  chrono);  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position,  chrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parsedZone.parseInto(bucket,  text,  position,  chrono);	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	36	None	replace
313	[BUG]  [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position,  iOffsetParsed);  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position,  iOffsetParsed);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parsedZone.parseInto(bucket,  text,  position,  iOffsetParsed);	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	36	None	replace
314	[BUG]  [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position,  iDefaultYear);  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position,  iDefaultYear);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parsedZone.parseInto(bucket,  text,  position,  iDefaultYear);	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	36	None	replace
315	[BUG]  [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position,  parsedOffset);  [CE]  cannot  find  symbol  [FE]                              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position,  parsedOffset);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parsedZone.parseInto(bucket,  text,  position,  parsedOffset);	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	36	None	replace
316	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    }    	compilable	  [FE]  AssertionFailedError  	39	8	replace
317	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  }  [FE]  AssertionFailedError  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    }    	compilable	  [FE]  AssertionFailedError  	39	8	replace
318	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedZone);  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedZone);  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedZone);  newPos  =  chrono.parseInto(bucket,  text,  position);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	39	None	replace
319	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedOffset);  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedOffset);  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedOffset);  newPos  =  chrono.parseInto(bucket,  text,  position);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	39	None	replace
320	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(chrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	if(chrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    }    	compilable	  [FE]  AssertionFailedError  	39	8	replace
321	[BUG]  [BUGGY]  if(chrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  }  [FE]  AssertionFailedError  [FE]                              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(chrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(chrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  parser.parseInto(bucket,  text,  position);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    }    	compilable	  [FE]  AssertionFailedError  	39	8	replace
322	[BUG]  [BUGGY]  if(chrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [CE]  cannot  find  symbol  [FE]                                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(chrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(chrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    }    	non-compiled	[CE]  cannot  find  symbol	39	None	replace
323	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  text);  newPos  =  parser.parseInto(bucket,  text,  position);  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  text);  newPos  =  parser.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  text);  newPos  =  parser.parseInto(bucket,  text,  position);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	39	None	replace
324	[BUG]  [BUGGY]  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	38	None	replace
325	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedZone);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedZone);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedZone);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	38	None	replace
326	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedOffset);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedOffset);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedOffset);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	38	None	replace
327	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.setMillis(instant.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.setMillis(instant.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.setMillis(instant.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	38	None	replace
328	[BUG]  [BUGGY]  newPos  =  parser.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parser.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parser.setMillis(bucket.computeMillis(false,  text));	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	38	None	replace
329	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedZone.computeMillis(false,  text));  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]                                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedZone.computeMillis(false,  text));  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  parsedZone.computeMillis(false,  text));  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	38	None	replace
330	[BUG]  [BUGGY]  newPos  =  iChrono.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  iChrono.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  iChrono.setMillis(bucket.computeMillis(false,  text));	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	38	None	replace
331	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  parsedOffset));  }  [CE]  no  suitable  method  found  for  computeMillis(boolean,int)  [FE]                                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  parsedOffset));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  parsedOffset));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  no  suitable  method  found  for  computeMillis(boolean,int)	38	None	replace
332	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  text),  chrono);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  text),  chrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(instant.computeMillis(false,  text),  chrono);	      instant.setMillis(instant.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	47	None	replace
333	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  parsedOffset));  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  parsedOffset));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(instant.computeMillis(false,  parsedOffset));	      instant.setMillis(instant.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	47	None	replace
334	[BUG]  [BUGGY]  instant.setMillis(instant.computeMillis(false,  text),  iLocale);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(instant.computeMillis(false,  text),  iLocale);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(instant.computeMillis(false,  text),  iLocale);	      instant.setMillis(instant.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	47	None	replace
335	[BUG]  [BUGGY]  if(iPivotYear!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iPivotYear!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iPivotYear!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
336	[BUG]  [BUGGY]  if(iLocale!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iLocale!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iLocale!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
337	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position,  parsedZone);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position,  parsedZone);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position,  parsedZone);  instant.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
338	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position,  parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position,  parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position,  parsedOffset);  instant.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
339	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	35	None	replace
340	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  iChrono);  [CE]  no  suitable  method  found  for  setMillis(long,Chronology)  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  iChrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  iChrono);	      instant.setMillis(bucket.computeMillis(false,    text));    iChrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,Chronology)	14	None	replace
341	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  }	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    	compilable	  [FE]  AssertionFailedError  	6	8	replace
342	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  null)  {  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  }	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    	compilable	  [FE]  AssertionFailedError  	6	8	replace
343	[BUG]  [BUGGY]  instant.setPos(parser.parseInto(bucket,  text,  position);  [CE]  ')'  expected  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setPos(parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setPos(parser.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  ')'  expected	6	None	replace
344	[BUG]  [BUGGY]  instant.setMillis(parsedZone.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(parsedZone.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(parsedZone.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	6	None	replace
345	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  iChrono.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  iChrono.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  iChrono.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	6	None	replace
346	[BUG]  [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(chrono.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);	      instant.setMillis(iChrono.computeMillis(false,    text));    newPos    =    chrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	48	None	replace
347	[BUG]  [BUGGY]  instant.setMillis(iChrono.computeMillis(true,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(iChrono.computeMillis(true,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(iChrono.computeMillis(true,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);	      instant.setMillis(iChrono.computeMillis(false,    text));    newPos    =    chrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	48	None	replace
348	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(chrono,  parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(chrono,  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(chrono,  parsedZone);	  chrono    =    chrono.withChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol  parsedZone	30	None	replace
349	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(parsedZone);	  chrono    =    chrono.withChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol  parsedZone	30	None	replace
350	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(instant);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(instant);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(instant);	  chrono    =    chrono.withChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol	30	None	replace
351	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(iChrono,  parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(iChrono,  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(iChrono,  parsedZone);	  chrono    =    chrono.withChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol  parsedZone	30	None	replace
352	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(bucket);  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(bucket);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(bucket);	  chrono    =    chrono.withChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol	30	None	replace
353	[BUG]  [BUGGY]  instant.setMillis(iChrono.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(iChrono.computeMillis(true,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(iChrono.computeMillis(true,  text));	      instant.setMillis(iChrono.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	45	None	replace
354	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  DateTimeParserBucket  chrono  =  chrono.withUTC();  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  DateTimeParserBucket  chrono  =  chrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    DateTimeParserBucket  chrono  =  chrono.withUTC();	  	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	40	None	add
355	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  DateTimeParser  parser  =  bucket.getParser();  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  DateTimeParser  parser  =  bucket.getParser();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    DateTimeParser  parser  =  bucket.getParser();	  	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	40	None	add
356	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  parsedZone  =  chrono.withUTC();  [CE]  cannot  find  symbol  parsedZone  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  parsedZone  =  chrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    parsedZone  =  chrono.withUTC();	  	non-compiled	[CE]  cannot  find  symbol  parsedZone	40	None	add
357	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  DateTimeParser  parser  =  chrono.withUTC();  [CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  DateTimeParser  parser  =  chrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    DateTimeParser  parser  =  chrono.withUTC();	  	non-compiled	[CE]  variable  parser  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	40	None	add
358	[BUG]  [BUGGY]  parsedOffset  =  chrono.getOffset();  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  chrono.getOffset();  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	parsedOffset  =  chrono.getOffset();	      parsedOffset    =    parsedZone.getOffset();    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
359	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  parsedZone.getOffset(parsedOffset);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	parsedOffset  =  parsedZone.getOffset(parsedOffset);	      parsedOffset    =    parsedZone.getOffset();    	compilable	  [FE]  AssertionFailedError  	7	8	replace
360	[BUG]  [BUGGY]  parsedOffset  =  parsedZone.getOffset(parsedOffset);  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  parsedZone.getOffset(parsedOffset);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	parsedOffset  =  parsedZone.getOffset(parsedOffset);	      parsedOffset    =    parsedZone.getOffset();    	compilable	  [FE]  AssertionFailedError  	7	8	replace
361	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(bucket.getZone(),  parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(bucket.getZone(),  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(bucket.getZone(),  parsedZone);	  chrono    =    chrono.withChronology(bucket.getZone());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	26	None	replace
362	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(bucket,  bucket.getZone());  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(bucket,  bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(bucket,  bucket.getZone());	  chrono    =    chrono.withChronology(bucket.getZone());    	non-compiled	[CE]  cannot  find  symbol	26	None	replace
363	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(chrono,  bucket.getZone());  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(chrono,  bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(chrono,  bucket.getZone());	  chrono    =    chrono.withChronology(bucket.getZone());    	non-compiled	[CE]  cannot  find  symbol	26	None	replace
364	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  bucket.getOffsetInteger());  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  bucket.getOffsetInteger());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getZone(),  bucket.getOffsetInteger());	  chrono    =    chrono.withZone(bucket.getZone(),    parsedZone);    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	42	None	replace
365	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  row);  [CE]  cannot  find  symbol  row  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  row);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getZone(),  row);	  chrono    =    chrono.withZone(bucket.getZone(),    parsedZone);    	non-compiled	[CE]  cannot  find  symbol  row	42	None	replace
366	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  iChrono);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  iChrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getZone(),  iChrono);	  chrono    =    chrono.withZone(bucket.getZone(),    parsedZone);    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	42	None	replace
367	[BUG]  [BUGGY]  chrono  =  chrono.withZone(iZone.getZone());  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(iZone.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(iZone.getZone());	  chrono    =    chrono.withZone(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol	15	None	replace
368	[BUG]  [BUGGY]  chrono  =  chrono.withZone(timeZone.getZone());  [CE]  cannot  find  symbol  timeZone  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(timeZone.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(timeZone.getZone());	  chrono    =    chrono.withZone(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol  timeZone	15	None	replace
369	[BUG]  [BUGGY]  chrono  =  chrono.withZone(separator.getZone());  [CE]  cannot  find  symbol  separator  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(separator.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(separator.getZone());	  chrono    =    chrono.withZone(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol  separator	15	None	replace
370	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setChronology(iChrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	instant.setChronology(iChrono);	      instant.setChronology(chrono);    	compilable	  [FE]  AssertionFailedError  	4	8	replace
371	[BUG]  [BUGGY]  instant.setChronology(iChrono);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setChronology(iChrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setChronology(iChrono);	      instant.setChronology(chrono);    	compilable	  [FE]  AssertionFailedError  	4	8	replace
372	[BUG]  [BUGGY]  instant.setTime(chrono);  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setTime(chrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setTime(chrono);	      instant.setChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
373	[BUG]  [BUGGY]  instant.setParsed(true);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setParsed(true);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setParsed(true);	      instant.setChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
374	[BUG]  [BUGGY]  instant.setLocale(locale);  [CE]  cannot  find  symbol  locale  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setLocale(locale);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setLocale(locale);	      instant.setChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol  locale	4	None	replace
375	[BUG]  [BUGGY]  instant.setTimeZone(chrono);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setTimeZone(chrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setTimeZone(chrono);	      instant.setChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
376	[BUG]  [BUGGY]  instant.setChronology(chrono,  null);  [CE]  method  setChronology  in  interface  ReadWritableInstant  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setChronology(chrono,  null);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setChronology(chrono,  null);	      instant.setChronology(chrono);    	non-compiled	[CE]  method  setChronology  in  interface  ReadWritableInstant  cannot  be  applied  to  given  types;	4	None	replace
377	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  instant.setMillis(bucket.computeMillis(false,  text));  return  newPos  +  1;  [CE]  unreachable  statement  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  instant.setMillis(bucket.computeMillis(false,  text));  return  newPos  +  1;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    instant.setMillis(bucket.computeMillis(false,  text));  return  newPos  +  1;	  	non-compiled	[CE]  unreachable  statement	12	None	add
378	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  long  instantMillis  =  chrono.computeMillis(false,  text));  return  newPos;  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  long  instantMillis  =  chrono.computeMillis(false,  text));  return  newPos;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    long  instantMillis  =  chrono.computeMillis(false,  text));  return  newPos;	  	non-compiled	[CE]  ';'  expected	12	None	add
379	[BUG]  [BUGGY]  instant.setChrono(chrono);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  instant.setChrono(chrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	instant.setChrono(chrono);	      	non-compiled	[CE]  cannot  find  symbol	25	None	replace
380	[BUG]  [BUGGY]  newPos  =  chrono.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  newPos  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	newPos  =  chrono.parseInto(bucket,  text,  position);	      	non-compiled	[CE]  cannot  find  symbol	25	None	replace
381	[BUG]  [BUGGY]  iChrono  =  chrono.withZone(parsedZone);  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  iChrono  =  chrono.withZone(parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	iChrono  =  chrono.withZone(parsedZone);	      	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	25	None	replace
382	[BUG]  [BUGGY]  instant.setChrono(iChrono);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  instant.setChrono(iChrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	instant.setChrono(iChrono);	      	non-compiled	[CE]  cannot  find  symbol	25	None	replace
383	[BUG]  [BUGGY]  iChrono  =  bucket.getChronology();  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  iChrono  =  bucket.getChronology();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	iChrono  =  bucket.getChronology();	      	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	25	None	replace
384	[BUG]  [BUGGY]  chrono  =  chrono.withZone(instant.getChronology());  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(instant.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(instant.getChronology());	  chrono    =    chrono.withZone(bucket.getChronology());    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	22	None	replace
385	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getChronology(),  bucket);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getChronology(),  bucket);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getChronology(),  bucket);	  chrono    =    chrono.withZone(bucket.getChronology());    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	22	None	replace
386	[BUG]  [BUGGY]  chrono  =  chrono.withZone(instant,  bucket.getChronology());  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(instant,  bucket.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(instant,  bucket.getChronology());	  chrono    =    chrono.withZone(bucket.getChronology());    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	22	None	replace
387	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffset());  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffset());  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffset());  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	38	None	replace
388	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getInstant());  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getInstant());  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getInstant());  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	38	None	replace
389	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	38	None	replace
390	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffsetInteger());  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffsetInteger());  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffsetInteger());  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	38	None	replace
391	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  newPos);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  newPos);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  newPos);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	38	None	replace
392	[BUG]  [BUGGY]  chrono  =  iChrono.withZone(chrono.getZone());  [timeout]  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  iChrono.withZone(chrono.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  iChrono.withZone(chrono.getZone());	  chrono    =    iChrono.withZone(bucket.getZone());    [timeout]    	non-compiled	[timeout]	27	None	replace
393	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket);  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket);  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket);  newPos  =  chrono.parseInto(bucket,  text,  position);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	39	None	replace
394	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getInstant());  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getInstant());  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getInstant());  newPos  =  chrono.parseInto(bucket,  text,  position);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    }    	non-compiled	[CE]  cannot  find  symbol	39	None	replace
395	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffsetInteger());  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffsetInteger());  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffsetInteger());  newPos  =  chrono.parseInto(bucket,  text,  position);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	39	None	replace
396	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffset());  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffset());  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffset());  newPos  =  chrono.parseInto(bucket,  text,  position);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	39	None	replace
397	[BUG]  [BUGGY]  Chronology  chrono  =  iChrono.withZone(chrono);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  iChrono.withZone(chrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  iChrono.withZone(chrono);	  chrono    =    chrono.withZone(iChrono.getZone());    [timeout]    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	28	None	replace
398	[BUG]  [BUGGY]  newPos  =  text.parseInto(bucket,  parsedZone,  position);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  text.parseInto(bucket,  parsedZone,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  text.parseInto(bucket,  parsedZone,  position);	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	36	None	replace
399	[BUG]  [BUGGY]  chrono  =  chrono.withLocal(timeZone.getZone());  [CE]  cannot  find  symbol  timeZone  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withLocal(timeZone.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withLocal(timeZone.getZone());	  chrono    =    chrono.withLocal(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol  timeZone	23	None	replace
400	[BUG]  [BUGGY]  chrono  =  chrono.withLocal(middle.getZone());  [CE]  cannot  find  symbol  middle  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withLocal(middle.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withLocal(middle.getZone());	  chrono    =    chrono.withLocal(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol  middle	23	None	replace
401	[BUG]  [BUGGY]  chrono  =  chrono.withLocal(parsedZone.getTimeZone());  [CE]  cannot  find  symbol  parsedZone  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withLocal(parsedZone.getTimeZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withLocal(parsedZone.getTimeZone());	  chrono    =    chrono.withLocal(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	23	None	replace
402	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(iZone.getChronology());  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(iZone.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(iZone.getChronology());	  chrono    =    chrono.withChronology(parsedZone.getChronology());    	non-compiled	[CE]  cannot  find  symbol	17	None	replace
403	[BUG]  [BUGGY]  Chronology  chrono  =  chrono.withChronology(bucket.getChronology());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  chrono.withChronology(bucket.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  chrono.withChronology(bucket.getChronology());	  chrono    =    chrono.withChronology(parsedZone.getChronology());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	17	None	replace
404	[BUG]  [BUGGY]  Chronology  chrono  =  chrono.withChronology(iChrono.getChronology());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  chrono.withChronology(iChrono.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  chrono.withChronology(iChrono.getChronology());	  chrono    =    chrono.withChronology(parsedZone.getChronology());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	17	None	replace
405	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(iParsedZone.getChronology());  [CE]  cannot  find  symbol  iParsedZone  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(iParsedZone.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(iParsedZone.getChronology());	  chrono    =    chrono.withChronology(parsedZone.getChronology());    	non-compiled	[CE]  cannot  find  symbol  iParsedZone	17	None	replace
406	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getMillis());  bucket.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getMillis());  bucket.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getMillis());  bucket.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	31	None	replace
407	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffset());  bucket.setMillis(bucket.computeMillis(false,  text));  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffset());  bucket.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffset());  bucket.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	31	None	replace
408	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffsetInteger());  bucket.setMillis(bucket.computeMillis(false,  text));  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffsetInteger());  bucket.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getOffsetInteger());  bucket.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	31	None	replace
409	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getInstant());  bucket.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getInstant());  bucket.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getInstant());  bucket.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	31	None	replace
410	[BUG]  [BUGGY]  instant.setPos(bucket.computePosition(0,  parsedOffset));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setPos(bucket.computePosition(0,  parsedOffset));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setPos(bucket.computePosition(0,  parsedOffset));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
411	[BUG]  [BUGGY]  instant.setPos(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setPos(bucket.computeMillis(true,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setPos(bucket.computeMillis(true,  text));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
412	[BUG]  [BUGGY]  instant.setPos(bucket.computePosition(parsedOffset,  chrono));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setPos(bucket.computePosition(parsedOffset,  chrono));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setPos(bucket.computePosition(parsedOffset,  chrono));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
413	[BUG]  [BUGGY]  instant.setPos(bucket.computePosition(0,  chrono));  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setPos(bucket.computePosition(0,  chrono));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setPos(bucket.computePosition(0,  chrono));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
414	[BUG]  [BUGGY]  newPos  =  text.parseInto(bucket,  position,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  text.parseInto(bucket,  position,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  text.parseInto(bucket,  position,  iChrono);  instant.setMillis(bucket.computeMillis(false,  text));	      newPos    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	33	None	replace
415	[BUG]  [BUGGY]  iChrono  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  iChrono  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	iChrono  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      newPos    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	33	None	replace
416	[BUG]  [BUGGY]  if(iChrono!=  null)  {  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  chrono  =  chrono.withZone(parsedZone);  }  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  chrono  =  chrono.withZone(parsedZone);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  chrono  =  chrono.withZone(parsedZone);  }	      newPos    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	33	None	replace
417	[BUG]  [BUGGY]  chrono  =  chrono.withZone(parsedZone,  bucket.getOffsetInteger());  [CE]  cannot  find  symbol  parsedZone  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(parsedZone,  bucket.getOffsetInteger());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(parsedZone,  bucket.getOffsetInteger());	  chrono    =    chrono.withZone(parsedZone,    bucket.getZone());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	44	None	replace
418	[BUG]  [BUGGY]  chrono  =  chrono.withZone(parsedZone,  bucket.getOffset());  [CE]  cannot  find  symbol  parsedZone  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(parsedZone,  bucket.getOffset());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(parsedZone,  bucket.getOffset());	  chrono    =    chrono.withZone(parsedZone,    bucket.getZone());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	44	None	replace
419	[BUG]  [BUGGY]  chrono  =  chrono.withZone(iZone,  bucket.getZone());  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(iZone,  bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(iZone,  bucket.getZone());	  chrono    =    chrono.withZone(parsedZone,    bucket.getZone());    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	44	None	replace
420	[BUG]  [BUGGY]  chrono  =  chrono.withZone(instant,  bucket.getZone());  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(instant,  bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(instant,  bucket.getZone());	  chrono    =    chrono.withZone(parsedZone,    bucket.getZone());    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	44	None	replace
421	[BUG]  [BUGGY]  if(iOffsetParsed  &&  parsedZone!=  null)  {  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iOffsetParsed  &&  parsedZone!=  null)  {  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iOffsetParsed  &&  parsedZone!=  null)  {  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setZone(parsedZone);    }    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
422	[BUG]  [BUGGY]  if(iOffsetParsed  &&  parsedZone!=  null)  {  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZ  [CE]  ')'  expected  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iOffsetParsed  &&  parsedZone!=  null)  {  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZ  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iOffsetParsed  &&  parsedZone!=  null)  {  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZ	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setZone(parsedZone);    }    	non-compiled	[CE]  ')'  expected	37	None	replace
423	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(iChrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	        instant.setChronology(chrono);    instant.setChronology(iChrono);	  	compilable	  [FE]  AssertionFailedError  	3	7	add
424	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setChronology(iChrono);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setChronology(iChrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setChronology(iChrono);	  	compilable	  [FE]  AssertionFailedError  	3	7	add
425	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(iChrono);  [CE]  no  suitable  method  found  for  setMillis(Chronology)  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(iChrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(iChrono);	  	non-compiled	[CE]  no  suitable  method  found  for  setMillis(Chronology)	3	None	add
426	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setZone(parsedZone);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	        instant.setChronology(chrono);    instant.setZone(parsedZone);	  	compilable	  [FE]  AssertionFailedError  	3	7	add
427	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setZone(parsedZone);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setZone(parsedZone);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setZone(parsedZone);	  	compilable	  [FE]  AssertionFailedError  	3	7	add
428	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(chrono));  [CE]  no  suitable  method  found  for  setMillis(Chronology)  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(chrono));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(selectChronology(chrono));	  	non-compiled	[CE]  no  suitable  method  found  for  setMillis(Chronology)	3	None	add
429	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setParsed(true);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setParsed(true);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setParsed(true);	  	non-compiled	[CE]  cannot  find  symbol	3	None	add
430	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(bucket,  text,  position));  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(bucket,  text,  position));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(selectChronology(bucket,  text,  position));	  	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	3	None	add
431	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(instantLocal,  parsedOffset));  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(instantLocal,  parsedOffset));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(selectChronology(instantLocal,  parsedOffset));	  	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	3	None	add
432	[BUG]  [BUGGY]  chrono  =  new  ReadWritableInstant(instant.getChronology());  [CE]  ReadWritableInstant  is  abstract;  cannot  be  instantiated  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  new  ReadWritableInstant(instant.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  new  ReadWritableInstant(instant.getChronology());	  chrono    =    chrono.withUTC();    	non-compiled	[CE]  ReadWritableInstant  is  abstract;  cannot  be  instantiated	41	None	replace
433	[BUG]  [BUGGY]  chrono  =  new  ReadWritableInstant(instant.getChronology(),  parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  new  ReadWritableInstant(instant.getChronology(),  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  new  ReadWritableInstant(instant.getChronology(),  parsedZone);	  chrono    =    chrono.withUTC();    	non-compiled	[CE]  cannot  find  symbol  parsedZone	41	None	replace
434	[BUG]  [BUGGY]  chrono  =  new  ReadWritableInstant(instant,  iChrono,  iLocale,  parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  new  ReadWritableInstant(instant,  iChrono,  iLocale,  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  new  ReadWritableInstant(instant,  iChrono,  iLocale,  parsedZone);	  chrono    =    chrono.withUTC();    	non-compiled	[CE]  cannot  find  symbol  parsedZone	41	None	replace
435	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.withChronology(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.withChronology(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.withChronology(bucket,  text,  position);	  	non-compiled	[CE]  cannot  find  symbol	5	None	add
436	[BUG]  [BUGGY]  iChrono.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  iChrono.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	iChrono.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    chrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
437	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iChrono  =  parsedZone;  [CE]  cannot  assign  a  value  to  final  variable  iChrono  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  iChrono  =  parsedZone;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  iChrono  =  parsedZone;	      instant.setMillis(bucket.computeMillis(false,    text));    iChrono    =    parsedZone;    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iChrono	10	None	replace
438	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(iZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	add	chrono  =  chrono.withZone(iZone);	  chrono    =    chrono.withZone(parsedZone);    	compilable	  [FE]  AssertionFailedError  	16	8	replace
439	[BUG]  [BUGGY]  chrono  =  chrono.withZone(iZone);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(iZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(iZone);	  chrono    =    chrono.withZone(parsedZone);    	compilable	  [FE]  AssertionFailedError  	16	8	replace
440	[BUG]  [BUGGY]  chrono  =  chrono.withZone(position);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(position);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(position);	  chrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	16	None	replace
441	[BUG]  [BUGGY]  chrono  =  chrono.withZone(instant);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(instant);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(instant);	  chrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	16	None	replace
442	[BUG]  [BUGGY]  newPos  =  byser.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  byser  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  byser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  byser.parseInto(bucket,  text,  position);	      newPos    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol  byser	32	None	replace
443	[BUG]  [BUGGY]  parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  [CE]  no  suitable  method  found  for  getOffset()  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position,  iLocale);	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  no  suitable  method  found  for  getOffset()	8	None	replace
444	[BUG]  [BUGGY]  iOffsetParsed  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  assign  a  value  to  final  variable  iOffsetParsed  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  iOffsetParsed  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	iOffsetParsed  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iOffsetParsed	8	None	replace
445	[BUG]  [BUGGY]  ParsedZone  parsedZone  =  bucket.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  ParsedZone  parsedZone  =  bucket.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	ParsedZone  parsedZone  =  bucket.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	8	None	replace
446	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  minute.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  minute  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  minute.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    minute.setMillis(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  minute	1	None	add
447	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  Text));  [CE]  cannot  find  symbol  Text  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(false,  Text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(false,  Text));	  	non-compiled	[CE]  cannot  find  symbol  Text	1	None	add
448	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.withZone(chrono);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.withZone(chrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.withZone(chrono);	  Chronology    chrono    =    bucket.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	replace
449	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.withZone(iChrono);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.withZone(iChrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.withZone(iChrono);	  Chronology    chrono    =    bucket.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	replace
450	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.withChronology(iChrono);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.withChronology(iChrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.withChronology(iChrono);	  Chronology    chrono    =    bucket.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	replace
451	[BUG]  [BUGGY]  Chronology  chrono  =  getChronology(bucket.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  getChronology(bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  getChronology(bucket.getZone());	  Chronology    chrono    =    bucket.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	replace
452	[BUG]  [BUGGY]  Chronology  chrono  =  iChrono.withZone(bucket.getLocale());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  iChrono.withZone(bucket.getLocale());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  iChrono.withZone(bucket.getLocale());	  Chronology    chrono    =    iChrono.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	18	None	replace
453	[BUG]  [BUGGY]  Chronology  chrono  =  iChrono.withZone(parsedZone,  bucket.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  iChrono.withZone(parsedZone,  bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  iChrono.withZone(parsedZone,  bucket.getZone());	  Chronology    chrono    =    iChrono.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	18	None	replace
454	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  iLocale  =  chrono;  [CE]  cannot  assign  a  value  to  final  variable  iLocale  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  iLocale  =  chrono;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text));  iLocale  =  chrono;	      instant.setMillis(bucket.computeMillis(false,    text));    iLocale    =    locale;    	non-compiled	[CE]  cannot  assign  a  value  to  final  variable  iLocale	11	None	replace
455	[BUG]  [BUGGY]  instant.setPos(chrono.parseInto(bucket,  text,  position));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setPos(chrono.parseInto(bucket,  text,  position));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setPos(chrono.parseInto(bucket,  text,  position));	      instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
456	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  return  0;  [CE]  unreachable  statement  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(true,  text));  return  0;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(true,  text));  return  0;	      instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    	non-compiled	[CE]  unreachable  statement	13	None	replace
457	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  iOffsetParsed);  [CE]  no  suitable  method  found  for  setMillis(long,boolean)  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  iOffsetParsed);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  iOffsetParsed);	      instant.setMillis(instant.computeMillis(false,    text));    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,boolean)	47	None	replace
458	[BUG]  [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parsedZone.parseInto(bucket,  text,  position,  chrono);  instant.setMillis(bucket.computeMillis(false,  text));	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	34	None	replace
459	[BUG]  [BUGGY]  newPos  =  text.parseInto(bucket,  position,  parsedZone);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  text.parseInto(bucket,  position,  parsedZone);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  text.parseInto(bucket,  position,  parsedZone);  instant.setMillis(bucket.computeMillis(false,  text));	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	34	None	replace
460	[BUG]  [BUGGY]  chrono  =  chrono.withZone(instant,  iChrono);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(instant,  iChrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(instant,  iChrono);	  chrono    =    chrono.withZone(chrono);    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	29	None	replace
461	[BUG]  [BUGGY]  chrono  =  chrono.withZone(chrono,  iChrono);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(chrono,  iChrono);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(chrono,  iChrono);	  chrono    =    chrono.withZone(chrono);    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	29	None	replace
462	[BUG]  [BUGGY]  chrono  =  chrono.withZone(newPos,  parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(newPos,  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(newPos,  parsedZone);	  chrono    =    chrono.withZone(chrono);    	non-compiled	[CE]  cannot  find  symbol  parsedZone	29	None	replace
463	[BUG]  [BUGGY]  chrono  =  chrono.withZone(timeZone.getChronology());  [CE]  cannot  find  symbol  timeZone  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(timeZone.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(timeZone.getChronology());	  chrono    =    chrono.withZone(parsedZone.getChronology());    	non-compiled	[CE]  cannot  find  symbol  timeZone	20	None	replace
464	[BUG]  [BUGGY]  chrono  =  chrono.withZone(separator.getChronology());  [CE]  cannot  find  symbol  separator  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(separator.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(separator.getChronology());	  chrono    =    chrono.withZone(parsedZone.getChronology());    	non-compiled	[CE]  cannot  find  symbol  separator	20	None	replace
465	[BUG]  [BUGGY]  chrono  =  chrono.withZone(jp.getChronology());  [CE]  cannot  find  symbol  jp  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(jp.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(jp.getChronology());	  chrono    =    chrono.withZone(parsedZone.getChronology());    	non-compiled	[CE]  cannot  find  symbol  jp	20	None	replace
466	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(bucket.getChronology(),  parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(bucket.getChronology(),  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(bucket.getChronology(),  parsedZone);	  chrono    =    chrono.withChronology(bucket.getChronology());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	21	None	replace
467	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(bucket.getChronology(),  bucket.getChronology());  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(bucket.getChronology(),  bucket.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(bucket.getChronology(),  bucket.getChronology());	  chrono    =    chrono.withChronology(bucket.getChronology());    	non-compiled	[CE]  cannot  find  symbol	21	None	replace
468	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(bucket,  bucket.getChronology());  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(bucket,  bucket.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(bucket,  bucket.getChronology());	  chrono    =    chrono.withChronology(bucket.getChronology());    	non-compiled	[CE]  cannot  find  symbol	21	None	replace
469	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(bucket.getChronology(),  bucket.getZone());  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(bucket.getChronology(),  bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(bucket.getChronology(),  bucket.getZone());	  chrono    =    chrono.withChronology(bucket.getChronology());    	non-compiled	[CE]  cannot  find  symbol	21	None	replace
470	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getLocalMillis(),  parsedZone);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getLocalMillis(),  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getLocalMillis(),  parsedZone);	  chrono    =    chrono.withZone(bucket.getLocalMillis());    	non-compiled	[CE]  cannot  find  symbol	43	None	replace
471	[BUG]  [BUGGY]  chrono  =  chrono.withZone(parsedZone.getLocalMillis());  [CE]  cannot  find  symbol  parsedZone  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(parsedZone.getLocalMillis());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(parsedZone.getLocalMillis());	  chrono    =    chrono.withZone(bucket.getLocalMillis());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	43	None	replace
472	[BUG]  [BUGGY]  chrono  =  chrono.withZone(parsedZone,  bucket.getLocalMillis());  [CE]  cannot  find  symbol  parsedZone  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(parsedZone,  bucket.getLocalMillis());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(parsedZone,  bucket.getLocalMillis());	  chrono    =    chrono.withZone(bucket.getLocalMillis());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	43	None	replace
473	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getLocalMillis(),  position);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getLocalMillis(),  position);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getLocalMillis(),  position);	  chrono    =    chrono.withZone(bucket.getLocalMillis());    	non-compiled	[CE]  cannot  find  symbol	43	None	replace
474	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket,  bucket.getLocalMillis());  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket,  bucket.getLocalMillis());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket,  bucket.getLocalMillis());	  chrono    =    chrono.withZone(bucket.getLocalMillis());    	non-compiled	[CE]  cannot  find  symbol	43	None	replace
475	[BUG]  [BUGGY]  chrono  =  chrono.withTimeZone(bucket.getZone());  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withTimeZone(bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withTimeZone(bucket.getZone());	  chrono    =    chrono.withZone(iChrono.getZone());    [timeout]    	non-compiled	[CE]  cannot  find  symbol	28	None	replace
476	[BUG]  [BUGGY]  chrono  =  chrono.withoutZone(bucket.getZone());  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withoutZone(bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withoutZone(bucket.getZone());	  chrono    =    chrono.withZone(iChrono.getZone());    [timeout]    	non-compiled	[CE]  cannot  find  symbol	28	None	replace
477	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  }  [CE]  illegal  start  of  type  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  }	  	non-compiled	[CE]  illegal  start  of  type	12	None	add
478	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  instant.setPos(bucket.computeMillis(false,  text));  return  newPos;  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  instant.setPos(bucket.computeMillis(false,  text));  return  newPos;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    instant.setPos(bucket.computeMillis(false,  text));  return  newPos;	  	non-compiled	[CE]  cannot  find  symbol	12	None	add
479	[BUG]  [BUGGY]  newPos  =  iChrono.parseInto(bucket,  text,  position,  chrono);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  iChrono.parseInto(bucket,  text,  position,  chrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  iChrono.parseInto(bucket,  text,  position,  chrono);	      newPos    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	32	None	replace
480	[BUG]  [BUGGY]  newPos  =  text.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  text.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  text.parseInto(bucket,  text,  position);	      newPos    =    iChrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	32	None	replace
481	[BUG]  [BUGGY]  if(iChrono!=  chrono)  {  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  chrono)  {  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  chrono)  {  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      newPos    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	33	None	replace
482	[BUG]  [BUGGY]  newPos  =  parseder.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  parseder  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parseder.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parseder.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      newPos    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol  parseder	33	None	replace
483	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  chrono)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	if(iChrono!=  chrono)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      newPos    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	compilable	  [FE]  AssertionFailedError  	33	8	replace
484	[BUG]  [BUGGY]  if(iChrono!=  chrono)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  chrono)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  chrono)  {  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      newPos    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	compilable	  [FE]  AssertionFailedError  	33	8	replace
485	[BUG]  [BUGGY]  if(iChrono!=  null)  {  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      newPos    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	33	None	replace
486	[BUG]  [BUGGY]  if(iChrono!=  chrono)  {  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  chrono  =  chrono.withZone(parsedZone);  }  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  chrono)  {  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  chrono  =  chrono.withZone(parsedZone);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  chrono)  {  newPos  =  iChrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  else  {  chrono  =  chrono.withZone(parsedZone);  }	      newPos    =    iChrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	33	None	replace
487	[BUG]  [BUGGY]  instant.setSeparator(bucket.computeSeparator(true,  text));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setSeparator(bucket.computeSeparator(true,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setSeparator(bucket.computeSeparator(true,  text));	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
488	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  chrono);  [CE]  no  suitable  method  found  for  setMillis(long,Chronology)  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  chrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  chrono);	      instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,Chronology)	2	None	replace
489	[BUG]  [BUGGY]  int  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  int  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	int  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));	      	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	25	None	replace
490	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);	      	non-compiled	[CE]  cannot  find  symbol	25	None	replace
491	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	add	instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;	      	compilable	  [FE]  AssertionFailedError  	25	12	replace
492	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	instant.setMillis(bucket.computeMillis(false,  text));  return  newPos;	      	compilable	  [FE]  AssertionFailedError  	25	12	replace
493	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.withZone(instantLocal);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.withZone(instantLocal);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  chrono.withZone(instantLocal);	      	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	25	None	replace
494	[BUG]  [BUGGY]  instant.setMillis(parser.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(parser.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(parser.computeMillis(true,  text));  newPos  =  parser.parseInto(bucket,  text,  position);	      instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	6	None	replace
495	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getChronology(),  instant);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getChronology(),  instant);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getChronology(),  instant);	  chrono    =    chrono.withZone(bucket.getChronology());    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	22	None	replace
496	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getChronology(),  position);  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getChronology(),  position);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getChronology(),  position);	  chrono    =    chrono.withZone(bucket.getChronology());    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	22	None	replace
497	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket,  bucket.getChronology());  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket,  bucket.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket,  bucket.getChronology());	  chrono    =    chrono.withZone(bucket.getChronology());    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	22	None	replace
498	[BUG]  [BUGGY]  chrono  =(chrono!=  null)?  chrono.withUTC()  :  new  ReadWritableInstant(instantLocal,  parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =(chrono!=  null)?  chrono.withUTC()  :  new  ReadWritableInstant(instantLocal,  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =(chrono!=  null)?  chrono.withUTC()  :  new  ReadWritableInstant(instantLocal,  parsedZone);	  chrono    =    chrono.withUTC();    	non-compiled	[CE]  cannot  find  symbol  parsedZone	41	None	replace
499	[BUG]  [BUGGY]  chrono  =(chrono!=  null)?  chrono.withUTC()  :  new  ReadWritableInstant(instantLocal,  chrono.getChronology());  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =(chrono!=  null)?  chrono.withUTC()  :  new  ReadWritableInstant(instantLocal,  chrono.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =(chrono!=  null)?  chrono.withUTC()  :  new  ReadWritableInstant(instantLocal,  chrono.getChronology());	  chrono    =    chrono.withUTC();    	non-compiled	[CE]  cannot  find  symbol	41	None	replace
500	[BUG]  [BUGGY]  chrono  =(chrono!=  null)?  chrono.withUTC()  :  parsedZone;  [CE]  cannot  find  symbol  parsedZone  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =(chrono!=  null)?  chrono.withUTC()  :  parsedZone;  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =(chrono!=  null)?  chrono.withUTC()  :  parsedZone;	  chrono    =    chrono.withUTC();    	non-compiled	[CE]  cannot  find  symbol  parsedZone	41	None	replace
501	[BUG]  [BUGGY]  chrono  =(chrono!=  null)?  chrono.withUTC()  :  new  ReadWritableInstant(instantLocal,  chrono.getZone());  [CE]  ReadWritableInstant  is  abstract;  cannot  be  instantiated  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =(chrono!=  null)?  chrono.withUTC()  :  new  ReadWritableInstant(instantLocal,  chrono.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =(chrono!=  null)?  chrono.withUTC()  :  new  ReadWritableInstant(instantLocal,  chrono.getZone());	  chrono    =    chrono.withUTC();    	non-compiled	[CE]  ReadWritableInstant  is  abstract;  cannot  be  instantiated	41	None	replace
502	[BUG]  [BUGGY]  Chronology  chrono  =  parsedZone.withChronology(bucket.getChronology());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  parsedZone.withChronology(bucket.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  parsedZone.withChronology(bucket.getChronology());	  chrono    =    chrono.withChronology(parsedZone.getChronology());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	17	None	replace
503	[BUG]  [BUGGY]  if(iOffsetParsed  &&  parsedZone.getOffset()!=  position)  {  parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  }  [CE]  no  suitable  method  found  for  getOffset()  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iOffsetParsed  &&  parsedZone.getOffset()!=  position)  {  parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iOffsetParsed  &&  parsedZone.getOffset()!=  position)  {  parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  }	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  no  suitable  method  found  for  getOffset()	8	None	replace
504	[BUG]  [BUGGY]  if(iOffsetParsed  &&  parsedZone.getOffset()!=  position)  {  parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  no  suitable  method  found  for  getOffset()  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iOffsetParsed  &&  parsedZone.getOffset()!=  position)  {  parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iOffsetParsed  &&  parsedZone.getOffset()!=  position)  {  parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text));  }	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  no  suitable  method  found  for  getOffset()	8	None	replace
505	[BUG]  [BUGGY]  if(iOffsetParsed  &&  parsedZone.getOffset()!=  position)  {  parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text)  [CE]  ')'  expected  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iOffsetParsed  &&  parsedZone.getOffset()!=  position)  {  parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text)  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iOffsetParsed  &&  parsedZone.getOffset()!=  position)  {  parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text)	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  ')'  expected	8	None	replace
506	[BUG]  [BUGGY]  if(iOffsetParsed  &&  parsedZone.getOffset()!=  position)  {  parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text  [CE]  ')'  expected  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iOffsetParsed  &&  parsedZone.getOffset()!=  position)  {  parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iOffsetParsed  &&  parsedZone.getOffset()!=  position)  {  parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position);  }  else  {  instant.setMillis(bucket.computeMillis(false,  text	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  ')'  expected	8	None	replace
507	[BUG]  [BUGGY]  parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position,  parsedOffset);  [CE]  no  suitable  method  found  for  getOffset()  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position,  parsedOffset);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	parsedOffset  =  parsedZone.getOffset();  newPos  =  parser.parseInto(bucket,  text,  position,  parsedOffset);	      parsedOffset    =    parsedZone.getOffset();    newPos    =    parser.parseInto(bucket,    text,    position);    	non-compiled	[CE]  no  suitable  method  found  for  getOffset()	8	None	replace
508	[BUG]  [BUGGY]  chrono  =  chrono.withZone(separator);  [CE]  cannot  find  symbol  separator  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(separator);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(separator);	  chrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  cannot  find  symbol  separator	16	None	replace
509	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  index);  [CE]  cannot  find  symbol  index  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getZone(),  index);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getZone(),  index);	  chrono    =    chrono.withZone(bucket.getZone(),    parsedZone);    	non-compiled	[CE]  cannot  find  symbol  index	42	None	replace
510	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  position);	      instant.setMillis(bucket.computeMillis(false,    text));    return    newPos;    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	13	None	replace
511	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  instant.setChrono(chrono.withZone(parsedZone);  [CE]  ')'  expected  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  instant.setChrono(chrono.withZone(parsedZone);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text));  instant.setChrono(chrono.withZone(parsedZone);	      instant.setMillis(bucket.computeMillis(false,    text));    iChrono    =    chrono.withZone(parsedZone);    	non-compiled	[CE]  ')'  expected	14	None	replace
512	[BUG]  [BUGGY]      int  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]      int  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	        int  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	  	non-compiled	[CE]  variable  newPos  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	24	None	add
513	[BUG]  [BUGGY]  chrono  =  chrono.withLocal(parsedZone,  bucket.getZone());  [CE]  cannot  find  symbol  parsedZone  [FE]                        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withLocal(parsedZone,  bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withLocal(parsedZone,  bucket.getZone());	  chrono    =    chrono.withLocal(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	23	None	replace
514	[BUG]  [BUGGY]  chrono  =  chrono.withLocal(separator.getZone());  [CE]  cannot  find  symbol  separator  [FE]                          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withLocal(separator.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withLocal(separator.getZone());	  chrono    =    chrono.withLocal(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol  separator	23	None	replace
515	[BUG]  [BUGGY]  chrono  =  chrono.withLocal(parsedZone.getTime());  [CE]  cannot  find  symbol  parsedZone  [FE]                            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withLocal(parsedZone.getTime());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withLocal(parsedZone.getTime());	  chrono    =    chrono.withLocal(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	23	None	replace
516	[BUG]  [BUGGY]  chrono  =  chrono.withLocal(tmp.getZone());  [CE]  cannot  find  symbol  tmp  [FE]                              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withLocal(tmp.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withLocal(tmp.getZone());	  chrono    =    chrono.withLocal(parsedZone.getZone());    	non-compiled	[CE]  cannot  find  symbol  tmp	23	None	replace
517	[BUG]  [BUGGY]  Chronology  chrono  =  instant.getChronology();  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  instant.getChronology();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  instant.getChronology();	  Chronology    chrono    =    bucket.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	replace
518	[BUG]  [BUGGY]  Chronology  chrono  =  bucket.withChronology(bucket.getZone());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  bucket.withChronology(bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  bucket.withChronology(bucket.getZone());	  Chronology    chrono    =    bucket.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	19	None	replace
519	[BUG]  [BUGGY]  if(newPos!=  0)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(newPos!=  0)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(newPos!=  0)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    }    	non-compiled	[CE]  cannot  find  symbol	39	None	replace
520	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  iChrono.selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  iChrono.selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  iChrono.selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    }    	non-compiled	[CE]  cannot  find  symbol	39	None	replace
521	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  parser.parseInto(bucket,  text,  position);  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [CE]  incompatible  types  [FE]                            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  parser.parseInto(bucket,  text,  position);  newPos  =  chrono.parseInto(bucket,  text,  position);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  parser.parseInto(bucket,  text,  position);  newPos  =  chrono.parseInto(bucket,  text,  position);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    }    	non-compiled	[CE]  incompatible  types	39	None	replace
522	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	        instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  iParser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	5	7	add
523	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  iParser.parseInto(bucket,  text,  position);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  iParser.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  iParser.parseInto(bucket,  text,  position);	  	compilable	  [FE]  AssertionFailedError  	5	7	add
524	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    newPos    =    parser.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(true,  text));  newPos  =  chrono.parseInto(bucket,  text,  position);	  	non-compiled	[CE]  cannot  find  symbol	5	None	add
525	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  bucket.getOffsetInteger();  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	parsedOffset  =  bucket.getOffsetInteger();	      parsedOffset    =    parsedZone.getOffset();    	compilable	  [FE]  AssertionFailedError  	7	8	replace
526	[BUG]  [BUGGY]  parsedOffset  =  bucket.getOffsetInteger();  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  parsedOffset  =  bucket.getOffsetInteger();  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	parsedOffset  =  bucket.getOffsetInteger();	      parsedOffset    =    parsedZone.getOffset();    	compilable	  [FE]  AssertionFailedError  	7	8	replace
527	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.setMillis(bucket.computeMillis(false,  text));  }  [CE]  ')'  expected  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  ')'  expected	31	None	replace
528	[BUG]  [BUGGY]  if(chrono!=  null)  {  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(chrono!=  null)  {  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(chrono!=  null)  {  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	31	None	replace
529	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket);  bucket.setMillis(bucket.computeMillis(false,  text));  }  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket);  bucket.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket);  bucket.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	31	None	replace
530	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(chrono),  iLocale,  iPivotYear,  iDefaultYear);  [CE]  no  suitable  method  found  for  setMillis(Chronology,Locale,Integer,int)  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(chrono),  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(selectChronology(chrono),  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  no  suitable  method  found  for  setMillis(Chronology,Locale,Integer,int)	3	None	add
531	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(selectChronology(instantLocal,  chrono),  iLocale,  iPivotYear,  iDefaultYear);	  	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	3	None	add
532	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(timeZone.computeMillis(false,  text));  [CE]  cannot  find  symbol  timeZone  [FE]        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(timeZone.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(timeZone.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol  timeZone	3	None	add
533	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(chrono),  iLocale,  iPivotYear);  [CE]  no  suitable  method  found  for  setMillis(Chronology,Locale,Integer)  [FE]          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(chrono),  iLocale,  iPivotYear);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(selectChronology(chrono),  iLocale,  iPivotYear);	  	non-compiled	[CE]  no  suitable  method  found  for  setMillis(Chronology,Locale,Integer)	3	None	add
534	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setZone(chrono);  [CE]  method  setZone  in  interface  ReadWritableInstant  cannot  be  applied  to  given  types;  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setZone(chrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setZone(chrono);	  	non-compiled	[CE]  method  setZone  in  interface  ReadWritableInstant  cannot  be  applied  to  given  types;	3	None	add
535	[BUG]  [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(instantLocal,  chrono));  [CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setChronology(chrono);  instant.setMillis(selectChronology(instantLocal,  chrono));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setChronology(chrono);    instant.setMillis(selectChronology(instantLocal,  chrono));	  	non-compiled	[CE]  method  selectChronology  in  class  DateTimeFormatter  cannot  be  applied  to  given  types;	3	None	add
536	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(fALSe,  text));  [CE]  cannot  find  symbol  fALSe  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setMillis(bucket.computeMillis(fALSe,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setMillis(bucket.computeMillis(fALSe,  text));	  	non-compiled	[CE]  cannot  find  symbol  fALSe	1	None	add
537	[BUG]  [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setPos(bucket.computeMillis(false,  text));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]      instant.setMillis(bucket.computeMillis(false,  text));  instant.setPos(bucket.computeMillis(false,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	        instant.setMillis(bucket.computeMillis(false,    text));    instant.setPos(bucket.computeMillis(false,  text));	  	non-compiled	[CE]  cannot  find  symbol	1	None	add
538	[BUG]  [BUGGY]  if(newPos!=  0)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(newPos!=  0)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(newPos!=  0)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	38	None	replace
539	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  iChrono.selectChronology(chrono);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  iChrono.selectChronology(chrono);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  iChrono.selectChronology(chrono);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	38	None	replace
540	[BUG]  [BUGGY]  if(newPos!=  iLocale)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [CE]  incomparable  types:  int  and  Locale  [FE]                          AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(newPos!=  iLocale)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(newPos!=  iLocale)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  incomparable  types:  int  and  Locale	38	None	replace
541	[BUG]  [BUGGY]  if(newPos!=  chrono)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [CE]  incomparable  types:  int  and  Chronology  [FE]                            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(newPos!=  chrono)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(newPos!=  chrono)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  incomparable  types:  int  and  Chronology	38	None	replace
542	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getInstance());  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]                              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getInstance());  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getInstance());  newPos  =  chrono.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	38	None	replace
543	[BUG]  [BUGGY]  chrono  =  iChrono.withZone(bucket.getChronology());  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  iChrono.withZone(bucket.getChronology());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  iChrono.withZone(bucket.getChronology());	  chrono    =    chrono.withZone(parsedZone.getChronology());    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	20	None	replace
544	[BUG]  [BUGGY]  chrono  =  chrono.withZone(parsedZone,  bucket.getLocale());  [CE]  cannot  find  symbol  parsedZone  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(parsedZone,  bucket.getLocale());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(parsedZone,  bucket.getLocale());	  chrono    =    chrono.withZone(parsedZone,    bucket.getZone());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	44	None	replace
545	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket,  bucket.getZone());  [CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket,  bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket,  bucket.getZone());	  chrono    =    chrono.withZone(parsedZone,    bucket.getZone());    	non-compiled	[CE]  method  withZone  in  class  Chronology  cannot  be  applied  to  given  types;	44	None	replace
546	[BUG]  [BUGGY]  chrono  =  chrono.withZone(parsedZone,  bucket.getInteger());  [CE]  cannot  find  symbol  parsedZone  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(parsedZone,  bucket.getInteger());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(parsedZone,  bucket.getInteger());	  chrono    =    chrono.withZone(parsedZone,    bucket.getZone());    	non-compiled	[CE]  cannot  find  symbol  parsedZone	44	None	replace
547	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  0)  {  newPos  =  parsedZone.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  0)  {  newPos  =  parsedZone.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iOffsetParsed  &&  bucket.getOffsetInteger()!=  0)  {  newPos  =  parsedZone.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	34	None	replace
548	[BUG]  [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  newPos  =  parsedZone.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	newPos  =  parsedZone.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(true,  text));	      newPos    =    parsedZone.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    	non-compiled	[CE]  cannot  find  symbol	34	None	replace
549	[BUG]  [BUGGY]  Chronology  chrono  =  iChrono.withZone(bucket.getPivot());  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  iChrono.withZone(bucket.getPivot());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  iChrono.withZone(bucket.getPivot());	  Chronology    chrono    =    iChrono.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	18	None	replace
550	[BUG]  [BUGGY]  Chronology  chrono  =  iChrono.withZone(bucket.getZone(),  position);  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  iChrono.withZone(bucket.getZone(),  position);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  iChrono.withZone(bucket.getZone(),  position);	  Chronology    chrono    =    iChrono.withZone(bucket.getZone());    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	18	None	replace
551	[BUG]  [BUGGY]  instant.setMillis(selectChronology(chrono),  chrono);  [CE]  no  suitable  method  found  for  setMillis(Chronology,Chronology)  [FE]    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(selectChronology(chrono),  chrono);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(selectChronology(chrono),  chrono);	      instant.setChronology(chrono);    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(Chronology,Chronology)	4	None	replace
552	[BUG]  [BUGGY]  instant.setMillis(selectChronology(chrono),  iLocale);  [CE]  no  suitable  method  found  for  setMillis(Chronology,Locale)  [FE]      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(selectChronology(chrono),  iLocale);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(selectChronology(chrono),  iLocale);	      instant.setChronology(chrono);    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(Chronology,Locale)	4	None	replace
553	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  chrono  =  chrono;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	add	instant.setMillis(bucket.computeMillis(false,  text));  chrono  =  chrono;	      instant.setMillis(bucket.computeMillis(false,    text));    iChrono    =    parsedZone;    	compilable	  [FE]  AssertionFailedError  	10	8	replace
554	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  chrono  =  chrono;  [FE]  AssertionFailedError  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text));  chrono  =  chrono;  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text));  chrono  =  chrono;	      instant.setMillis(bucket.computeMillis(false,    text));    iChrono    =    parsedZone;    	compilable	  [FE]  AssertionFailedError  	10	8	replace
555	[BUG]  [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  iDefaultYear);  [CE]  no  suitable  method  found  for  setMillis(long,int)  [FE]            AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(bucket.computeMillis(false,  text),  iDefaultYear);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(bucket.computeMillis(false,  text),  iDefaultYear);	      instant.setMillis(instant.computeMillis(false,    text));    	non-compiled	[CE]  no  suitable  method  found  for  setMillis(long,int)	47	None	replace
556	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket.getLocalMillis(),  bucket.getLocalMillis());  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket.getLocalMillis(),  bucket.getLocalMillis());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket.getLocalMillis(),  bucket.getLocalMillis());	  chrono    =    chrono.withZone(bucket.getLocalMillis());    	non-compiled	[CE]  cannot  find  symbol	43	None	replace
557	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(bucket.getZone(),  bucket.getZone());  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(bucket.getZone(),  bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(bucket.getZone(),  bucket.getZone());	  chrono    =    chrono.withChronology(bucket.getZone());    	non-compiled	[CE]  cannot  find  symbol	26	None	replace
558	[BUG]  [BUGGY]  if(iOffsetParsed  &&  bucket!=  null)  {  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iOffsetParsed  &&  bucket!=  null)  {  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iOffsetParsed  &&  bucket!=  null)  {  chrono  =  selectChronology(chrono);  bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setZone(parsedZone);    }    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
559	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getMillis());  bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getMillis());  bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.getMillis());  bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setZone(parsedZone);    }    	non-compiled	[CE]  cannot  find  symbol	37	None	replace
560	[BUG]  [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }  [CE]  ')'  expected  [FE]                        AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(iChrono!=  null)  {  chrono  =  selectChronology(chrono,  bucket.setMillis(bucket.computeMillis(false,  text));  }  else  {  instant.setZone(parsedZone);  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    bucket.setMillis(bucket.computeMillis(false,    text));    }    else    {    instant.setZone(parsedZone);    }    	non-compiled	[CE]  ')'  expected	37	None	replace
561	[BUG]  [BUGGY]  chrono  =  chrono.withZone(parsedZone,  instant);  [CE]  cannot  find  symbol  parsedZone  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(parsedZone,  instant);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(parsedZone,  instant);	  chrono    =    chrono.withZone(chrono);    	non-compiled	[CE]  cannot  find  symbol  parsedZone	29	None	replace
562	[BUG]  [BUGGY]  chrono  =  chrono.withZone(parsedZone,  instantLocal);  [CE]  cannot  find  symbol  parsedZone  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(parsedZone,  instantLocal);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(parsedZone,  instantLocal);	  chrono    =    chrono.withZone(chrono);    	non-compiled	[CE]  cannot  find  symbol  parsedZone	29	None	replace
563	[BUG]  [BUGGY]  chrono  =  chrono.withZone(bucket,  parsedZone);  [CE]  cannot  find  symbol  parsedZone  [FE]                  AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withZone(bucket,  parsedZone);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withZone(bucket,  parsedZone);	  chrono    =    chrono.withZone(chrono);    	non-compiled	[CE]  cannot  find  symbol  parsedZone	29	None	replace
564	[BUG]  [BUGGY]  chrono  =  chrono.withTime(bucket.getZone());  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withTime(bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withTime(bucket.getZone());	  chrono    =    iChrono.withZone(bucket.getZone());    [timeout]    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
565	[BUG]  [BUGGY]  Chronology  chrono  =  iChrono.withUTC();  [CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)  [FE]            AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  Chronology  chrono  =  iChrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	Chronology  chrono  =  iChrono.withUTC();	  chrono    =    iChrono.withZone(bucket.getZone());    [timeout]    	non-compiled	[CE]  variable  chrono  is  already  defined  in  method  parseInto(ReadWritableInstant,String,int)	27	None	replace
566	[BUG]  [BUGGY]  chrono  =  instant.withZone(bucket.getZone());  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  instant.withZone(bucket.getZone());  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  instant.withZone(bucket.getZone());	  chrono    =    iChrono.withZone(bucket.getZone());    [timeout]    	non-compiled	[CE]  cannot  find  symbol	27	None	replace
567	[BUG]  [BUGGY]  chrono  =  chrono.withChronology(chunk);  [CE]  cannot  find  symbol  chunk  [FE]                AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withChronology(chunk);  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono  =  chrono.withChronology(chunk);	  chrono    =    chrono.withChronology(chrono);    	non-compiled	[CE]  cannot  find  symbol  chunk	30	None	replace
568	[BUG]  [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text),  position);  newPos  =  chrono.parseInto(bucket,  text,  position);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant.setMillis(chrono.computeMillis(false,  text),  position);  newPos  =  chrono.parseInto(bucket,  text,  position);  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant.setMillis(chrono.computeMillis(false,  text),  position);  newPos  =  chrono.parseInto(bucket,  text,  position);	      instant.setMillis(iChrono.computeMillis(false,    text));    newPos    =    chrono.parseInto(bucket,    text,    position);    	non-compiled	[CE]  cannot  find  symbol	48	None	replace
569	[BUG]  [BUGGY]  instant  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  instant  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	instant  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  <identifier>  expected	35	None	replace
570	[BUG]  [BUGGY]  if(newPos!=  0)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(newPos!=  0)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(newPos!=  0)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
571	[BUG]  [BUGGY]  if(newPos!=  iLocale)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [CE]  incomparable  types:  int  and  Locale  [FE]                    AssertionFailedError    [CONTEXT]    chrono  =  selectChronology(chrono);  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);    [BUGGY]  if(newPos!=  iLocale)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }  [BUGGY]    }  else  if  (bucket.getZone()  !=  null)  {  chrono  =  chrono.withZone(bucket.getZone());  }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	716	716	7	replace	if(newPos!=  iLocale)  {  chrono  =  selectChronology(chrono);  newPos  =  chrono.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  }	      if(iChrono!=    null)    {    chrono    =    selectChronology(chrono);    newPos    =    chrono.parseInto(bucket,    text,    position);    instant.setMillis(bucket.computeMillis(false,    text));    }    	non-compiled	[CE]  incomparable  types:  int  and  Locale	35	None	replace
572	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  DateTimeParser  <?>  instant  =  chrono.withUTC();  [CE]  type  DateTimeParser  does  not  take  parameters  [FE]    AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  DateTimeParser  <?>  instant  =  chrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    DateTimeParser  <?>  instant  =  chrono.withUTC();	  	non-compiled	[CE]  type  DateTimeParser  does  not  take  parameters	40	None	add
573	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  DateTimeParser  <?>  parsedZone  =  chrono.withUTC();  [CE]  type  DateTimeParser  does  not  take  parameters  [FE]      AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  DateTimeParser  <?>  parsedZone  =  chrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    DateTimeParser  <?>  parsedZone  =  chrono.withUTC();	  	non-compiled	[CE]  type  DateTimeParser  does  not  take  parameters	40	None	add
574	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  parsedOffset  =  chrono.withUTC();  [CE]  cannot  find  symbol  parsedOffset  [FE]        AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  parsedOffset  =  chrono.withUTC();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    parsedOffset  =  chrono.withUTC();	  	non-compiled	[CE]  cannot  find  symbol  parsedOffset	40	None	add
575	[BUG]  [BUGGY]  chrono  =  chrono.withUTC();  DateTimeParser  <?>  parsedZone  =  bucket.getZone();  [CE]  type  DateTimeParser  does  not  take  parameters  [FE]          AssertionFailedError    [CONTEXT]    DateTimeParserBucket  bucket  =  new  DateTimeParserBucket(  instantLocal,  chrono,  iLocale,  iPivotYear,  iDefaultYear);  int  newPos  =  parser.parseInto(bucket,  text,  position);  instant.setMillis(bucket.computeMillis(false,  text));  if  (iOffsetParsed  &&  bucket.getOffsetInteger()  !=  null)  {  int  parsedOffset  =  bucket.getOffsetInteger();  DateTimeZone  parsedZone  =  DateTimeZone.forOffsetMillis(parsedOffset);  chrono  =  chrono.withZone(parsedZone);  }  else  if  (bucket.getZone()  !=  null)  {    [BUGGY]  chrono  =  chrono.withUTC();  DateTimeParser  <?>  parsedZone  =  bucket.getZone();  [BUGGY]    }  instant.setChronology(chrono);  if  (iZone  !=  null)  {  instant.setZone(iZone);  }  return  newPos;  }  [CLASS]  DateTimeFormatter  [METHOD]  parseInto  [RETURN_TYPE]  int  ReadWritableInstant  instant  String  text  int  position  [VARIABLES]  Locale  iLocale  locale  Integer  iPivotYear  pivotYear  DateTimeParser  iParser  parser  boolean  iOffsetParsed  offsetParsed  DateTimeParserBucket  bucket  ReadWritableInstant  instant  Chronology  chrono  iChrono  String  text  DateTimePrinter  iPrinter  printer  DateTimeZone  iZone  parsedZone  zone  int  defaultYear  iDefaultYear  newPos  offset  parsedOffset  pivotYear  position  long  instantLocal  instantMillis  	projects/Time16/src/main/java/org/joda/time/format/DateTimeFormatter.java	0.7071067811865476	717	717	7	replace	chrono    =    chrono.withUTC();    DateTimeParser  <?>  parsedZone  =  bucket.getZone();	  	non-compiled	[CE]  type  DateTimeParser  does  not  take  parameters	40	None	add
