bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); [FE] AssertionFailedError [CONTEXT] private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); if (constraintObj != null && constraintObj.isRecordType()) { [BUGGY] ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); [BUGGY] if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); [CLASS] TypeInference BooleanOutcomePair [METHOD] inferPropertyTypesToMatchConstraint [RETURN_TYPE] void  JSType type JSType constraint [VARIABLES] ReverseAbstractInterpreter reverseInterpreter ObjectType constraintObj objType AbstractCompiler compiler JSTypeRegistry registry JSType constraint propType type typeToInfer boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED BooleanLiteralSet booleanValues toBooleanOutcomes String prop Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	
2	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); if (constraintObj != null && constraintObj.isRecordType()) { [BUGGY] [BUGGY] ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); [CLASS] TypeInference BooleanOutcomePair [METHOD] inferPropertyTypesToMatchConstraint [RETURN_TYPE] void  JSType type JSType constraint [VARIABLES] ReverseAbstractInterpreter reverseInterpreter ObjectType constraintObj objType AbstractCompiler compiler JSTypeRegistry registry JSType constraint propType type typeToInfer boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED BooleanLiteralSet booleanValues toBooleanOutcomes String prop Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	add	
3	[BUG] [BUGGY] if (objType != null) { [FE] AssertionFailedError [CONTEXT] private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); if (constraintObj != null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); [BUGGY] if (objType != null) { [BUGGY] for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } [CLASS] TypeInference BooleanOutcomePair [METHOD] inferPropertyTypesToMatchConstraint [RETURN_TYPE] void  JSType type JSType constraint [VARIABLES] ReverseAbstractInterpreter reverseInterpreter ObjectType constraintObj objType AbstractCompiler compiler JSTypeRegistry registry JSType constraint propType type typeToInfer boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED BooleanLiteralSet booleanValues toBooleanOutcomes String prop Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1123	1123	1	replace	
4	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); if (constraintObj != null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); [BUGGY] [BUGGY] if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } [CLASS] TypeInference BooleanOutcomePair [METHOD] inferPropertyTypesToMatchConstraint [RETURN_TYPE] void  JSType type JSType constraint [VARIABLES] ReverseAbstractInterpreter reverseInterpreter ObjectType constraintObj objType AbstractCompiler compiler JSTypeRegistry registry JSType constraint propType type typeToInfer boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED BooleanLiteralSet booleanValues toBooleanOutcomes String prop Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1123	1123	1	add	
5	[BUG] [BUGGY] var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType)); [FE] AssertionFailedError [CONTEXT] valueType = getNativeType(UNKNOWN_TYPE); } objectType.defineInferredProperty(memberName, valueType, name);  if (qObjName != null && name.isString()) { String qKeyName = qObjName + "." + memberName; Var var = syntacticScope.getVar(qKeyName); JSType oldType = var == null ? null : var.getType(); if (var != null && var.isTypeInferred()) { [BUGGY] var.setType(oldType == null ?    valueType : oldType.getLeastSupertype(oldType)); [BUGGY] valueType : oldType.getLeastSupertype(oldType)); } scope.inferQualifiedSlot(name, qKeyName, oldType == null ? getNativeType(UNKNOWN_TYPE) : oldType, valueType); } } else { n.setJSType(getNativeType(UNKNOWN_TYPE)); } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.22360679774997896	692	693	1	replace	
6	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] valueType = getNativeType(UNKNOWN_TYPE); } objectType.defineInferredProperty(memberName, valueType, name);  if (qObjName != null && name.isString()) { String qKeyName = qObjName + "." + memberName; Var var = syntacticScope.getVar(qKeyName); JSType oldType = var == null ? null : var.getType(); if (var != null && var.isTypeInferred()) { [BUGGY] [BUGGY] var.setType(oldType == null ?    valueType : oldType.getLeastSupertype(oldType)); valueType : oldType.getLeastSupertype(oldType)); } scope.inferQualifiedSlot(name, qKeyName, oldType == null ? getNativeType(UNKNOWN_TYPE) : oldType, valueType); } } else { n.setJSType(getNativeType(UNKNOWN_TYPE)); } [CLASS] TypeInference BooleanOutcomePair [METHOD] traverseObjectLiteral [RETURN_TYPE] FlowScope  Node n FlowScope scope [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType oldType rawValueType type valueType Var var Node n name value BooleanLiteralSet booleanValues toBooleanOutcomes String memberName qKeyName qObjName ObjectType objectType AbstractCompiler compiler JSTypeRegistry registry boolean hasLendsName Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope functionScope informed input joinedScope leftScope newScope output rightScope scope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.22360679774997896	692	693	1	add	
