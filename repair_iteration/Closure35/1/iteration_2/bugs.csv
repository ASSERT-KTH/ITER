bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(type.getRecordType(),  constraintObj);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(type.getRecordType(),  constraintObj);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(type.getRecordType(),  constraintObj);	  ObjectType    objType    =    ObjectType.cast(type.getRecordType());    	non-compiled	[CE]  cannot  find  symbol	8	None	replace
2	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(type.getRecordType(),  constraint);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(type.getRecordType(),  constraint);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(type.getRecordType(),  constraint);	  ObjectType    objType    =    ObjectType.cast(type.getRecordType());    	non-compiled	[CE]  cannot  find  symbol	8	None	replace
3	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.getRecordType());  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.getRecordType());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(constraint.getRecordType());	  ObjectType    objType    =    ObjectType.cast(type.getRecordType());    	non-compiled	[CE]  cannot  find  symbol	8	None	replace
4	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(type.recordType());  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(type.recordType());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(type.recordType());	  ObjectType    objType    =    ObjectType.cast(type.getRecordType());    	non-compiled	[CE]  cannot  find  symbol	8	None	replace
5	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(type,  constraintObj.getRecordType());  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(type,  constraintObj.getRecordType());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(type,  constraintObj.getRecordType());	  ObjectType    objType    =    ObjectType.cast(type.getRecordType());    	non-compiled	[CE]  cannot  find  symbol	8	None	replace
6	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(recordObj.getRecordType());  [CE]  cannot  find  symbol  recordObj  [FE]                  AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(recordObj.getRecordType());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(recordObj.getRecordType());	  ObjectType    objType    =    ObjectType.cast(type.getRecordType());    	non-compiled	[CE]  cannot  find  symbol  recordObj	8	None	replace
7	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(record.restrictByNotNullOrUndefined());  [CE]  cannot  find  symbol  record  [FE]          AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(record.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(record.restrictByNotNullOrUndefined());	  ObjectType    objType    =    ObjectType.cast(recordObj.restrictByNotNullOrUndefined());    	non-compiled	[CE]  cannot  find  symbol  record	3	None	replace
8	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(scope.restrictByNotNullOrUndefined());  [CE]  cannot  find  symbol  scope  [FE]            AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(scope.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(scope.restrictByNotNullOrUndefined());	  ObjectType    objType    =    ObjectType.cast(recordObj.restrictByNotNullOrUndefined());    	non-compiled	[CE]  cannot  find  symbol  scope	3	None	replace
9	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(null,  constraint.restrictByNotNullOrUndefined());  [CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(null,  constraint.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(null,  constraint.restrictByNotNullOrUndefined());	  ObjectType    objType    =    ObjectType.cast(recordObj.restrictByNotNullOrUndefined());    	non-compiled	[CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;	3	None	replace
10	[BUG]  [BUGGY]  ObjectType  objType  =  constraintObj.getRecordType();  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  constraintObj.getRecordType();  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  constraintObj.getRecordType();	      	non-compiled	[CE]  cannot  find  symbol	7	None	replace
11	[BUG]  [BUGGY]  ObjectType  objType  =  constraintObj.getPropertyType(type);  [CE]  method  getPropertyType  in  class  ObjectType  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  constraintObj.getPropertyType(type);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  constraintObj.getPropertyType(type);	      	non-compiled	[CE]  method  getPropertyType  in  class  ObjectType  cannot  be  applied  to  given  types;	7	None	replace
12	[BUG]  [BUGGY]  ObjectType  propType  =  constraintObj.getPropertyType(type);  [CE]  method  getPropertyType  in  class  ObjectType  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  propType  =  constraintObj.getPropertyType(type);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  propType  =  constraintObj.getPropertyType(type);	      	non-compiled	[CE]  method  getPropertyType  in  class  ObjectType  cannot  be  applied  to  given  types;	7	None	replace
13	[BUG]  [BUGGY]  ObjectType  objType  =  constraintObj.getPropertyType(prop);  [CE]  cannot  find  symbol  prop  [FE]                      AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  constraintObj.getPropertyType(prop);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  constraintObj.getPropertyType(prop);	      	non-compiled	[CE]  cannot  find  symbol  prop	7	None	replace
14	[BUG]  [BUGGY]  ObjectType  typeToInfer  =  constraintObj.getRecordType();  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  typeToInfer  =  constraintObj.getRecordType();  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  typeToInfer  =  constraintObj.getRecordType();	      	non-compiled	[CE]  cannot  find  symbol	7	None	replace
15	[BUG]  [BUGGY]  ObjectType  objType  =  constraint.getRecordType();  [CE]  cannot  find  symbol  [FE]                          AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  constraint.getRecordType();  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  constraint.getRecordType();	      	non-compiled	[CE]  cannot  find  symbol	7	None	replace
16	[BUG]  [BUGGY]  Type  objType  =  constraintObj.getRecordType();  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  Type  objType  =  constraintObj.getRecordType();  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	Type  objType  =  constraintObj.getRecordType();	      	non-compiled	[CE]  cannot  find  symbol	7	None	replace
17	[BUG]  [BUGGY]  JSType  objType  =  ObjectType.cast(type.restrictByNotNullOrUndefined());  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  JSType  objType  =  ObjectType.cast(type.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	JSType  objType  =  ObjectType.cast(type.restrictByNotNullOrUndefined());	  ObjectType    objType    =    ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());    timeout    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
18	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(recordType.restrictByNotNullOrUndefined());  [CE]  cannot  find  symbol  recordType  [FE]              AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(recordType.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(recordType.restrictByNotNullOrUndefined());	  ObjectType    objType    =    ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());    timeout    	non-compiled	[CE]  cannot  find  symbol  recordType	5	None	replace
19	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(type.restrictByNotEmptyOrUndefined());  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(type.restrictByNotEmptyOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(type.restrictByNotEmptyOrUndefined());	  ObjectType    objType    =    ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());    timeout    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
20	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(type.restrictByNotNullOrUndefined(),  constraintObj,  constraint);  [CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(type.restrictByNotNullOrUndefined(),  constraintObj,  constraint);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(type.restrictByNotNullOrUndefined(),  constraintObj,  constraint);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraintObj);    	non-compiled	[CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;	6	None	replace
21	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined(),  type);  [CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined(),  type);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined(),  type);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraintObj);    	non-compiled	[CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;	6	None	replace
22	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined(),  type);  [CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined(),  type);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined(),  type);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraintObj);    	non-compiled	[CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;	6	None	replace
23	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined(),  constraintObj);  [CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined(),  constraintObj);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined(),  constraintObj);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraintObj);    	non-compiled	[CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;	6	None	replace
24	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(type.restrictByNotNullOrUndefined(),  constraintObj,  constraintType);  [CE]  cannot  find  symbol  constraintType  [FE]                      AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(type.restrictByNotNullOrUndefined(),  constraintObj,  constraintType);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(type.restrictByNotNullOrUndefined(),  constraintObj,  constraintType);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraintObj);    	non-compiled	[CE]  cannot  find  symbol  constraintType	6	None	replace
25	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constructor.restrictByNotNullOrUndefined(),  constraintObj);  [CE]  cannot  find  symbol  constructor  [FE]                        AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constructor.restrictByNotNullOrUndefined(),  constraintObj);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(constructor.restrictByNotNullOrUndefined(),  constraintObj);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraintObj);    	non-compiled	[CE]  cannot  find  symbol  constructor	6	None	replace
26	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(null,  constraintObj.restrictByNotNullOrUndefined(),  constraint);  [CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;  [FE]                          AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(null,  constraintObj.restrictByNotNullOrUndefined(),  constraint);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(null,  constraintObj.restrictByNotNullOrUndefined(),  constraint);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraintObj);    	non-compiled	[CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;	6	None	replace
27	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)  [FE]        AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType    objType    =    ObjectType.cast(constraint.restrictByNotNullOrUndefined());    ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());	  timeout    	non-compiled	[CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)	1	None	add
28	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  ObjectType  objtype  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)  [FE]          AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  ObjectType  objtype  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType    objType    =    ObjectType.cast(constraint.restrictByNotNullOrUndefined());    ObjectType  objtype  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());	  timeout    	non-compiled	[CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)	1	None	add
29	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  ObjectType  typeToInfer  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)  [FE]            AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  ObjectType  typeToInfer  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType    objType    =    ObjectType.cast(constraint.restrictByNotNullOrUndefined());    ObjectType  typeToInfer  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());	  timeout    	non-compiled	[CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)	1	None	add
30	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  PropertyType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  PropertyType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType    objType    =    ObjectType.cast(constraint.restrictByNotNullOrUndefined());    PropertyType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());	  timeout    	non-compiled	[CE]  cannot  find  symbol	1	None	add
31	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  ObjectType  constraint  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [CE]  variable  constraint  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)  [FE]                AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  ObjectType  constraint  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType    objType    =    ObjectType.cast(constraint.restrictByNotNullOrUndefined());    ObjectType  constraint  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());	  timeout    	non-compiled	[CE]  variable  constraint  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)	1	None	add
32	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  ObjectType  objectType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)  [FE]                  AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  ObjectType  objectType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType    objType    =    ObjectType.cast(constraint.restrictByNotNullOrUndefined());    ObjectType  objectType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());	  timeout    	non-compiled	[CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)	1	None	add
33	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined(),  constraint);  [CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined(),  constraint);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined(),  constraint);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraint);    	non-compiled	[CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;	9	None	replace
34	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(restrictByNotNullOrUndefined(),  constraintObj);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(restrictByNotNullOrUndefined(),  constraintObj);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(restrictByNotNullOrUndefined(),  constraintObj);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraint);    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
35	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  [CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)  [FE]            AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType    objType    =    ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());    ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());	  timeout    	non-compiled	[CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)	4	None	add
36	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  ObjectType  objtype  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  [CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)  [FE]              AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  ObjectType  objtype  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType    objType    =    ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());    ObjectType  objtype  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());	  timeout    	non-compiled	[CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)	4	None	add
37	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  ObjectType  typeToInfer  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  [CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)  [FE]                AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  ObjectType  typeToInfer  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType    objType    =    ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());    ObjectType  typeToInfer  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());	  timeout    	non-compiled	[CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)	4	None	add
38	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  ObjectType  resultObjType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  [CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)  [FE]                  AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  ObjectType  resultObjType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType    objType    =    ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());    ObjectType  resultObjType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());	  timeout    	non-compiled	[CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)	4	None	add
39	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  PropertyType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  PropertyType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType    objType    =    ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());    PropertyType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());	  timeout    	non-compiled	[CE]  cannot  find  symbol	4	None	add
40	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  ObjectType  objectType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  [CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)  [FE]                      AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  ObjectType  objectType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType    objType    =    ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());    ObjectType  objectType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());	  timeout    	non-compiled	[CE]  variable  objType  is  already  defined  in  method  inferPropertyTypesToMatchConstraint(JSType,JSType)	4	None	add
41	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(null,  constraintObj.restrictByNotNullOrUndefined());  [CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;  [FE]          AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(null,  constraintObj.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(null,  constraintObj.restrictByNotNullOrUndefined());	  ObjectType    objType    =    ObjectType.cast(recordObj.restrictByNotNullOrUndefined());    	non-compiled	[CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;	3	None	replace
42	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.getRecordType());  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.getRecordType());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(constraintObj.getRecordType());	  ObjectType    objType    =    ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());    timeout    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
43	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(restrictByNotNullOrUndefined());  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(restrictByNotNullOrUndefined());	  ObjectType    objType    =    ObjectType.cast(str.restrictByNotNullOrUndefined());    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
44	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(boolean.restrictByNotNullOrUndefined());  [CE]  class  expected  [FE]            AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(boolean.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(boolean.restrictByNotNullOrUndefined());	  ObjectType    objType    =    ObjectType.cast(str.restrictByNotNullOrUndefined());    	non-compiled	[CE]  class  expected	10	None	replace
45	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(restrictByNotNullOrUndefined(),  constraintObj,  constraint);  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(restrictByNotNullOrUndefined(),  constraintObj,  constraint);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(restrictByNotNullOrUndefined(),  constraintObj,  constraint);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraintObj);    	non-compiled	[CE]  cannot  find  symbol	6	None	replace
46	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(type.restrictByNotNullOrUndefined(),  constraintObj,  constraintObj);  [CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(type.restrictByNotNullOrUndefined(),  constraintObj,  constraintObj);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(type.restrictByNotNullOrUndefined(),  constraintObj,  constraintObj);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraintObj);    	non-compiled	[CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;	6	None	replace
47	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(type.restrictByNotNullOrUndefined(),  constraintObj,  type);  [CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(type.restrictByNotNullOrUndefined(),  constraintObj,  type);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(type.restrictByNotNullOrUndefined(),  constraintObj,  type);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraintObj);    	non-compiled	[CE]  method  cast  in  class  ObjectType  cannot  be  applied  to  given  types;	6	None	replace
48	[BUG]  [BUGGY]  ObjectType  objType  =  constraint.restrictByNotNullOrUndefined();  [CE]  incompatible  types  [FE]                AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  constraint.restrictByNotNullOrUndefined();  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  constraint.restrictByNotNullOrUndefined();	      	non-compiled	[CE]  incompatible  types	7	None	replace
49	[BUG]  [BUGGY]  ObjectType  objType  =  constraintObj.getInstanceType();  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  constraintObj.getInstanceType();  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  constraintObj.getInstanceType();	      	non-compiled	[CE]  cannot  find  symbol	7	None	replace
50	[BUG]  [BUGGY]  timeout  [FE]                    AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  constraintObj.getConstructor();  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	add	ObjectType  objType  =  constraintObj.getConstructor();	      	compilable	timeout	7	1	replace
51	[BUG]  [BUGGY]  ObjectType  objType  =  constraintObj.getConstructor();  timeout  [FE]                    AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  constraintObj.getConstructor();  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  constraintObj.getConstructor();	      	compilable	timeout	7	1	replace
52	[BUG]  [BUGGY]  ObjectType  objType  =  constraintObj.getObjectType();  [CE]  method  traverse  in  class  TypeInference  cannot  be  applied  to  given  types;  [FE]                      AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  constraintObj.getObjectType();  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  constraintObj.getObjectType();	      	non-compiled	[CE]  method  traverse  in  class  TypeInference  cannot  be  applied  to  given  types;	7	None	replace
53	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  ObjectType  ibjType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [CE]  method  traverse  in  class  TypeInference  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  ObjectType  ibjType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType    objType    =    ObjectType.cast(constraint.restrictByNotNullOrUndefined());    ObjectType  ibjType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());	  timeout    	non-compiled	[CE]  method  traverse  in  class  TypeInference  cannot  be  applied  to  given  types;	1	None	add
54	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constructType(type,  constraintObj));  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constructType(type,  constraintObj));  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(constructType(type,  constraintObj));	  ObjectType    objType    =    ObjectType.cast(constraint.restrictByNotNullOrUndefined());    timeout    	non-compiled	[CE]  class,  interface,  or  enum  expected	2	None	replace
55	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(strObj.restrictByNotNullOrUndefined(),  constraint);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(strObj.restrictByNotNullOrUndefined(),  constraint);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(strObj.restrictByNotNullOrUndefined(),  constraint);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraint);    	non-compiled	[CE]  class,  interface,  or  enum  expected	9	None	replace
56	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  ObjectType[]  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [CE]  variable  arg  is  already  defined  in  method  traverseNew(Node,FlowScope)  [FE]        AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  ObjectType[]  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType    objType    =    ObjectType.cast(constraint.restrictByNotNullOrUndefined());    ObjectType[]  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());	  timeout    	non-compiled	[CE]  variable  arg  is  already  defined  in  method  traverseNew(Node,FlowScope)	1	None	add
57	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  ObjectType  propType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [CE]  variable  arg  is  already  defined  in  method  traverseNew(Node,FlowScope)  [FE]          AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  ObjectType  propType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType    objType    =    ObjectType.cast(constraint.restrictByNotNullOrUndefined());    ObjectType  propType  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());	  timeout    	non-compiled	[CE]  variable  arg  is  already  defined  in  method  traverseNew(Node,FlowScope)	1	None	add
58	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(recordedPropertyType.restrictByNotNullOrUndefined());  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(recordedPropertyType.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(recordedPropertyType.restrictByNotNullOrUndefined());	  ObjectType    objType    =    ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());    timeout    	non-compiled	[CE]  class,  interface,  or  enum  expected	5	None	replace
59	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(null);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(null);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(null);	  ObjectType    objType    =    ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());    timeout    	non-compiled	[CE]  class,  interface,  or  enum  expected	5	None	replace
60	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(recordedPropertyType.restrictByNotNullOrUndefined(),  constraintObj);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(recordedPropertyType.restrictByNotNullOrUndefined(),  constraintObj);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(recordedPropertyType.restrictByNotNullOrUndefined(),  constraintObj);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraint);    	non-compiled	[CE]  class,  interface,  or  enum  expected	9	None	replace
61	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(null,  constraint.restrictByNotNullOrUndefined(),  constraint);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(null,  constraint.restrictByNotNullOrUndefined(),  constraint);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(null,  constraint.restrictByNotNullOrUndefined(),  constraint);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraint);    	non-compiled	[CE]  class,  interface,  or  enum  expected	9	None	replace
62	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(restricted.restrictByNotNullOrUndefined(),  constraintObj);  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(restricted.restrictByNotNullOrUndefined(),  constraintObj);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(restricted.restrictByNotNullOrUndefined(),  constraintObj);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraint);    	non-compiled	[CE]  class,  interface,  or  enum  expected	9	None	replace
63	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(restrictedPropertyType.restrictByNotNullOrUndefined(),  constraintObj);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(restrictedPropertyType.restrictByNotNullOrUndefined(),  constraintObj);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(restrictedPropertyType.restrictByNotNullOrUndefined(),  constraintObj);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraint);    	non-compiled	[CE]  class,  interface,  or  enum  expected	9	None	replace
64	[BUG]  [BUGGY]  ObjectType  propType  =  constraintObj.getPropertyType(prop);  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  propType  =  constraintObj.getPropertyType(prop);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  propType  =  constraintObj.getPropertyType(prop);	      	non-compiled	[CE]  class,  interface,  or  enum  expected	7	None	replace
65	[BUG]  [BUGGY]  ObjectType  propType  =  constraint.getPropertyType(prop);  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  propType  =  constraint.getPropertyType(prop);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  propType  =  constraint.getPropertyType(prop);	      	non-compiled	[CE]  class,  interface,  or  enum  expected	7	None	replace
66	[BUG]  [BUGGY]  JSType  propType  =  constraintObj.getPropertyType(prop);  [CE]  class,  interface,  or  enum  expected  [FE]                    AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  JSType  propType  =  constraintObj.getPropertyType(prop);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	JSType  propType  =  constraintObj.getPropertyType(prop);	      	non-compiled	[CE]  class,  interface,  or  enum  expected	7	None	replace
67	[BUG]  [BUGGY]  ObjectType  propType  =  constraintObj.getPropertyType();  [CE]  class,  interface,  or  enum  expected  [FE]                      AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  propType  =  constraintObj.getPropertyType();  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  propType  =  constraintObj.getPropertyType();	      	non-compiled	[CE]  class,  interface,  or  enum  expected	7	None	replace
68	[BUG]  [BUGGY]  ObjectType  propType  =  constraint.restrictByNotNullOrUndefined();  [CE]  class,  interface,  or  enum  expected  [FE]                        AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  propType  =  constraint.restrictByNotNullOrUndefined();  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  propType  =  constraint.restrictByNotNullOrUndefined();	      	non-compiled	[CE]  class,  interface,  or  enum  expected	7	None	replace
69	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(registry.restrictByNotNullOrUndefined());  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(registry.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(registry.restrictByNotNullOrUndefined());	  ObjectType    objType    =    ObjectType.cast(str.restrictByNotNullOrUndefined());    	non-compiled	[CE]  class,  interface,  or  enum  expected	10	None	replace
70	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  ObjectType[]  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  ObjectType[]  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType    objType    =    ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());    ObjectType[]  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());	  timeout    	non-compiled	[CE]  class,  interface,  or  enum  expected	4	None	add
71	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  ObjectType  propType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  ObjectType  propType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType    objType    =    ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());    ObjectType  propType  =  ObjectType.cast(constraintObj.restrictByNotNullOrUndefined());	  timeout    	non-compiled	[CE]  class,  interface,  or  enum  expected	4	None	add
72	[BUG]  [BUGGY]  ObjectType  objType  =  ObjectType.cast(registry.restrictByNotNullOrUndefined(),  constraintObj);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError    [CONTEXT]    private  void  inferPropertyTypesToMatchConstraint(  JSType  type,  JSType  constraint)  {  if  (type  ==  null  ||  constraint  ==  null)  {  return;  }  ObjectType  constraintObj  =  ObjectType.cast(constraint.restrictByNotNullOrUndefined());  if  (constraintObj  !=  null  &&  constraintObj.isRecordType())  {    [BUGGY]  ObjectType  objType  =  ObjectType.cast(registry.restrictByNotNullOrUndefined(),  constraintObj);  [BUGGY]    if  (objType  !=  null)  {  for  (String  prop  :  constraintObj.getOwnPropertyNames())  {  JSType  propType  =  constraintObj.getPropertyType(prop);  if  (!objType.isPropertyTypeDeclared(prop))  {  JSType  typeToInfer  =  propType;  if  (!objType.hasProperty(prop))  {  typeToInfer  =  getNativeType(VOID_TYPE).getLeastSupertype(propType);  }  objType.defineInferredProperty(prop,  typeToInfer,  null);  [CLASS]  TypeInference  BooleanOutcomePair  [METHOD]  inferPropertyTypesToMatchConstraint  [RETURN_TYPE]  void  JSType  type  JSType  constraint  [VARIABLES]  ReverseAbstractInterpreter  reverseInterpreter  ObjectType  constraintObj  objType  AbstractCompiler  compiler  JSTypeRegistry  registry  JSType  constraint  propType  type  typeToInfer  boolean  Scope  functionScope  syntacticScope  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  BooleanLiteralSet  booleanValues  toBooleanOutcomes  String  prop  Map  assertionFunctionsMap  FlowScope  bottomScope  conditionFlowScope  falseScope  functionScope  informed  input  joinedScope  leftScope  newScope  output  rightScope  scope  trueScope  	projects/Closure35/src/com/google/javascript/jscomp/TypeInference.java	0.30151134457776363	1122	1122	1	replace	ObjectType  objType  =  ObjectType.cast(registry.restrictByNotNullOrUndefined(),  constraintObj);	  ObjectType    objType    =    ObjectType.cast(type.restrictByNotNullOrUndefined(),    constraintObj);    	non-compiled	[CE]  class,  interface,  or  enum  expected	6	None	replace
