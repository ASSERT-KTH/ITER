bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE); [FE] AssertionFailedError [CONTEXT] public TarArchiveOutputStream(OutputStream os) { [BUGGY] this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE); [BUGGY] } [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream)  OutputStream os [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen longFileMode long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	69	69	1	replace	
2	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public TarArchiveOutputStream(OutputStream os) { [BUGGY] [BUGGY] this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE); } [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream)  OutputStream os [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen longFileMode long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	69	69	1	add	
3	[BUG] [BUGGY] } [FE] AssertionFailedError [CONTEXT] public TarArchiveOutputStream(OutputStream os) { this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE); [BUGGY] } [BUGGY]  [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream)  OutputStream os [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen longFileMode long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	70	70	1	replace	
4	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public TarArchiveOutputStream(OutputStream os) { this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE); [BUGGY] [BUGGY] } [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream)  OutputStream os [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen longFileMode long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	70	70	1	add	
5	[BUG] [BUGGY] public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) { [FE] AssertionFailedError [CONTEXT] [BUGGY] public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) { [BUGGY] out = new CountingOutputStream(os); this.buffer = new TarBuffer(out, blockSize, recordSize); this.assemLen = 0; this.assemBuf = new byte[recordSize]; this.recordBuf = new byte[recordSize]; } [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream,int,int)  OutputStream os int blockSize int recordSize [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	87	87	1	replace	
6	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] [BUGGY] [BUGGY] public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) { out = new CountingOutputStream(os); this.buffer = new TarBuffer(out, blockSize, recordSize); this.assemLen = 0; this.assemBuf = new byte[recordSize]; this.recordBuf = new byte[recordSize]; } [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream,int,int)  OutputStream os int blockSize int recordSize [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	87	87	1	add	
7	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private final byte[]assemBuf; [CLASS] TarArchiveOutputStream  [VARIABLES] 	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	52	52	1	replace	
8	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private final byte[]assemBuf; [CLASS] TarArchiveOutputStream  [VARIABLES] 	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	52	52	1	add	
9	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private int longFileMode = LONGFILE_ERROR; [CLASS] TarArchiveOutputStream  [VARIABLES] 	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	54	54	1	replace	
10	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private int longFileMode = LONGFILE_ERROR; [CLASS] TarArchiveOutputStream  [VARIABLES] 	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	54	54	1	add	
11	[BUG] [BUGGY] private boolean haveUnclosedEntry = false; [FE] AssertionFailedError [CONTEXT] [BUGGY] private boolean haveUnclosedEntry = false; [BUGGY]  [CLASS] TarArchiveOutputStream  [VARIABLES] 	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	57	57	1	replace	
12	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] [BUGGY] [BUGGY] private boolean haveUnclosedEntry = false; [CLASS] TarArchiveOutputStream  [VARIABLES] 	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	57	57	1	add	
13	[BUG] [BUGGY] private boolean finished = false; [FE] AssertionFailedError [CONTEXT] [BUGGY] private boolean finished = false; [BUGGY]  [CLASS] TarArchiveOutputStream  [VARIABLES] 	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	60	60	1	replace	
14	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] [BUGGY] [BUGGY] private boolean finished = false; [CLASS] TarArchiveOutputStream  [VARIABLES] 	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	60	60	1	add	
15	[BUG] [BUGGY] out = new CountingOutputStream(os); [FE] AssertionFailedError [CONTEXT] public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) { [BUGGY] out = new CountingOutputStream(os); [BUGGY]  this.buffer = new TarBuffer(out, blockSize, recordSize); this.assemLen = 0; this.assemBuf = new byte[recordSize]; this.recordBuf = new byte[recordSize]; } [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream,int,int)  OutputStream os int blockSize int recordSize [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	88	88	1	replace	
16	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) { [BUGGY] [BUGGY] out = new CountingOutputStream(os); this.buffer = new TarBuffer(out, blockSize, recordSize); this.assemLen = 0; this.assemBuf = new byte[recordSize]; this.recordBuf = new byte[recordSize]; } [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream,int,int)  OutputStream os int blockSize int recordSize [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	88	88	1	add	
17	[BUG] [BUGGY] this.buffer = new TarBuffer(out, blockSize, recordSize); [FE] AssertionFailedError [CONTEXT] public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) { out = new CountingOutputStream(os); [BUGGY] this.buffer = new TarBuffer(out, blockSize, recordSize); [BUGGY] this.assemLen = 0; this.assemBuf = new byte[recordSize]; this.recordBuf = new byte[recordSize]; } [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream,int,int)  OutputStream os int blockSize int recordSize [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	90	90	1	replace	
18	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) { out = new CountingOutputStream(os); [BUGGY] [BUGGY] this.buffer = new TarBuffer(out, blockSize, recordSize); this.assemLen = 0; this.assemBuf = new byte[recordSize]; this.recordBuf = new byte[recordSize]; } [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream,int,int)  OutputStream os int blockSize int recordSize [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	90	90	1	add	
19	[BUG] [BUGGY] this.assemLen = 0; [FE] AssertionFailedError [CONTEXT] public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) { out = new CountingOutputStream(os); this.buffer = new TarBuffer(out, blockSize, recordSize); [BUGGY] this.assemLen = 0; [BUGGY] this.assemBuf = new byte[recordSize]; this.recordBuf = new byte[recordSize]; } [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream,int,int)  OutputStream os int blockSize int recordSize [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	91	91	1	replace	
20	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) { out = new CountingOutputStream(os); this.buffer = new TarBuffer(out, blockSize, recordSize); [BUGGY] [BUGGY] this.assemLen = 0; this.assemBuf = new byte[recordSize]; this.recordBuf = new byte[recordSize]; } [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream,int,int)  OutputStream os int blockSize int recordSize [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	91	91	1	add	
21	[BUG] [BUGGY] this.assemBuf = new byte[recordSize]; [FE] AssertionFailedError [CONTEXT] public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) { out = new CountingOutputStream(os); this.buffer = new TarBuffer(out, blockSize, recordSize); this.assemLen = 0; [BUGGY] this.assemBuf = new byte[recordSize]; [BUGGY] this.recordBuf = new byte[recordSize]; } [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream,int,int)  OutputStream os int blockSize int recordSize [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	92	92	1	replace	
22	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) { out = new CountingOutputStream(os); this.buffer = new TarBuffer(out, blockSize, recordSize); this.assemLen = 0; [BUGGY] [BUGGY] this.assemBuf = new byte[recordSize]; this.recordBuf = new byte[recordSize]; } [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream,int,int)  OutputStream os int blockSize int recordSize [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	92	92	1	add	
23	[BUG] [BUGGY] this.recordBuf = new byte[recordSize]; [FE] AssertionFailedError [CONTEXT] public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) { out = new CountingOutputStream(os); this.buffer = new TarBuffer(out, blockSize, recordSize); this.assemLen = 0; this.assemBuf = new byte[recordSize]; [BUGGY] this.recordBuf = new byte[recordSize]; [BUGGY] } [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream,int,int)  OutputStream os int blockSize int recordSize [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	93	93	1	replace	
24	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) { out = new CountingOutputStream(os); this.buffer = new TarBuffer(out, blockSize, recordSize); this.assemLen = 0; this.assemBuf = new byte[recordSize]; [BUGGY] [BUGGY] this.recordBuf = new byte[recordSize]; } [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream,int,int)  OutputStream os int blockSize int recordSize [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	93	93	1	add	
25	[BUG] [BUGGY] } [FE] AssertionFailedError [CONTEXT] public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) { out = new CountingOutputStream(os); this.buffer = new TarBuffer(out, blockSize, recordSize); this.assemLen = 0; this.assemBuf = new byte[recordSize]; this.recordBuf = new byte[recordSize]; [BUGGY] } [BUGGY]  [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream,int,int)  OutputStream os int blockSize int recordSize [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	94	94	1	replace	
26	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) { out = new CountingOutputStream(os); this.buffer = new TarBuffer(out, blockSize, recordSize); this.assemLen = 0; this.assemBuf = new byte[recordSize]; this.recordBuf = new byte[recordSize]; [BUGGY] [BUGGY] } [CLASS] TarArchiveOutputStream [METHOD] <init> [RETURN_TYPE] OutputStream,int,int)  OutputStream os int blockSize int recordSize [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	94	94	1	add	
27	[BUG] [BUGGY] if (finished) { [FE] AssertionFailedError [CONTEXT] public void finish() throws IOException { [BUGGY] if (finished) { [BUGGY] throw new IOException("This archive has already been finished"); } if(haveUnclosedEntry) { throw new IOException("This archives contains unclosed entries."); } writeEOFRecord(); writeEOFRecord(); buffer.flushBlock(); finished = true; [CLASS] TarArchiveOutputStream [METHOD] finish [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	121	121	1	replace	
28	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void finish() throws IOException { [BUGGY] [BUGGY] if (finished) { throw new IOException("This archive has already been finished"); } if(haveUnclosedEntry) { throw new IOException("This archives contains unclosed entries."); } writeEOFRecord(); writeEOFRecord(); buffer.flushBlock(); finished = true; [CLASS] TarArchiveOutputStream [METHOD] finish [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	121	121	1	add	
29	[BUG] [BUGGY] if(haveUnclosedEntry) { [FE] AssertionFailedError [CONTEXT] public void finish() throws IOException { if (finished) { throw new IOException("This archive has already been finished"); } [BUGGY] if(haveUnclosedEntry) { [BUGGY] throw new IOException("This archives contains unclosed entries."); } writeEOFRecord(); writeEOFRecord(); buffer.flushBlock(); finished = true; } [CLASS] TarArchiveOutputStream [METHOD] finish [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	125	125	1	replace	
30	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void finish() throws IOException { if (finished) { throw new IOException("This archive has already been finished"); } [BUGGY] [BUGGY] if(haveUnclosedEntry) { throw new IOException("This archives contains unclosed entries."); } writeEOFRecord(); writeEOFRecord(); buffer.flushBlock(); finished = true; } [CLASS] TarArchiveOutputStream [METHOD] finish [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	125	125	1	add	
31	[BUG] [BUGGY] writeEOFRecord(); [FE] AssertionFailedError [CONTEXT] public void finish() throws IOException { if (finished) { throw new IOException("This archive has already been finished"); } if(haveUnclosedEntry) { throw new IOException("This archives contains unclosed entries."); } [BUGGY] writeEOFRecord(); [BUGGY] writeEOFRecord(); buffer.flushBlock(); finished = true; } [CLASS] TarArchiveOutputStream [METHOD] finish [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	128	128	1	replace	
32	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void finish() throws IOException { if (finished) { throw new IOException("This archive has already been finished"); } if(haveUnclosedEntry) { throw new IOException("This archives contains unclosed entries."); } [BUGGY] [BUGGY] writeEOFRecord(); writeEOFRecord(); buffer.flushBlock(); finished = true; } [CLASS] TarArchiveOutputStream [METHOD] finish [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	128	128	1	add	
33	[BUG] [BUGGY] writeEOFRecord(); [FE] AssertionFailedError [CONTEXT] public void finish() throws IOException { if (finished) { throw new IOException("This archive has already been finished"); } if(haveUnclosedEntry) { throw new IOException("This archives contains unclosed entries."); } writeEOFRecord(); [BUGGY] writeEOFRecord(); [BUGGY] buffer.flushBlock(); finished = true; } [CLASS] TarArchiveOutputStream [METHOD] finish [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	129	129	1	replace	
34	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void finish() throws IOException { if (finished) { throw new IOException("This archive has already been finished"); } if(haveUnclosedEntry) { throw new IOException("This archives contains unclosed entries."); } writeEOFRecord(); [BUGGY] [BUGGY] writeEOFRecord(); buffer.flushBlock(); finished = true; } [CLASS] TarArchiveOutputStream [METHOD] finish [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	129	129	1	add	
35	[BUG] [BUGGY] buffer.flushBlock(); [FE] AssertionFailedError [CONTEXT] public void finish() throws IOException { if (finished) { throw new IOException("This archive has already been finished"); } if(haveUnclosedEntry) { throw new IOException("This archives contains unclosed entries."); } writeEOFRecord(); writeEOFRecord(); [BUGGY] buffer.flushBlock(); [BUGGY] finished = true; } [CLASS] TarArchiveOutputStream [METHOD] finish [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	130	130	1	replace	
36	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void finish() throws IOException { if (finished) { throw new IOException("This archive has already been finished"); } if(haveUnclosedEntry) { throw new IOException("This archives contains unclosed entries."); } writeEOFRecord(); writeEOFRecord(); [BUGGY] [BUGGY] buffer.flushBlock(); finished = true; } [CLASS] TarArchiveOutputStream [METHOD] finish [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	130	130	1	add	
37	[BUG] [BUGGY] finished = true; [FE] AssertionFailedError [CONTEXT] if (finished) { throw new IOException("This archive has already been finished"); } if(haveUnclosedEntry) { throw new IOException("This archives contains unclosed entries."); } writeEOFRecord(); writeEOFRecord(); buffer.flushBlock(); [BUGGY] finished = true; [BUGGY] } [CLASS] TarArchiveOutputStream [METHOD] finish [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	
38	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (finished) { throw new IOException("This archive has already been finished"); } if(haveUnclosedEntry) { throw new IOException("This archives contains unclosed entries."); } writeEOFRecord(); writeEOFRecord(); buffer.flushBlock(); [BUGGY] [BUGGY] finished = true; } [CLASS] TarArchiveOutputStream [METHOD] finish [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	add	
39	[BUG] [BUGGY] } [FE] AssertionFailedError [CONTEXT] throw new IOException("This archive has already been finished"); } if(haveUnclosedEntry) { throw new IOException("This archives contains unclosed entries."); } writeEOFRecord(); writeEOFRecord(); buffer.flushBlock(); finished = true; [BUGGY] } [BUGGY]  [CLASS] TarArchiveOutputStream [METHOD] finish [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	132	132	1	replace	
40	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] throw new IOException("This archive has already been finished"); } if(haveUnclosedEntry) { throw new IOException("This archives contains unclosed entries."); } writeEOFRecord(); writeEOFRecord(); buffer.flushBlock(); finished = true; [BUGGY] [BUGGY] } [CLASS] TarArchiveOutputStream [METHOD] finish [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	132	132	1	add	
41	[BUG] [BUGGY] if(!finished) { [FE] AssertionFailedError [CONTEXT] public void close() throws IOException { [BUGGY] if(!finished) { [BUGGY] finish(); } if (!closed) { buffer.close(); out.close(); closed = true; } } [CLASS] TarArchiveOutputStream [METHOD] close [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	140	140	1	replace	
42	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void close() throws IOException { [BUGGY] [BUGGY] if(!finished) { finish(); } if (!closed) { buffer.close(); out.close(); closed = true; } } [CLASS] TarArchiveOutputStream [METHOD] close [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	140	140	1	add	
43	[BUG] [BUGGY] finish(); [FE] AssertionFailedError [CONTEXT] public void close() throws IOException { if(!finished) { [BUGGY] finish(); [BUGGY] } if (!closed) { buffer.close(); out.close(); closed = true; } } [CLASS] TarArchiveOutputStream [METHOD] close [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	141	141	1	replace	
44	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void close() throws IOException { if(!finished) { [BUGGY] [BUGGY] finish(); } if (!closed) { buffer.close(); out.close(); closed = true; } } [CLASS] TarArchiveOutputStream [METHOD] close [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	141	141	1	add	
45	[BUG] [BUGGY] if (!closed) { [FE] AssertionFailedError [CONTEXT] public void close() throws IOException { if(!finished) { finish(); } [BUGGY] if (!closed) { [BUGGY] buffer.close(); out.close(); closed = true; } } [CLASS] TarArchiveOutputStream [METHOD] close [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	144	144	1	replace	
46	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void close() throws IOException { if(!finished) { finish(); } [BUGGY] [BUGGY] if (!closed) { buffer.close(); out.close(); closed = true; } } [CLASS] TarArchiveOutputStream [METHOD] close [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	144	144	1	add	
47	[BUG] [BUGGY] buffer.close(); [FE] AssertionFailedError [CONTEXT] public void close() throws IOException { if(!finished) { finish(); } if (!closed) { [BUGGY] buffer.close(); [BUGGY] out.close(); closed = true; } } [CLASS] TarArchiveOutputStream [METHOD] close [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	145	145	1	replace	
48	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void close() throws IOException { if(!finished) { finish(); } if (!closed) { [BUGGY] [BUGGY] buffer.close(); out.close(); closed = true; } } [CLASS] TarArchiveOutputStream [METHOD] close [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	145	145	1	add	
49	[BUG] [BUGGY] out.close(); [FE] AssertionFailedError [CONTEXT] public void close() throws IOException { if(!finished) { finish(); } if (!closed) { buffer.close(); [BUGGY] out.close(); [BUGGY] closed = true; } } [CLASS] TarArchiveOutputStream [METHOD] close [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	146	146	1	replace	
50	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void close() throws IOException { if(!finished) { finish(); } if (!closed) { buffer.close(); [BUGGY] [BUGGY] out.close(); closed = true; } } [CLASS] TarArchiveOutputStream [METHOD] close [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	146	146	1	add	
51	[BUG] [BUGGY] closed = true; [FE] AssertionFailedError [CONTEXT] public void close() throws IOException { if(!finished) { finish(); } if (!closed) { buffer.close(); out.close(); [BUGGY] closed = true; [BUGGY] } } [CLASS] TarArchiveOutputStream [METHOD] close [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	147	147	1	replace	
52	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void close() throws IOException { if(!finished) { finish(); } if (!closed) { buffer.close(); out.close(); [BUGGY] [BUGGY] closed = true; } } [CLASS] TarArchiveOutputStream [METHOD] close [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	147	147	1	add	
53	[BUG] [BUGGY] } [FE] AssertionFailedError [CONTEXT] public void close() throws IOException { if(!finished) { finish(); } if (!closed) { buffer.close(); out.close(); closed = true; } [BUGGY] } [BUGGY]  [CLASS] TarArchiveOutputStream [METHOD] close [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	149	149	1	replace	
54	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void close() throws IOException { if(!finished) { finish(); } if (!closed) { buffer.close(); out.close(); closed = true; } [BUGGY] [BUGGY] } [CLASS] TarArchiveOutputStream [METHOD] close [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	149	149	1	add	
55	[BUG] [BUGGY] if(finished) { [FE] AssertionFailedError [CONTEXT] public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException { [BUGGY] if(finished) { [BUGGY] throw new IOException("Stream has already been finished"); } TarArchiveEntry entry = (TarArchiveEntry) archiveEntry; if (entry.getName().length() >= TarConstants.NAMELEN) { if (longFileMode == LONGFILE_GNU) {   TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, TarConstants.LF_GNUTYPE_LONGNAME); [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	175	175	1	replace	
56	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException { [BUGGY] [BUGGY] if(finished) { throw new IOException("Stream has already been finished"); } TarArchiveEntry entry = (TarArchiveEntry) archiveEntry; if (entry.getName().length() >= TarConstants.NAMELEN) { if (longFileMode == LONGFILE_GNU) {   TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, TarConstants.LF_GNUTYPE_LONGNAME); [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	175	175	1	add	
57	[BUG] [BUGGY] TarArchiveEntry entry = (TarArchiveEntry) archiveEntry; [FE] AssertionFailedError [CONTEXT] public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException { if(finished) { throw new IOException("Stream has already been finished"); } [BUGGY] TarArchiveEntry entry = (TarArchiveEntry) archiveEntry; [BUGGY] if (entry.getName().length() >= TarConstants.NAMELEN) { if (longFileMode == LONGFILE_GNU) {   TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, TarConstants.LF_GNUTYPE_LONGNAME); final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName()); longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	178	178	1	replace	
58	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException { if(finished) { throw new IOException("Stream has already been finished"); } [BUGGY] [BUGGY] TarArchiveEntry entry = (TarArchiveEntry) archiveEntry; if (entry.getName().length() >= TarConstants.NAMELEN) { if (longFileMode == LONGFILE_GNU) {   TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, TarConstants.LF_GNUTYPE_LONGNAME); final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName()); longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	178	178	1	add	
59	[BUG] [BUGGY] if (entry.getName().length() >= TarConstants.NAMELEN) { [FE] AssertionFailedError [CONTEXT] public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException { if(finished) { throw new IOException("Stream has already been finished"); } TarArchiveEntry entry = (TarArchiveEntry) archiveEntry; [BUGGY] if (entry.getName().length() >= TarConstants.NAMELEN) { [BUGGY]  if (longFileMode == LONGFILE_GNU) {   TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, TarConstants.LF_GNUTYPE_LONGNAME); final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName()); longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL putArchiveEntry(longLinkEntry); [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	179	179	1	replace	
60	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException { if(finished) { throw new IOException("Stream has already been finished"); } TarArchiveEntry entry = (TarArchiveEntry) archiveEntry; [BUGGY] [BUGGY] if (entry.getName().length() >= TarConstants.NAMELEN) { if (longFileMode == LONGFILE_GNU) {   TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, TarConstants.LF_GNUTYPE_LONGNAME); final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName()); longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL putArchiveEntry(longLinkEntry); [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	179	179	1	add	
61	[BUG] [BUGGY] entry.writeEntryHeader(recordBuf); [FE] AssertionFailedError [CONTEXT] write(nameBytes); write(0); // NUL terminator closeArchiveEntry(); } else if (longFileMode != LONGFILE_TRUNCATE) { throw new RuntimeException("file name '" + entry.getName() + "' is too long ( > " + TarConstants.NAMELEN + " bytes)"); } } [BUGGY] entry.writeEntryHeader(recordBuf); [BUGGY] buffer.writeRecord(recordBuf); currBytes = 0; if (entry.isDirectory()) { currSize = 0; } else { currSize = entry.getSize(); } currName = entry.getName(); [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	200	200	1	replace	
62	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] write(nameBytes); write(0); // NUL terminator closeArchiveEntry(); } else if (longFileMode != LONGFILE_TRUNCATE) { throw new RuntimeException("file name '" + entry.getName() + "' is too long ( > " + TarConstants.NAMELEN + " bytes)"); } } [BUGGY] [BUGGY] entry.writeEntryHeader(recordBuf); buffer.writeRecord(recordBuf); currBytes = 0; if (entry.isDirectory()) { currSize = 0; } else { currSize = entry.getSize(); } currName = entry.getName(); [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	200	200	1	add	
63	[BUG] [BUGGY] buffer.writeRecord(recordBuf); [FE] AssertionFailedError [CONTEXT] write(0); // NUL terminator closeArchiveEntry(); } else if (longFileMode != LONGFILE_TRUNCATE) { throw new RuntimeException("file name '" + entry.getName() + "' is too long ( > " + TarConstants.NAMELEN + " bytes)"); } } entry.writeEntryHeader(recordBuf); [BUGGY] buffer.writeRecord(recordBuf); [BUGGY]  currBytes = 0; if (entry.isDirectory()) { currSize = 0; } else { currSize = entry.getSize(); } currName = entry.getName(); haveUnclosedEntry = true; [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	201	201	1	replace	
64	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] write(0); // NUL terminator closeArchiveEntry(); } else if (longFileMode != LONGFILE_TRUNCATE) { throw new RuntimeException("file name '" + entry.getName() + "' is too long ( > " + TarConstants.NAMELEN + " bytes)"); } } entry.writeEntryHeader(recordBuf); [BUGGY] [BUGGY] buffer.writeRecord(recordBuf); currBytes = 0; if (entry.isDirectory()) { currSize = 0; } else { currSize = entry.getSize(); } currName = entry.getName(); haveUnclosedEntry = true; [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	201	201	1	add	
65	[BUG] [BUGGY] currBytes = 0; [FE] AssertionFailedError [CONTEXT] } else if (longFileMode != LONGFILE_TRUNCATE) { throw new RuntimeException("file name '" + entry.getName() + "' is too long ( > " + TarConstants.NAMELEN + " bytes)"); } } entry.writeEntryHeader(recordBuf); buffer.writeRecord(recordBuf); [BUGGY] currBytes = 0; [BUGGY]  if (entry.isDirectory()) { currSize = 0; } else { currSize = entry.getSize(); } currName = entry.getName(); haveUnclosedEntry = true; } [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	203	203	1	replace	
66	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } else if (longFileMode != LONGFILE_TRUNCATE) { throw new RuntimeException("file name '" + entry.getName() + "' is too long ( > " + TarConstants.NAMELEN + " bytes)"); } } entry.writeEntryHeader(recordBuf); buffer.writeRecord(recordBuf); [BUGGY] [BUGGY] currBytes = 0; if (entry.isDirectory()) { currSize = 0; } else { currSize = entry.getSize(); } currName = entry.getName(); haveUnclosedEntry = true; } [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	203	203	1	add	
67	[BUG] [BUGGY] if (entry.isDirectory()) { [FE] AssertionFailedError [CONTEXT] + "' is too long ( > " + TarConstants.NAMELEN + " bytes)"); } } entry.writeEntryHeader(recordBuf); buffer.writeRecord(recordBuf); currBytes = 0; [BUGGY] if (entry.isDirectory()) { [BUGGY] currSize = 0; } else { currSize = entry.getSize(); } currName = entry.getName(); haveUnclosedEntry = true; } [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	205	205	1	replace	
68	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] + "' is too long ( > " + TarConstants.NAMELEN + " bytes)"); } } entry.writeEntryHeader(recordBuf); buffer.writeRecord(recordBuf); currBytes = 0; [BUGGY] [BUGGY] if (entry.isDirectory()) { currSize = 0; } else { currSize = entry.getSize(); } currName = entry.getName(); haveUnclosedEntry = true; } [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	205	205	1	add	
69	[BUG] [BUGGY] currSize = entry.getSize(); [FE] AssertionFailedError [CONTEXT] if (entry.isDirectory()) { currSize = 0; } else { [BUGGY] currSize = entry.getSize(); [BUGGY] } [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	208	208	1	replace	
70	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (entry.isDirectory()) { currSize = 0; } else { [BUGGY] [BUGGY] currSize = entry.getSize(); } [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	208	208	1	add	
71	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (entry.isDirectory()) { currSize = 0; } else { currSize = entry.getSize(); } [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	210	210	1	replace	
72	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (entry.isDirectory()) { currSize = 0; } else { currSize = entry.getSize(); } [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	210	210	1	add	
73	[BUG] [BUGGY] haveUnclosedEntry = true; [FE] AssertionFailedError [CONTEXT] buffer.writeRecord(recordBuf); currBytes = 0; if (entry.isDirectory()) { currSize = 0; } else { currSize = entry.getSize(); } currName = entry.getName(); [BUGGY] haveUnclosedEntry = true; [BUGGY] } [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	211	211	1	replace	
74	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] buffer.writeRecord(recordBuf); currBytes = 0; if (entry.isDirectory()) { currSize = 0; } else { currSize = entry.getSize(); } currName = entry.getName(); [BUGGY] [BUGGY] haveUnclosedEntry = true; } [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	211	211	1	add	
75	[BUG] [BUGGY] } [FE] AssertionFailedError [CONTEXT] currBytes = 0; if (entry.isDirectory()) { currSize = 0; } else { currSize = entry.getSize(); } currName = entry.getName(); haveUnclosedEntry = true; [BUGGY] } [BUGGY]  [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	212	212	1	replace	
76	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] currBytes = 0; if (entry.isDirectory()) { currSize = 0; } else { currSize = entry.getSize(); } currName = entry.getName(); haveUnclosedEntry = true; [BUGGY] [BUGGY] } [CLASS] TarArchiveOutputStream [METHOD] putArchiveEntry [RETURN_TYPE] void  ArchiveEntry archiveEntry [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer ArchiveEntry archiveEntry String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize longFileMode recordSize long currBytes currSize TarArchiveEntry entry longLinkEntry  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	212	212	1	add	
77	[BUG] [BUGGY] if(finished) { [FE] AssertionFailedError [CONTEXT] public void closeArchiveEntry() throws IOException { [BUGGY] if(finished) { [BUGGY] throw new IOException("Stream has already been finished"); } if (!haveUnclosedEntry){ throw new IOException("No current entry to close"); } if (assemLen > 0) { for (int i = assemLen; i < assemBuf.length; ++i) { assemBuf[i] = 0; }  [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	226	226	1	replace	
78	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void closeArchiveEntry() throws IOException { [BUGGY] [BUGGY] if(finished) { throw new IOException("Stream has already been finished"); } if (!haveUnclosedEntry){ throw new IOException("No current entry to close"); } if (assemLen > 0) { for (int i = assemLen; i < assemBuf.length; ++i) { assemBuf[i] = 0; }  [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	226	226	1	add	
79	[BUG] [BUGGY] if (!haveUnclosedEntry){ [FE] AssertionFailedError [CONTEXT] public void closeArchiveEntry() throws IOException { if(finished) { throw new IOException("Stream has already been finished"); } [BUGGY] if (!haveUnclosedEntry){ [BUGGY] throw new IOException("No current entry to close"); } if (assemLen > 0) { for (int i = assemLen; i < assemBuf.length; ++i) { assemBuf[i] = 0; } buffer.writeRecord(assemBuf); currBytes += assemLen; [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	229	229	1	replace	
80	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void closeArchiveEntry() throws IOException { if(finished) { throw new IOException("Stream has already been finished"); } [BUGGY] [BUGGY] if (!haveUnclosedEntry){ throw new IOException("No current entry to close"); } if (assemLen > 0) { for (int i = assemLen; i < assemBuf.length; ++i) { assemBuf[i] = 0; } buffer.writeRecord(assemBuf); currBytes += assemLen; [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	229	229	1	add	
81	[BUG] [BUGGY] if (assemLen > 0) { [FE] AssertionFailedError [CONTEXT] public void closeArchiveEntry() throws IOException { if(finished) { throw new IOException("Stream has already been finished"); } if (!haveUnclosedEntry){ throw new IOException("No current entry to close"); } [BUGGY] if (assemLen > 0) { [BUGGY] for (int i = assemLen; i < assemBuf.length; ++i) { assemBuf[i] = 0; } buffer.writeRecord(assemBuf); currBytes += assemLen; assemLen = 0; }  [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	232	232	1	replace	
82	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void closeArchiveEntry() throws IOException { if(finished) { throw new IOException("Stream has already been finished"); } if (!haveUnclosedEntry){ throw new IOException("No current entry to close"); } [BUGGY] [BUGGY] if (assemLen > 0) { for (int i = assemLen; i < assemBuf.length; ++i) { assemBuf[i] = 0; } buffer.writeRecord(assemBuf); currBytes += assemLen; assemLen = 0; }  [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	232	232	1	add	
83	[BUG] [BUGGY] for (int i = assemLen; i < assemBuf.length; ++i) { [FE] AssertionFailedError [CONTEXT] public void closeArchiveEntry() throws IOException { if(finished) { throw new IOException("Stream has already been finished"); } if (!haveUnclosedEntry){ throw new IOException("No current entry to close"); } if (assemLen > 0) { [BUGGY] for (int i = assemLen; i < assemBuf.length; ++i) { [BUGGY] assemBuf[i] = 0; } buffer.writeRecord(assemBuf); currBytes += assemLen; assemLen = 0; } if (currBytes < currSize) { [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	233	233	1	replace	
84	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void closeArchiveEntry() throws IOException { if(finished) { throw new IOException("Stream has already been finished"); } if (!haveUnclosedEntry){ throw new IOException("No current entry to close"); } if (assemLen > 0) { [BUGGY] [BUGGY] for (int i = assemLen; i < assemBuf.length; ++i) { assemBuf[i] = 0; } buffer.writeRecord(assemBuf); currBytes += assemLen; assemLen = 0; } if (currBytes < currSize) { [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	233	233	1	add	
85	[BUG] [BUGGY] assemBuf[i] = 0; [FE] AssertionFailedError [CONTEXT] public void closeArchiveEntry() throws IOException { if(finished) { throw new IOException("Stream has already been finished"); } if (!haveUnclosedEntry){ throw new IOException("No current entry to close"); } if (assemLen > 0) { for (int i = assemLen; i < assemBuf.length; ++i) { [BUGGY] assemBuf[i] = 0; [BUGGY] } buffer.writeRecord(assemBuf); currBytes += assemLen; assemLen = 0; } if (currBytes < currSize) { throw new IOException("entry '" + currName + "' closed at '" [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	234	234	1	replace	
86	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void closeArchiveEntry() throws IOException { if(finished) { throw new IOException("Stream has already been finished"); } if (!haveUnclosedEntry){ throw new IOException("No current entry to close"); } if (assemLen > 0) { for (int i = assemLen; i < assemBuf.length; ++i) { [BUGGY] [BUGGY] assemBuf[i] = 0; } buffer.writeRecord(assemBuf); currBytes += assemLen; assemLen = 0; } if (currBytes < currSize) { throw new IOException("entry '" + currName + "' closed at '" [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	234	234	1	add	
87	[BUG] [BUGGY] buffer.writeRecord(assemBuf); [FE] AssertionFailedError [CONTEXT] throw new IOException("Stream has already been finished"); } if (!haveUnclosedEntry){ throw new IOException("No current entry to close"); } if (assemLen > 0) { for (int i = assemLen; i < assemBuf.length; ++i) { assemBuf[i] = 0; } [BUGGY] buffer.writeRecord(assemBuf); [BUGGY]  currBytes += assemLen; assemLen = 0; } if (currBytes < currSize) { throw new IOException("entry '" + currName + "' closed at '" + currBytes + "' before the '" + currSize + "' bytes specified in the header were written"); [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	237	237	1	replace	
88	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] throw new IOException("Stream has already been finished"); } if (!haveUnclosedEntry){ throw new IOException("No current entry to close"); } if (assemLen > 0) { for (int i = assemLen; i < assemBuf.length; ++i) { assemBuf[i] = 0; } [BUGGY] [BUGGY] buffer.writeRecord(assemBuf); currBytes += assemLen; assemLen = 0; } if (currBytes < currSize) { throw new IOException("entry '" + currName + "' closed at '" + currBytes + "' before the '" + currSize + "' bytes specified in the header were written"); [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	237	237	1	add	
89	[BUG] [BUGGY] currBytes += assemLen; [FE] AssertionFailedError [CONTEXT] if (!haveUnclosedEntry){ throw new IOException("No current entry to close"); } if (assemLen > 0) { for (int i = assemLen; i < assemBuf.length; ++i) { assemBuf[i] = 0; } buffer.writeRecord(assemBuf); [BUGGY] currBytes += assemLen; [BUGGY] assemLen = 0; } if (currBytes < currSize) { throw new IOException("entry '" + currName + "' closed at '" + currBytes + "' before the '" + currSize + "' bytes specified in the header were written"); } haveUnclosedEntry = false; [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	239	239	1	replace	
90	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if (!haveUnclosedEntry){ throw new IOException("No current entry to close"); } if (assemLen > 0) { for (int i = assemLen; i < assemBuf.length; ++i) { assemBuf[i] = 0; } buffer.writeRecord(assemBuf); [BUGGY] [BUGGY] currBytes += assemLen; assemLen = 0; } if (currBytes < currSize) { throw new IOException("entry '" + currName + "' closed at '" + currBytes + "' before the '" + currSize + "' bytes specified in the header were written"); } haveUnclosedEntry = false; [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	239	239	1	add	
91	[BUG] [BUGGY] assemLen = 0; [FE] AssertionFailedError [CONTEXT] throw new IOException("No current entry to close"); } if (assemLen > 0) { for (int i = assemLen; i < assemBuf.length; ++i) { assemBuf[i] = 0; } buffer.writeRecord(assemBuf); currBytes += assemLen; [BUGGY] assemLen = 0; [BUGGY] } if (currBytes < currSize) { throw new IOException("entry '" + currName + "' closed at '" + currBytes + "' before the '" + currSize + "' bytes specified in the header were written"); } haveUnclosedEntry = false; } [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	240	240	1	replace	
92	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] throw new IOException("No current entry to close"); } if (assemLen > 0) { for (int i = assemLen; i < assemBuf.length; ++i) { assemBuf[i] = 0; } buffer.writeRecord(assemBuf); currBytes += assemLen; [BUGGY] [BUGGY] assemLen = 0; } if (currBytes < currSize) { throw new IOException("entry '" + currName + "' closed at '" + currBytes + "' before the '" + currSize + "' bytes specified in the header were written"); } haveUnclosedEntry = false; } [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	240	240	1	add	
93	[BUG] [BUGGY] if (currBytes < currSize) { [FE] AssertionFailedError [CONTEXT] for (int i = assemLen; i < assemBuf.length; ++i) { assemBuf[i] = 0; } buffer.writeRecord(assemBuf); currBytes += assemLen; assemLen = 0; } [BUGGY] if (currBytes < currSize) { [BUGGY] throw new IOException("entry '" + currName + "' closed at '" + currBytes + "' before the '" + currSize + "' bytes specified in the header were written"); } haveUnclosedEntry = false; } [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	243	243	1	replace	
94	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] for (int i = assemLen; i < assemBuf.length; ++i) { assemBuf[i] = 0; } buffer.writeRecord(assemBuf); currBytes += assemLen; assemLen = 0; } [BUGGY] [BUGGY] if (currBytes < currSize) { throw new IOException("entry '" + currName + "' closed at '" + currBytes + "' before the '" + currSize + "' bytes specified in the header were written"); } haveUnclosedEntry = false; } [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	243	243	1	add	
95	[BUG] [BUGGY] haveUnclosedEntry = false; [FE] AssertionFailedError [CONTEXT] currBytes += assemLen; assemLen = 0; } if (currBytes < currSize) { throw new IOException("entry '" + currName + "' closed at '" + currBytes + "' before the '" + currSize + "' bytes specified in the header were written"); } [BUGGY] haveUnclosedEntry = false; [BUGGY] } [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	249	249	1	replace	
96	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] currBytes += assemLen; assemLen = 0; } if (currBytes < currSize) { throw new IOException("entry '" + currName + "' closed at '" + currBytes + "' before the '" + currSize + "' bytes specified in the header were written"); } [BUGGY] [BUGGY] haveUnclosedEntry = false; } [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	249	249	1	add	
97	[BUG] [BUGGY] } [FE] AssertionFailedError [CONTEXT] assemLen = 0; } if (currBytes < currSize) { throw new IOException("entry '" + currName + "' closed at '" + currBytes + "' before the '" + currSize + "' bytes specified in the header were written"); } haveUnclosedEntry = false; [BUGGY] } [BUGGY]  [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	250	250	1	replace	
98	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] assemLen = 0; } if (currBytes < currSize) { throw new IOException("entry '" + currName + "' closed at '" + currBytes + "' before the '" + currSize + "' bytes specified in the header were written"); } haveUnclosedEntry = false; [BUGGY] [BUGGY] } [CLASS] TarArchiveOutputStream [METHOD] closeArchiveEntry [RETURN_TYPE] void  [VARIABLES] byte[] assemBuf nameBytes recordBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE assemLen blockSize i longFileMode recordSize long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	250	250	1	add	
99	[BUG] [BUGGY] if ((currBytes + numToWrite) > currSize) { [FE] AssertionFailedError [CONTEXT] public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException { [BUGGY] if ((currBytes + numToWrite) > currSize) { [BUGGY] throw new IOException("request to write '" + numToWrite + "' bytes exceeds size in header of '" + currSize + "' bytes for entry '" + currName + "'");       [CLASS] TarArchiveOutputStream [METHOD] write [RETURN_TYPE] void  byte[] wBuf int wOffset int numToWrite [VARIABLES] byte[] assemBuf nameBytes recordBuf wBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE aLen assemLen blockSize i longFileMode num numToWrite recordSize wOffset long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	268	268	1	replace	
100	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException { [BUGGY] [BUGGY] if ((currBytes + numToWrite) > currSize) { throw new IOException("request to write '" + numToWrite + "' bytes exceeds size in header of '" + currSize + "' bytes for entry '" + currName + "'");       [CLASS] TarArchiveOutputStream [METHOD] write [RETURN_TYPE] void  byte[] wBuf int wOffset int numToWrite [VARIABLES] byte[] assemBuf nameBytes recordBuf wBuf boolean closed finished haveUnclosedEntry OutputStream os out TarBuffer buffer String currName int LONGFILE_ERROR LONGFILE_GNU LONGFILE_TRUNCATE aLen assemLen blockSize i longFileMode num numToWrite recordSize wOffset long currBytes currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	268	268	1	add	
