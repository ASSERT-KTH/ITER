bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	35	None	replace
2	[BUG]  [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	35	None	replace
3	[BUG]  [BUGGY]  readEOFRecord();  buffer.flushBlock();  started  =  true;  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  readEOFRecord();  buffer.flushBlock();  started  =  true;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	readEOFRecord();  buffer.flushBlock();  started  =  true;	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	35	None	replace
4	[BUG]  [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	35	None	replace
5	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	73	None	replace
6	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	73	None	replace
7	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	73	None	replace
8	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	73	None	replace
9	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	73	None	replace
10	[BUG]  [BUGGY]  after(recordBuf,  0,  out.length)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(recordBuf,  0,  out.length)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(recordBuf,  0,  out.length)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	73	None	replace
11	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finish  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finish  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finish  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	73	None	replace
12	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	34	None	replace
13	[BUG]  [BUGGY]  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	34	None	replace
14	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	34	None	replace
15	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	34	None	replace
16	[BUG]  [BUGGY]  while(!closed)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	34	None	replace
17	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	34	None	replace
18	[BUG]  [BUGGY]  Finished  =  false;  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;	  if(finished)    {    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	111	None	replace
19	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }	  if(finished)    {    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	111	None	replace
20	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;	  if(finished)    {    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	111	None	replace
21	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }	  if(finished)    {    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	111	None	replace
22	[BUG]  [BUGGY]  if(closed  ||  finished)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed  ||  finished)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed  ||  finished)  {  finished  =  false;  }	  if(finished)    {    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	111	None	replace
23	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	110	None	replace
24	[BUG]  [BUGGY]  if(!finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	110	None	replace
25	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	110	None	replace
26	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	110	None	replace
27	[BUG]  [BUGGY]  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	110	None	replace
28	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	110	None	replace
29	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  OutputStream  out.close();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  OutputStream  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  OutputStream  out.close();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	110	None	replace
30	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	72	None	replace
31	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	72	None	replace
32	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	72	None	replace
33	[BUG]  [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	72	None	replace
34	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	72	None	replace
35	[BUG]  [BUGGY]  if(closed)  {  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	92	None	replace
36	[BUG]  [BUGGY]  if(finished)  {  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	92	None	replace
37	[BUG]  [BUGGY]  else  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	92	None	replace
38	[BUG]  [BUGGY]  while(!closed)  {  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	92	None	replace
39	[BUG]  [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	92	None	replace
40	[BUG]  [BUGGY]  if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	9	None	replace
41	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	9	None	replace
42	[BUG]  [BUGGY]  if(closed)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	9	None	replace
43	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	9	None	replace
44	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	9	None	replace
45	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  buffer.append(currName[i]);  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  buffer.append(currName[i]);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  buffer.append(currName[i]);	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	9	None	replace
46	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.flushBlock();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	13	None	replace
47	[BUG]  [BUGGY]  if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.flushBlock();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	13	None	replace
48	[BUG]  [BUGGY]  if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	13	None	replace
49	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.flushBlock();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	13	None	replace
50	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	13	None	replace
51	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	104	None	replace
52	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	104	None	replace
53	[BUG]  [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	104	None	replace
54	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	104	None	replace
55	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	104	None	replace
56	[BUG]  [BUGGY]  Finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	104	None	replace
57	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	109	None	replace
58	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	109	None	replace
59	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	109	None	replace
60	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	109	None	replace
61	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	109	None	replace
62	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finish  =  false;  }  else  {  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finish  =  false;  }  else  {  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finish  =  false;  }  else  {  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	109	None	replace
63	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	109	None	replace
64	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	23	None	replace
65	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	23	None	replace
66	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	23	None	replace
67	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	23	None	replace
68	[BUG]  [BUGGY]  if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	53	None	replace
69	[BUG]  [BUGGY]  if(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	53	None	replace
70	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	53	None	replace
71	[BUG]  [BUGGY]  if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	53	None	replace
72	[BUG]  [BUGGY]  if(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	53	None	replace
73	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  ==  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(currName    ==    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	51	None	replace
74	[BUG]  [BUGGY]  if(currName  ==  null  ||  currName.length()  ==  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null  ||  currName.length()  ==  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null  ||  currName.length()  ==  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(currName    ==    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	51	None	replace
75	[BUG]  [BUGGY]  if(closed)  {  if(currName  ==  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(currName  ==  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(currName  ==  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(currName    ==    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	51	None	replace
76	[BUG]  [BUGGY]  if(closed)  {  if(currName  ==  null)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(currName  ==  null)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(currName  ==  null)  {  finished  =  false;  }	  if(currName    ==    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	51	None	replace
77	[BUG]  [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	45	None	replace
78	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	45	None	replace
79	[BUG]  [BUGGY]  if(closed)  {  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	45	None	replace
80	[BUG]  [BUGGY]  if(closed)  {  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	45	None	replace
81	[BUG]  [BUGGY]  while(!finished  &&  buffer.hasMoreElements())  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  buffer.hasMoreElements())  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  buffer.hasMoreElements())  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	45	None	replace
82	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	118	None	replace
83	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	118	None	replace
84	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	118	None	replace
85	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	118	None	replace
86	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  started  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	118	None	replace
87	[BUG]  [BUGGY]  Finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	118	None	replace
88	[BUG]  [BUGGY]  Thread.currentThread().getContextClassLoader().reset();  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Thread.currentThread().getContextClassLoader().reset();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Thread.currentThread().getContextClassLoader().reset();	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
89	[BUG]  [BUGGY]  Thread.currentThread().interrupt();  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Thread.currentThread().interrupt();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Thread.currentThread().interrupt();	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
90	[BUG]  [BUGGY]  readEOFRecord();  buffer.flushBlock();  finish();  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  readEOFRecord();  buffer.flushBlock();  finish();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	readEOFRecord();  buffer.flushBlock();  finish();	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
91	[BUG]  [BUGGY]  Thread.currentThread().getContextClassLoader();  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Thread.currentThread().getContextClassLoader();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Thread.currentThread().getContextClassLoader();	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
92	[BUG]  [BUGGY]  Thread.currentThread().getContextClassLoader().setCurrentName(currName);  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Thread.currentThread().getContextClassLoader().setCurrentName(currName);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Thread.currentThread().getContextClassLoader().setCurrentName(currName);	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
93	[BUG]  [BUGGY]  Thread.currentThread().getContextClassLoader().reportError( "TarArchiveOutputStream. ");  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Thread.currentThread().getContextClassLoader().reportError( "TarArchiveOutputStream. ");  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Thread.currentThread().getContextClassLoader().reportError( "TarArchiveOutputStream. ");	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
94	[BUG]  [BUGGY]  aughtExceptionHandler.throwAsIOException( " ");  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  aughtExceptionHandler.throwAsIOException( " ");  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	aughtExceptionHandler.throwAsIOException( " ");	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	83	None	replace
95	[BUG]  [BUGGY]  aughtExceptionHandler.throwInternal();  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  aughtExceptionHandler.throwInternal();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	aughtExceptionHandler.throwInternal();	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	83	None	replace
96	[BUG]  [BUGGY]  aughtExceptionHandler.handleMissingException( " ");  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  aughtExceptionHandler.handleMissingException( " ");  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	aughtExceptionHandler.handleMissingException( " ");	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	83	None	replace
97	[BUG]  [BUGGY]  aughtExceptionHandler.throwIOException( " ");  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  aughtExceptionHandler.throwIOException( " ");  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	aughtExceptionHandler.throwIOException( " ");	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	83	None	replace
98	[BUG]  [BUGGY]  aughtExceptionHandler.handleException( " ");  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  aughtExceptionHandler.handleException( " ");  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	aughtExceptionHandler.handleException( " ");	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	83	None	replace
99	[BUG]  [BUGGY]  Parchet.checkNotNull(currName);  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Parchet.checkNotNull(currName);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Parchet.checkNotNull(currName);	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	83	None	replace
100	[BUG]  [BUGGY]  readEOFRecord();  buffer.flushBlock();  completed  =  true;  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  readEOFRecord();  buffer.flushBlock();  completed  =  true;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	readEOFRecord();  buffer.flushBlock();  completed  =  true;	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	58	None	replace
101	[BUG]  [BUGGY]  readEOFRecord();  buffer.flushBlock();  finished  =  false;  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  readEOFRecord();  buffer.flushBlock();  finished  =  false;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	readEOFRecord();  buffer.flushBlock();  finished  =  false;	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	58	None	replace
102	[BUG]  [BUGGY]  castError( "TarArchiveOutputStream  has  already  been  finished. ");  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  castError( "TarArchiveOutputStream  has  already  been  finished. ");  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	castError( "TarArchiveOutputStream  has  already  been  finished. ");	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	58	None	replace
103	[BUG]  [BUGGY]  castError( "TarArchiveOutputStream  finished: "  +  currName);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  castError( "TarArchiveOutputStream  finished: "  +  currName);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	castError( "TarArchiveOutputStream  finished: "  +  currName);	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	58	None	replace
104	[BUG]  [BUGGY]  finished  =  buffer.read();  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  buffer.read();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  buffer.read();	  finished    =    null;    	non-compiled	[CE]  <identifier>  expected	114	None	replace
105	[BUG]  [BUGGY]  finished  =  buffer.getBytes(currName);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  buffer.getBytes(currName);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  buffer.getBytes(currName);	  finished    =    null;    	non-compiled	[CE]  <identifier>  expected	114	None	replace
106	[BUG]  [BUGGY]  finished  =  buffer.finish();  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  buffer.finish();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  buffer.finish();	  finished    =    null;    	non-compiled	[CE]  <identifier>  expected	114	None	replace
107	[BUG]  [BUGGY]  finished  =  buffer;  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  buffer;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  buffer;	  finished    =    null;    	non-compiled	[CE]  <identifier>  expected	114	None	replace
108	[BUG]  [BUGGY]  finished  =  buffer.openStream();  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  buffer.openStream();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  buffer.openStream();	  finished    =    null;    	non-compiled	[CE]  <identifier>  expected	114	None	replace
109	[BUG]  [BUGGY]  finished  =  buffer.length();  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  buffer.length();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  buffer.length();	  finished    =    null;    	non-compiled	[CE]  <identifier>  expected	114	None	replace
110	[BUG]  [BUGGY]  finished  =  buffer.getOutputStream();  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  buffer.getOutputStream();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  buffer.getOutputStream();	  finished    =    null;    	non-compiled	[CE]  <identifier>  expected	114	None	replace
111	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	46	None	replace
112	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	46	None	replace
113	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	46	None	replace
114	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	46	None	replace
115	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  closed  =  true;  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  closed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  closed  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	46	None	replace
116	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  sealed  =  true;  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  sealed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  sealed  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	46	None	replace
117	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	46	None	replace
118	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	75	None	replace
119	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  OutputStream  out.close();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  OutputStream  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  OutputStream  out.close();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	75	None	replace
120	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  out.close();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  out.close();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	75	None	replace
121	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	24	None	replace
122	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedentry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedentry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedentry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	24	None	replace
123	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	8	None	replace
124	[BUG]  [BUGGY]  while(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	8	None	replace
125	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	8	None	replace
126	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	31	None	replace
127	[BUG]  [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	31	None	replace
128	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	31	None	replace
129	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	31	None	replace
130	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	31	None	replace
131	[BUG]  [BUGGY]  while(!finished)  {  closed  =  false;  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  closed  =  false;  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  closed  =  false;  }  else  {  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	31	None	replace
132	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	25	None	replace
133	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	25	None	replace
134	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	25	None	replace
135	[BUG]  [BUGGY]  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	25	None	replace
136	[BUG]  [BUGGY]  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	95	None	replace
137	[BUG]  [BUGGY]  else  if(closed)  {  writeERROR();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(closed)  {  writeERROR();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(closed)  {  writeERROR();  buffer.flushBlock();  finished  =  true;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	95	None	replace
138	[BUG]  [BUGGY]  else  if(closed)  {  writeIOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(closed)  {  writeIOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(closed)  {  writeIOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	95	None	replace
139	[BUG]  [BUGGY]  if(!finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	95	None	replace
140	[BUG]  [BUGGY]  if(buffer!=  null)  {  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(buffer!=  null)  {  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(buffer!=  null)  {  writeEOFRecord();  }  else  {  buffer.flushBlock();  }	  writeEOFRecord();    	non-compiled	[CE]  <identifier>  expected	98	None	replace
141	[BUG]  [BUGGY]  if(closed)  {  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  writeEOFRecord();  }  else  {  buffer.flushBlock();  }	  writeEOFRecord();    	non-compiled	[CE]  <identifier>  expected	98	None	replace
142	[BUG]  [BUGGY]  if(!closed)  {  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  writeEOFRecord();  }  else  {  buffer.flushBlock();  }	  writeEOFRecord();    	non-compiled	[CE]  <identifier>  expected	98	None	replace
143	[BUG]  [BUGGY]  if(buffer!=  null)  {  writeEOFRecord();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(buffer!=  null)  {  writeEOFRecord();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(buffer!=  null)  {  writeEOFRecord();  }  else  {  buffer.close();  }	  writeEOFRecord();    	non-compiled	[CE]  <identifier>  expected	98	None	replace
144	[BUG]  [BUGGY]  if(!closed)  {  writeEOFRecord();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  writeEOFRecord();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  writeEOFRecord();  }	  writeEOFRecord();    	non-compiled	[CE]  <identifier>  expected	98	None	replace
145	[BUG]  [BUGGY]  if(buffer!=  null)  {  writeEOFRecord();  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(buffer!=  null)  {  writeEOFRecord();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(buffer!=  null)  {  writeEOFRecord();  }	  writeEOFRecord();    	non-compiled	[CE]  <identifier>  expected	98	None	replace
146	[BUG]  [BUGGY]  readEOFRecord();  buffer.flushBlock();  endBlock();  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  readEOFRecord();  buffer.flushBlock();  endBlock();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	readEOFRecord();  buffer.flushBlock();  endBlock();	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	63	None	replace
147	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_ERROR  ||  endBlock();  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_ERROR  ||  endBlock();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_ERROR  ||  endBlock();	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	63	None	replace
148	[BUG]  [BUGGY]  EndBlock  <  T>  endBlock  =  new  EndBlock  <  T>(currName);  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  T>  endBlock  =  new  EndBlock  <  T>(currName);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  T>  endBlock  =  new  EndBlock  <  T>(currName);	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	63	None	replace
149	[BUG]  [BUGGY]  EndBlock  <  Object>  endBlock  =  new  EndBlock  <  Object>();  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  Object>  endBlock  =  new  EndBlock  <  Object>();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  Object>  endBlock  =  new  EndBlock  <  Object>();	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	63	None	replace
150	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_ERROR)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_ERROR)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_ERROR)  {  finished  =  false;  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	63	None	replace
151	[BUG]  [BUGGY]  EndBlock  <  Tar>  endBlock  =  new  EndBlock  <  Tar>();  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  Tar>  endBlock  =  new  EndBlock  <  Tar>();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  Tar>  endBlock  =  new  EndBlock  <  Tar>();	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	63	None	replace
152	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	81	None	replace
153	[BUG]  [BUGGY]  final  hasUnclosedEntry  =  false;  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  final  hasUnclosedEntry  =  false;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	final  hasUnclosedEntry  =  false;	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	81	None	replace
154	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  currName,  currSize);  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  currName,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  currName,  currSize);  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	81	None	replace
155	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  currName,  currSize,  currSize);  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  currName,  currSize,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  currName,  currSize,  currSize);  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	81	None	replace
156	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  currSize,  currSize,  currSize);  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  currSize,  currSize,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  currSize,  currSize,  currSize);  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	81	None	replace
157	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  currSize,  currSize);  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  currSize,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  currSize,  currSize);  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	81	None	replace
158	[BUG]  [BUGGY]  os.writeEndByteBuffer();  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.writeEndByteBuffer();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.writeEndByteBuffer();	  os.flushBuffer();    	non-compiled	[CE]  <identifier>  expected	100	None	replace
159	[BUG]  [BUGGY]  os.writeBytes(currName);  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.writeBytes(currName);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.writeBytes(currName);	  os.flushBuffer();    	non-compiled	[CE]  <identifier>  expected	100	None	replace
160	[BUG]  [BUGGY]  os.writeEndBuffer();  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.writeEndBuffer();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.writeEndBuffer();	  os.flushBuffer();    	non-compiled	[CE]  <identifier>  expected	100	None	replace
161	[BUG]  [BUGGY]  os.writeEndBytes(recordBuf);  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.writeEndBytes(recordBuf);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.writeEndBytes(recordBuf);	  os.flushBuffer();    	non-compiled	[CE]  <identifier>  expected	100	None	replace
162	[BUG]  [BUGGY]  if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(haveUnclosedEntry)    {    finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	80	None	replace
163	[BUG]  [BUGGY]  if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  }	  if(haveUnclosedEntry)    {    finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	80	None	replace
164	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(haveUnclosedEntry)    {    finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	80	None	replace
165	[BUG]  [BUGGY]  if(closed)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(haveUnclosedEntry)    {    finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	80	None	replace
166	[BUG]  [BUGGY]  if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	80	None	replace
167	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	32	None	replace
168	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	32	None	replace
169	[BUG]  [BUGGY]  after(recordBuf,  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(recordBuf,  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(recordBuf,  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	32	None	replace
170	[BUG]  [BUGGY]  after(recordBuf)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(recordBuf)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(recordBuf)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	32	None	replace
171	[BUG]  [BUGGY]  after(recordBuf,  0,  out.length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(recordBuf,  0,  out.length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(recordBuf,  0,  out.length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	32	None	replace
172	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	27	None	replace
173	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	27	None	replace
174	[BUG]  [BUGGY]  AfterOperation  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterOperation  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterOperation  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	27	None	replace
175	[BUG]  [BUGGY]  AfterOperator  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterOperator  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterOperator  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	27	None	replace
176	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	132	None	replace
177	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	132	None	replace
178	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	132	None	replace
179	[BUG]  [BUGGY]  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	132	None	replace
180	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	132	None	replace
181	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	132	None	replace
182	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  EndBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  EndBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  EndBlock();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	132	None	replace
183	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	71	None	replace
184	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	71	None	replace
185	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	71	None	replace
186	[BUG]  [BUGGY]  while(!finished  &&  buffer.isOpen())  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  buffer.isOpen())  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  buffer.isOpen())  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	71	None	replace
187	[BUG]  [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
188	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
189	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
190	[BUG]  [BUGGY]  while(!finished  &&  buffer.hasMoreElements())  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  buffer.hasMoreElements())  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  buffer.hasMoreElements())  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
191	[BUG]  [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
192	[BUG]  [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start();  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
193	[BUG]  [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  stop();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  stop();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  stop();  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
194	[BUG]  [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	68	None	replace
195	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	68	None	replace
196	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	68	None	replace
197	[BUG]  [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	68	None	replace
198	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	18	None	replace
199	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	18	None	replace
200	[BUG]  [BUGGY]  if(finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	18	None	replace
201	[BUG]  [BUGGY]  readEOFRecord();  buffer.flushBlock();  wrapped  =  true;  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  readEOFRecord();  buffer.flushBlock();  wrapped  =  true;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	readEOFRecord();  buffer.flushBlock();  wrapped  =  true;	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	43	None	replace
202	[BUG]  [BUGGY]  after(readEOFRecord(),  buffer.flushBlock());  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(readEOFRecord(),  buffer.flushBlock());  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(readEOFRecord(),  buffer.flushBlock());	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	43	None	replace
203	[BUG]  [BUGGY]  Thread.currentThread().getContextClassLoader().finish();  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Thread.currentThread().getContextClassLoader().finish();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Thread.currentThread().getContextClassLoader().finish();	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	43	None	replace
204	[BUG]  [BUGGY]  if(closed)  {  if(currName  ==  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(currName  ==  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(currName  ==  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(currName    ==    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	78	None	replace
205	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  ==  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(currName    ==    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	78	None	replace
206	[BUG]  [BUGGY]  if(currName  ==  null  ||  currName.length()  ==  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null  ||  currName.length()  ==  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null  ||  currName.length()  ==  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(currName    ==    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	78	None	replace
207	[BUG]  [BUGGY]  if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }	  if(currName    ==    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	78	None	replace
208	[BUG]  [BUGGY]  if(closed)  {  if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(currName!=    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	50	None	replace
209	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  <  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  <  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  <  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(currName!=    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	50	None	replace
210	[BUG]  [BUGGY]  AfterOperation  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterOperation  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterOperation  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	91	None	replace
211	[BUG]  [BUGGY]  AfterEOF()  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterEOF()  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterEOF()  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	91	None	replace
212	[BUG]  [BUGGY]  AfterOperation  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterOperation  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterOperation  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  finishEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	91	None	replace
213	[BUG]  [BUGGY]  AfterOperation  {  finished  =  false;  }  else  if(closed)  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterOperation  {  finished  =  false;  }  else  if(closed)  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterOperation  {  finished  =  false;  }  else  if(closed)  {  finishEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	91	None	replace
214	[BUG]  [BUGGY]  AfterEOF()  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterEOF()  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterEOF()  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	91	None	replace
215	[BUG]  [BUGGY]  AfterOperation  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterOperation  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterOperation  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	91	None	replace
216	[BUG]  [BUGGY]  AfterEOF()  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterEOF()  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterEOF()  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	91	None	replace
217	[BUG]  [BUGGY]  Parchet.getInstance().completeAndClearBuffer(buffer);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Parchet.getInstance().completeAndClearBuffer(buffer);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Parchet.getInstance().completeAndClearBuffer(buffer);	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	56	None	replace
218	[BUG]  [BUGGY]  Parchet.getInstance().completeAndClearBuffer(buffer,  closed);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Parchet.getInstance().completeAndClearBuffer(buffer,  closed);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Parchet.getInstance().completeAndClearBuffer(buffer,  closed);	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	56	None	replace
219	[BUG]  [BUGGY]  Parchet.getInstance().finish(buffer,  LONGFILE_GNU);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Parchet.getInstance().finish(buffer,  LONGFILE_GNU);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Parchet.getInstance().finish(buffer,  LONGFILE_GNU);	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	56	None	replace
220	[BUG]  [BUGGY]  Parchet.getInstance().completeAndClearBuffer(buffer,  assemLen);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Parchet.getInstance().completeAndClearBuffer(buffer,  assemLen);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Parchet.getInstance().completeAndClearBuffer(buffer,  assemLen);	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	56	None	replace
221	[BUG]  [BUGGY]  Parchet.getInstance().completeAndClearBuffer(buffer,  finished);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Parchet.getInstance().completeAndClearBuffer(buffer,  finished);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Parchet.getInstance().completeAndClearBuffer(buffer,  finished);	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	56	None	replace
222	[BUG]  [BUGGY]  Parchet.getInstance().completeAndClearBuffer(buffer,  currName);  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Parchet.getInstance().completeAndClearBuffer(buffer,  currName);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Parchet.getInstance().completeAndClearBuffer(buffer,  currName);	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	56	None	replace
223	[BUG]  [BUGGY]  if(!finished)  {  readEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  readEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  readEOFRecord();  buffer.flushBlock();  }	  readEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	28	None	replace
224	[BUG]  [BUGGY]  if(closed)  {  readEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  readEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  readEOFRecord();  buffer.flushBlock();  }	  readEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	28	None	replace
225	[BUG]  [BUGGY]  if(currName!=  null)  {  readEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  readEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  readEOFRecord();  buffer.flushBlock();  }	  readEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	28	None	replace
226	[BUG]  [BUGGY]  if(!closed)  {  readEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  readEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  readEOFRecord();  buffer.flushBlock();  }	  readEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	28	None	replace
227	[BUG]  [BUGGY]  if(currName  ==  null)  {  readEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  readEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  readEOFRecord();  buffer.flushBlock();  }	  readEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	28	None	replace
228	[BUG]  [BUGGY]  if(finished)  {  readEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  readEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  readEOFRecord();  buffer.flushBlock();  }	  readEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	28	None	replace
229	[BUG]  [BUGGY]  if(currName!=  null)  {  readEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  readEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  readEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }	  readEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	28	None	replace
230	[BUG]  [BUGGY]  finished  =  new  byte[LONGFILE_ERROR];  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  new  byte[LONGFILE_ERROR];  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  new  byte[LONGFILE_ERROR];	  finished    =   "   ";    	non-compiled	[CE]  <identifier>  expected	115	None	replace
231	[BUG]  [BUGGY]  finished  =  new  StringBuffer(LONGFILE_ERROR,  currName);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  new  StringBuffer(LONGFILE_ERROR,  currName);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  new  StringBuffer(LONGFILE_ERROR,  currName);	  finished    =   "   ";    	non-compiled	[CE]  <identifier>  expected	115	None	replace
232	[BUG]  [BUGGY]  finished  =  new  StringBuffer(LONGFILE_ERROR.toString());  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  new  StringBuffer(LONGFILE_ERROR.toString());  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  new  StringBuffer(LONGFILE_ERROR.toString());	  finished    =   "   ";    	non-compiled	[CE]  <identifier>  expected	115	None	replace
233	[BUG]  [BUGGY]  if(currName  ==  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	142	None	replace
234	[BUG]  [BUGGY]  if(closed)  {  if(currName!=  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(currName!=  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(currName!=  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	142	None	replace
235	[BUG]  [BUGGY]  if(!finished)  {  if(currName!=  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  if(currName!=  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  if(currName!=  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	142	None	replace
236	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	142	None	replace
237	[BUG]  [BUGGY]  if(closed)  {  if(currName  ==  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(currName  ==  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(currName  ==  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	142	None	replace
238	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  <  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  <  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  <  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	142	None	replace
239	[BUG]  [BUGGY]  EndBlock  <  Tar>  endBlock  =  new  EndBlock  <  Tar>(currName.length());  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  Tar>  endBlock  =  new  EndBlock  <  Tar>(currName.length());  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  Tar>  endBlock  =  new  EndBlock  <  Tar>(currName.length());	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	106	None	replace
240	[BUG]  [BUGGY]  EndBlock  <  T>  endBlock  =  new  EndBlock  <  T>(currName.length());  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  T>  endBlock  =  new  EndBlock  <  T>(currName.length());  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  T>  endBlock  =  new  EndBlock  <  T>(currName.length());	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	106	None	replace
241	[BUG]  [BUGGY]  EndBlock  <  T>  endBlock  =  new  EndBlock  <  T>(length());  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  T>  endBlock  =  new  EndBlock  <  T>(length());  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  T>  endBlock  =  new  EndBlock  <  T>(length());	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	106	None	replace
242	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	89	None	replace
243	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	89	None	replace
244	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	89	None	replace
245	[BUG]  [BUGGY]  if(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	89	None	replace
246	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	89	None	replace
247	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	89	None	replace
248	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	48	None	replace
249	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	48	None	replace
250	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	48	None	replace
251	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	48	None	replace
252	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	36	None	replace
253	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	36	None	replace
254	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  breakEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  breakEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  breakEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	36	None	replace
255	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  began  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  began  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  began  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	36	None	replace
256	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	79	None	replace
257	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	79	None	replace
258	[BUG]  [BUGGY]  if(!finished)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	79	None	replace
259	[BUG]  [BUGGY]  if(!finished)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	79	None	replace
260	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	79	None	replace
261	[BUG]  [BUGGY]  buffer.flushBlock();  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  buffer.flushBlock();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	buffer.flushBlock();	  buffer.close();    	non-compiled	[CE]  <identifier>  expected	99	None	replace
262	[BUG]  [BUGGY]  buffer.flushBuffer();  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  buffer.flushBuffer();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	buffer.flushBuffer();	  buffer.close();    	non-compiled	[CE]  <identifier>  expected	99	None	replace
263	[BUG]  [BUGGY]  buffer.flush();  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  buffer.flush();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	buffer.flush();	  buffer.close();    	non-compiled	[CE]  <identifier>  expected	99	None	replace
264	[BUG]  [BUGGY]  buffer.writeBytes(assemBuf,  0,  assemLen);  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  buffer.writeBytes(assemBuf,  0,  assemLen);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	buffer.writeBytes(assemBuf,  0,  assemLen);	  buffer.close();    	non-compiled	[CE]  <identifier>  expected	99	None	replace
265	[BUG]  [BUGGY]  buffer.write(assemBuf,  0,  assemLen);  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  buffer.write(assemBuf,  0,  assemLen);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	buffer.write(assemBuf,  0,  assemLen);	  buffer.close();    	non-compiled	[CE]  <identifier>  expected	99	None	replace
266	[BUG]  [BUGGY]  buffer.flushCurrentSize();  [CE]  <identifier>  expected  [FE]                                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  buffer.flushCurrentSize();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	buffer.flushCurrentSize();	  buffer.close();    	non-compiled	[CE]  <identifier>  expected	99	None	replace
267	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	124	None	replace
268	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	124	None	replace
269	[BUG]  [BUGGY]  if(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	124	None	replace
270	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	124	None	replace
271	[BUG]  [BUGGY]  if(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	124	None	replace
272	[BUG]  [BUGGY]  if(currName  ==  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	143	None	replace
273	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	143	None	replace
274	[BUG]  [BUGGY]  if(closed)  {  if(currName!=  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(currName!=  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(currName!=  null)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	143	None	replace
275	[BUG]  [BUGGY]  if(currName  ==  null  ||  currName.length()  ==  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null  ||  currName.length()  ==  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null  ||  currName.length()  ==  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	143	None	replace
276	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  <  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  <  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  <  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	143	None	replace
277	[BUG]  [BUGGY]  if(currName!=  null)  {  buffer.close();  writeEOFRecord();  }  [CE]  <identifier>  expected  [FE]                                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  buffer.close();  writeEOFRecord();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  buffer.close();  writeEOFRecord();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	143	None	replace
278	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	88	None	replace
279	[BUG]  [BUGGY]  if(closed)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	88	None	replace
280	[BUG]  [BUGGY]  if(closed)  {  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	88	None	replace
281	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	88	None	replace
282	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  endBlock();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  endBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	64	None	replace
283	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	64	None	replace
284	[BUG]  [BUGGY]  os.write(buffer,  0,  buffer.length  +  1);  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.write(buffer,  0,  buffer.length  +  1);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.write(buffer,  0,  buffer.length  +  1);	  os.write(buffer,    0,    buffer.length);    	non-compiled	[CE]  <identifier>  expected	101	None	replace
285	[BUG]  [BUGGY]  os.write(buffer,  0,  buffer.length  -  1);  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.write(buffer,  0,  buffer.length  -  1);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.write(buffer,  0,  buffer.length  -  1);	  os.write(buffer,    0,    buffer.length);    	non-compiled	[CE]  <identifier>  expected	101	None	replace
286	[BUG]  [BUGGY]  os.write(assemBuf,  0,  buffer.length);  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.write(assemBuf,  0,  buffer.length);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.write(assemBuf,  0,  buffer.length);	  os.write(buffer,    0,    buffer.length);    	non-compiled	[CE]  <identifier>  expected	101	None	replace
287	[BUG]  [BUGGY]  os.write(buffer,  0,  buffer.length  +  2);  [CE]  <identifier>  expected  [FE]                                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.write(buffer,  0,  buffer.length  +  2);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.write(buffer,  0,  buffer.length  +  2);	  os.write(buffer,    0,    buffer.length);    	non-compiled	[CE]  <identifier>  expected	101	None	replace
288	[BUG]  [BUGGY]  os.write(buffer,  0,  buffer.length  -  2);  [CE]  <identifier>  expected  [FE]                                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.write(buffer,  0,  buffer.length  -  2);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.write(buffer,  0,  buffer.length  -  2);	  os.write(buffer,    0,    buffer.length);    	non-compiled	[CE]  <identifier>  expected	101	None	replace
289	[BUG]  [BUGGY]  os.write(buffer,  0,  buffer.length  +  4);  [CE]  <identifier>  expected  [FE]                                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.write(buffer,  0,  buffer.length  +  4);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.write(buffer,  0,  buffer.length  +  4);	  os.write(buffer,    0,    buffer.length);    	non-compiled	[CE]  <identifier>  expected	101	None	replace
290	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.write(assemBuf,    0,    currSize);    }    	non-compiled	[CE]  <identifier>  expected	33	None	replace
291	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.write(assemBuf,    0,    currSize);    }    	non-compiled	[CE]  <identifier>  expected	33	None	replace
292	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.writeBlock();  out.write(assemBuf,  0,  currSize);  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.writeBlock();  out.write(assemBuf,  0,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  buffer.writeBlock();  out.write(assemBuf,  0,  currSize);  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.write(assemBuf,    0,    currSize);    }    	non-compiled	[CE]  <identifier>  expected	33	None	replace
293	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.write(assemBuf,    0,    currSize);    }    	non-compiled	[CE]  <identifier>  expected	33	None	replace
294	[BUG]  [BUGGY]  After(assemLen)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  After(assemLen)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	After(assemLen)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.write(assemBuf,    0,    currSize);    }    	non-compiled	[CE]  <identifier>  expected	33	None	replace
295	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.write(assemBuf,    0,    currSize);    }    	non-compiled	[CE]  <identifier>  expected	33	None	replace
296	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.writeBlock();  out.write(assemBuf,  0,  currSize);  }  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.writeBlock();  out.write(assemBuf,  0,  currSize);  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.writeBlock();  out.write(assemBuf,  0,  currSize);  }  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.write(assemBuf,    0,    currSize);    }    	non-compiled	[CE]  <identifier>  expected	33	None	replace
297	[BUG]  [BUGGY]  finish  =  false;  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  =  false;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  =  false;	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
298	[BUG]  [BUGGY]  finish  |=  JsonStringEncoder.getInstance().encodeAsEOF(currName));  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  |=  JsonStringEncoder.getInstance().encodeAsEOF(currName));  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  |=  JsonStringEncoder.getInstance().encodeAsEOF(currName));	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
299	[BUG]  [BUGGY]  finish  |=  JsonStringEncoder.getInstance().encodeAsEOF(currName,  buffer.length()  -  1);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  |=  JsonStringEncoder.getInstance().encodeAsEOF(currName,  buffer.length()  -  1);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  |=  JsonStringEncoder.getInstance().encodeAsEOF(currName,  buffer.length()  -  1);	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
300	[BUG]  [BUGGY]  finish  |=  JsonStringEncoder.getInstance().encodeAsIOd(currName));  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  |=  JsonStringEncoder.getInstance().encodeAsIOd(currName));  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  |=  JsonStringEncoder.getInstance().encodeAsIOd(currName));	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
301	[BUG]  [BUGGY]  finish  |=  JsonStringEncoder.getInstance().encodeAsEOF(currName,  buffer.length()));  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  |=  JsonStringEncoder.getInstance().encodeAsEOF(currName,  buffer.length()));  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  |=  JsonStringEncoder.getInstance().encodeAsEOF(currName,  buffer.length()));	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
302	[BUG]  [BUGGY]  finish  |=  JsonStringEncoder.getInstance().encodeAsEOF(currName);  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  |=  JsonStringEncoder.getInstance().encodeAsEOF(currName);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  |=  JsonStringEncoder.getInstance().encodeAsEOF(currName);	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
303	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	117	None	replace
304	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	117	None	replace
305	[BUG]  [BUGGY]  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	117	None	replace
306	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	117	None	replace
307	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	117	None	replace
308	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	59	None	replace
309	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	59	None	replace
310	[BUG]  [BUGGY]  if(!closed)  {  finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	59	None	replace
311	[BUG]  [BUGGY]  if(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	59	None	replace
312	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock  <  LONGFILE_GNU>();  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock  <  LONGFILE_GNU>();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock  <  LONGFILE_GNU>();	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	107	None	replace
313	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock  <  LONGFILE_GNU>(LONGFILE_GNU);  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock  <  LONGFILE_GNU>(LONGFILE_GNU);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock  <  LONGFILE_GNU>(LONGFILE_GNU);	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	107	None	replace
314	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock  <  LONGFILE_GNU>(currName);  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock  <  LONGFILE_GNU>(currName);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock  <  LONGFILE_GNU>(currName);	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	107	None	replace
315	[BUG]  [BUGGY]  EndBlock  <  EOFRecord>  endBlock  =  new  EndBlock  <  EOFRecord>();  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  EOFRecord>  endBlock  =  new  EndBlock  <  EOFRecord>();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  EOFRecord>  endBlock  =  new  EndBlock  <  EOFRecord>();	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	107	None	replace
316	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock  <  LONGFILE_GNU>(length());  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock  <  LONGFILE_GNU>(length());  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock  <  LONGFILE_GNU>(length());	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	107	None	replace
317	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_ERROR  ||  finished  =  false;  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_ERROR  ||  finished  =  false;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_ERROR  ||  finished  =  false;	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	107	None	replace
318	[BUG]  [BUGGY]  if(currName  ==  null)  {  buffer.flush();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  buffer.flush();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  buffer.flush();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    buffer.flush();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	144	None	replace
319	[BUG]  [BUGGY]  if(currName!=  null)  {  buffer.flush();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  buffer.flush();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  buffer.flush();  }	  if(currName!=    null)    {    buffer.flush();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	144	None	replace
320	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.flush();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.flush();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.flush();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    buffer.flush();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	144	None	replace
321	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.flush();  }  [CE]  <identifier>  expected  [FE]                                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.flush();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.flush();  }	  if(currName!=    null)    {    buffer.flush();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	144	None	replace
322	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  buffer.flush();  }  [CE]  <identifier>  expected  [FE]                                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  buffer.flush();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  buffer.flush();  }	  if(currName!=    null)    {    buffer.flush();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	144	None	replace
323	[BUG]  [BUGGY]  if(currName  ==  null)  {  buffer.flush();  }  [CE]  <identifier>  expected  [FE]                                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  buffer.flush();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  buffer.flush();  }	  if(currName!=    null)    {    buffer.flush();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	144	None	replace
324	[BUG]  [BUGGY]  after(length)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(length)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(length)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	15	None	replace
325	[BUG]  [BUGGY]  after(length)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBuffer();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(length)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBuffer();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(length)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBuffer();  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	15	None	replace
326	[BUG]  [BUGGY]  castError( "Tar  archive  has  already  been  finished. ");  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  castError( "Tar  archive  has  already  been  finished. ");  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	castError( "Tar  archive  has  already  been  finished. ");	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	15	None	replace
327	[BUG]  [BUGGY]  after(length)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  block.flushBlock();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(length)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  block.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(length)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  block.flushBlock();  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	15	None	replace
328	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	82	None	replace
329	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	82	None	replace
330	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	82	None	replace
331	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	82	None	replace
332	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	125	None	replace
333	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	125	None	replace
334	[BUG]  [BUGGY]  if(!finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	125	None	replace
335	[BUG]  [BUGGY]  if(!finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	125	None	replace
336	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(!closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	55	None	replace
337	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(!closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	55	None	replace
338	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }	  if(!closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	55	None	replace
339	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }	  if(!closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	55	None	replace
340	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(!closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	55	None	replace
341	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	52	None	replace
342	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	52	None	replace
343	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	52	None	replace
344	[BUG]  [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	52	None	replace
345	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	52	None	replace
346	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	87	None	replace
347	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	87	None	replace
348	[BUG]  [BUGGY]  if(!closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	87	None	replace
349	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	102	None	replace
350	[BUG]  [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	102	None	replace
351	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	102	None	replace
352	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	102	None	replace
353	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	102	None	replace
354	[BUG]  [BUGGY]  if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	49	None	replace
355	[BUG]  [BUGGY]  if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	49	None	replace
356	[BUG]  [BUGGY]  if(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	49	None	replace
357	[BUG]  [BUGGY]  if(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	49	None	replace
358	[BUG]  [BUGGY]  if(!finished)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	49	None	replace
359	[BUG]  [BUGGY]  if(!finished)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	49	None	replace
360	[BUG]  [BUGGY]  if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName.charAt(i));    }    	non-compiled	[CE]  <identifier>  expected	14	None	replace
361	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName.charAt(i));    }    	non-compiled	[CE]  <identifier>  expected	14	None	replace
362	[BUG]  [BUGGY]  if(buffer!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }  [CE]  <identifier>  expected  [FE]                                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(buffer!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(buffer!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName.charAt(i));    }    	non-compiled	[CE]  <identifier>  expected	14	None	replace
363	[BUG]  [BUGGY]  if(closed)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }  [CE]  <identifier>  expected  [FE]                                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName.charAt(i));    }    	non-compiled	[CE]  <identifier>  expected	14	None	replace
364	[BUG]  [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i  +  1));  }  [CE]  <identifier>  expected  [FE]                                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i  +  1));  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i  +  1));  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName.charAt(i));    }    	non-compiled	[CE]  <identifier>  expected	14	None	replace
365	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt  [CE]  <identifier>  expected  [FE]                                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName.charAt(i));    }    	non-compiled	[CE]  <identifier>  expected	14	None	replace
366	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	108	None	replace
367	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	108	None	replace
368	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  writeEOFRecord();    buffer.flushBlock();    finished    =    true;    	non-compiled	[CE]  <identifier>  expected	120	None	replace
369	[BUG]  [BUGGY]  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  writeEOFRecord();    buffer.flushBlock();    finished    =    true;    	non-compiled	[CE]  <identifier>  expected	120	None	replace
370	[BUG]  [BUGGY]  if(!closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  writeEOFRecord();    buffer.flushBlock();    finished    =    true;    	non-compiled	[CE]  <identifier>  expected	120	None	replace
371	[BUG]  [BUGGY]  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	writeEOFRecord();  buffer.flushBlock();  finished  =  false;	  writeEOFRecord();    buffer.flushBlock();    finished    =    true;    	non-compiled	[CE]  <identifier>  expected	120	None	replace
372	[BUG]  [BUGGY]  if(finish)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finish)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finish)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  writeEOFRecord();    buffer.flushBlock();    finished    =    true;    	non-compiled	[CE]  <identifier>  expected	120	None	replace
373	[BUG]  [BUGGY]  AfterEOF()  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterEOF()  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterEOF()  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    true;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	138	None	replace
374	[BUG]  [BUGGY]  AfterEOF()  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterEOF()  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterEOF()  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }	  if(finished)    {    finished    =    true;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	138	None	replace
375	[BUG]  [BUGGY]  AfterEOF()  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterEOF()  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterEOF()  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }	  if(finished)    {    finished    =    true;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	138	None	replace
376	[BUG]  [BUGGY]  AfterEOF()  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterEOF()  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterEOF()  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();	  if(finished)    {    finished    =    true;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	138	None	replace
377	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    completed    =    true;    }    	non-compiled	[CE]  <identifier>  expected	126	None	replace
378	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    completed    =    true;    }    	non-compiled	[CE]  <identifier>  expected	126	None	replace
379	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    completed    =    true;    }    	non-compiled	[CE]  <identifier>  expected	126	None	replace
380	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    completed    =    true;    }    	non-compiled	[CE]  <identifier>  expected	126	None	replace
381	[BUG]  [BUGGY]  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    completed    =    true;    }    	non-compiled	[CE]  <identifier>  expected	126	None	replace
382	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    completed    =    true;    }    	non-compiled	[CE]  <identifier>  expected	126	None	replace
383	[BUG]  [BUGGY]  after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	29	None	replace
384	[BUG]  [BUGGY]  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	29	None	replace
385	[BUG]  [BUGGY]  after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.closeBlock();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.closeBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.closeBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	29	None	replace
386	[BUG]  [BUGGY]  Parchet.getInstance().finishCurrentStructure(buffer,  LONGFILE_GNU);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Parchet.getInstance().finishCurrentStructure(buffer,  LONGFILE_GNU);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Parchet.getInstance().finishCurrentStructure(buffer,  LONGFILE_GNU);	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	29	None	replace
387	[BUG]  [BUGGY]  after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	29	None	replace
388	[BUG]  [BUGGY]  if(closed)  {  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	38	None	replace
389	[BUG]  [BUGGY]  if(closed)  {  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	38	None	replace
390	[BUG]  [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	5	None	replace
391	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	5	None	replace
392	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	5	None	replace
393	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	5	None	replace
394	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	5	None	replace
395	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	5	None	replace
396	[BUG]  [BUGGY]  os.write('n');  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.write('n');  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.write('n');	  os.flush();    	non-compiled	[CE]  <identifier>  expected	96	None	replace
397	[BUG]  [BUGGY]  os.writeEndBytes();  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.writeEndBytes();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.writeEndBytes();	  os.flush();    	non-compiled	[CE]  <identifier>  expected	96	None	replace
398	[BUG]  [BUGGY]  os.write(currName);  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.write(currName);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.write(currName);	  os.flush();    	non-compiled	[CE]  <identifier>  expected	96	None	replace
399	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	127	None	replace
400	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	127	None	replace
401	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	127	None	replace
402	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start();  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	127	None	replace
403	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	127	None	replace
404	[BUG]  [BUGGY]  if(!finished)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  writeEOFRecord();  buffer.flushBlock();  }	  writeEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	11	None	replace
405	[BUG]  [BUGGY]  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  writeEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	11	None	replace
406	[BUG]  [BUGGY]  if(!closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  writeEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	11	None	replace
407	[BUG]  [BUGGY]  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  writeEOFRecord();  buffer.flushBlock();  }	  writeEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	11	None	replace
408	[BUG]  [BUGGY]  if(isEnabled(Feature.AUTO_CLOSE_ERROR))  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(isEnabled(Feature.AUTO_CLOSE_ERROR))  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(isEnabled(Feature.AUTO_CLOSE_ERROR))  {  writeEOFRecord();  buffer.flushBlock();  }	  writeEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	11	None	replace
409	[BUG]  [BUGGY]  if(currName  ==  null)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  writeEOFRecord();  buffer.flushBlock();  }	  writeEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	11	None	replace
410	[BUG]  [BUGGY]  finally(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finally(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finally(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	121	None	replace
411	[BUG]  [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	121	None	replace
412	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.write(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	12	None	replace
413	[BUG]  [BUGGY]  if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.write(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	12	None	replace
414	[BUG]  [BUGGY]  while(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.write(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	12	None	replace
415	[BUG]  [BUGGY]  if(closed)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.write(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	12	None	replace
416	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  [CE]  <identifier>  expected  [FE]                                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.write(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	12	None	replace
417	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  buffer.write(currName[i]);  [CE]  <identifier>  expected  [FE]                                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  buffer.write(currName[i]);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  buffer.write(currName[i]);	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.write(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	12	None	replace
418	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	16	None	replace
419	[BUG]  [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	16	None	replace
420	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	16	None	replace
421	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	16	None	replace
422	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	16	None	replace
423	[BUG]  [BUGGY]  while(!finished  &&  closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	16	None	replace
424	[BUG]  [BUGGY]  done  =  false;  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  done  =  false;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	done  =  false;	  done    =    true;    	non-compiled	[CE]  <identifier>  expected	116	None	replace
425	[BUG]  [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  }	  done    =    true;    	non-compiled	[CE]  <identifier>  expected	116	None	replace
426	[BUG]  [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }	  done    =    true;    	non-compiled	[CE]  <identifier>  expected	116	None	replace
427	[BUG]  [BUGGY]  done  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  done  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	done  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  }	  done    =    true;    	non-compiled	[CE]  <identifier>  expected	116	None	replace
428	[BUG]  [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  done    =    true;    	non-compiled	[CE]  <identifier>  expected	116	None	replace
429	[BUG]  [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  done    =    true;    	non-compiled	[CE]  <identifier>  expected	116	None	replace
430	[BUG]  [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  done    =    true;    	non-compiled	[CE]  <identifier>  expected	116	None	replace
431	[BUG]  [BUGGY]  finally(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finally(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finally(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	94	None	replace
432	[BUG]  [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	94	None	replace
433	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	94	None	replace
434	[BUG]  [BUGGY]  if(currName!=  null)  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	141	None	replace
435	[BUG]  [BUGGY]  if(currName  ==  null)  {  buffer.close();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  buffer.close();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  buffer.close();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	141	None	replace
436	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	141	None	replace
437	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.close();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.close();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  ==  0)  {  buffer.close();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	141	None	replace
438	[BUG]  [BUGGY]  if(currName  ==  null)  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	141	None	replace
439	[BUG]  [BUGGY]  if(currName  ==  null  ||  currName.length()  ==  0)  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null  ||  currName.length()  ==  0)  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null  ||  currName.length()  ==  0)  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	141	None	replace
440	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	105	None	replace
441	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	105	None	replace
442	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrap  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrap  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrap  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	105	None	replace
443	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  sealed  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  sealed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  sealed  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	105	None	replace
444	[BUG]  [BUGGY]  while(!finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  while(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	103	None	replace
445	[BUG]  [BUGGY]  while(true)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(true)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(true)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  while(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	103	None	replace
446	[BUG]  [BUGGY]  while(!cloned)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!cloned)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!cloned)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  while(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	103	None	replace
447	[BUG]  [BUGGY]  while(!finished)  {  wrapped  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  wrapped  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  wrapped  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  while(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	103	None	replace
448	[BUG]  [BUGGY]  While(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  While(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	While(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  while(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	103	None	replace
449	[BUG]  [BUGGY]  after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	7	None	replace
450	[BUG]  [BUGGY]  after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	7	None	replace
451	[BUG]  [BUGGY]  after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	7	None	replace
452	[BUG]  [BUGGY]  after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  stop();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  stop();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  stop();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	7	None	replace
453	[BUG]  [BUGGY]  after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  begin();  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  begin();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  begin();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	7	None	replace
454	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(!closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	26	None	replace
455	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }	  if(!closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	26	None	replace
456	[BUG]  [BUGGY]  if(isEnabled(Feature.QUOTE_FIELD_NAMES))  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(isEnabled(Feature.QUOTE_FIELD_NAMES))  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(isEnabled(Feature.QUOTE_FIELD_NAMES))  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(!closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	26	None	replace
457	[BUG]  [BUGGY]  if(isEnabled(Feature.QUOTE_FIELD_NAMES))  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(isEnabled(Feature.QUOTE_FIELD_NAMES))  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(isEnabled(Feature.QUOTE_FIELD_NAMES))  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }	  if(!closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	26	None	replace
458	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  ==  0)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(currName!=    null)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	140	None	replace
459	[BUG]  [BUGGY]  if(currName  ==  null  ||  currName.length()  ==  0)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null  ||  currName.length()  ==  0)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null  ||  currName.length()  ==  0)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(currName!=    null)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	140	None	replace
460	[BUG]  [BUGGY]  if(currName!=  null)  {  writeEOFRecord();  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  writeEOFRecord();  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  writeEOFRecord();  buffer.close();  }	  if(currName!=    null)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	140	None	replace
461	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	44	None	replace
462	[BUG]  [BUGGY]  if(closed)  {  if(finished)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(finished)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(finished)  {  finished  =  false;  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	44	None	replace
463	[BUG]  [BUGGY]  if(closed)  {  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	44	None	replace
464	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	130	None	replace
465	[BUG]  [BUGGY]  Finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	130	None	replace
466	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finish  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finish  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finish  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	130	None	replace
467	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	130	None	replace
468	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  completed  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  completed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  completed  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	130	None	replace
469	[BUG]  [BUGGY]  if(closed)  {  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	135	None	replace
470	[BUG]  [BUGGY]  if(finished)  {  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	135	None	replace
471	[BUG]  [BUGGY]  else  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	135	None	replace
472	[BUG]  [BUGGY]  while(!closed)  {  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	135	None	replace
473	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	123	None	replace
474	[BUG]  [BUGGY]  if(!closed)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	123	None	replace
475	[BUG]  [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	66	None	replace
476	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	66	None	replace
477	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	66	None	replace
478	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_ERROR  ||  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_ERROR  ||  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_ERROR  ||  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	66	None	replace
479	[BUG]  [BUGGY]  if(closed)  {  if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(currName!=    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	76	None	replace
480	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(currName!=    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	76	None	replace
481	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  <  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  <  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  <  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(currName!=    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	76	None	replace
482	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	6	None	replace
483	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	6	None	replace
484	[BUG]  [BUGGY]  if(!finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	6	None	replace
485	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	6	None	replace
486	[BUG]  [BUGGY]  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	6	None	replace
487	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  end();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	6	None	replace
488	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	65	None	replace
489	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	65	None	replace
490	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	65	None	replace
491	[BUG]  [BUGGY]  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	134	None	replace
492	[BUG]  [BUGGY]  if(!finished)  {  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	134	None	replace
493	[BUG]  [BUGGY]  else  if(closed)  {  writeERROR();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(closed)  {  writeERROR();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(closed)  {  writeERROR();  buffer.flushBlock();  finished  =  false;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	134	None	replace
494	[BUG]  [BUGGY]  else  if(closed)  {  writeIOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(closed)  {  writeIOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(closed)  {  writeIOFRecord();  buffer.flushBlock();  finished  =  false;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	134	None	replace
495	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	77	None	replace
496	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	77	None	replace
497	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	77	None	replace
498	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  breakEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  breakEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  breakEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	77	None	replace
499	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	77	None	replace
500	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	84	None	replace
501	[BUG]  [BUGGY]  if(haveUnclosed)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosed)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosed)  {  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	84	None	replace
502	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	22	None	replace
503	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	22	None	replace
504	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  false;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  false;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	22	None	replace
505	[BUG]  [BUGGY]  os.writeEndBytes(buffer,  0,  buffer.length);  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.writeEndBytes(buffer,  0,  buffer.length);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.writeEndBytes(buffer,  0,  buffer.length);	  os.close();    	non-compiled	[CE]  <identifier>  expected	97	None	replace
506	[BUG]  [BUGGY]  os.writeEndByteBuffer(buffer,  0,  buffer.length);  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.writeEndByteBuffer(buffer,  0,  buffer.length);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.writeEndByteBuffer(buffer,  0,  buffer.length);	  os.close();    	non-compiled	[CE]  <identifier>  expected	97	None	replace
507	[BUG]  [BUGGY]  os.writeEndBytes(recordBuf,  0,  buffer.length);  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.writeEndBytes(recordBuf,  0,  buffer.length);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.writeEndBytes(recordBuf,  0,  buffer.length);	  os.close();    	non-compiled	[CE]  <identifier>  expected	97	None	replace
508	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }	  if(hasUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	122	None	replace
509	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(hasUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	122	None	replace
510	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(hasUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	122	None	replace
511	[BUG]  [BUGGY]  AfterClosed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterClosed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterClosed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	30	None	replace
512	[BUG]  [BUGGY]  AfterClosed)  {  finished  =  false;  }  else  {  buffer.closeArchive();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterClosed)  {  finished  =  false;  }  else  {  buffer.closeArchive();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterClosed)  {  finished  =  false;  }  else  {  buffer.closeArchive();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	30	None	replace
513	[BUG]  [BUGGY]  AfterClosed)  {  finished  =  false;  }  else  {  buffer.closeArchiveOutputStream();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterClosed)  {  finished  =  false;  }  else  {  buffer.closeArchiveOutputStream();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterClosed)  {  finished  =  false;  }  else  {  buffer.closeArchiveOutputStream();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	30	None	replace
514	[BUG]  [BUGGY]  AfterClosed)  {  finished  =  false;  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterClosed)  {  finished  =  false;  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterClosed)  {  finished  =  false;  }  else  {  buffer.close();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	30	None	replace
515	[BUG]  [BUGGY]  AfterClosed)  {  finished  =  false;  }  else  {  buffer.closeBlock();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterClosed)  {  finished  =  false;  }  else  {  buffer.closeBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterClosed)  {  finished  =  false;  }  else  {  buffer.closeBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	30	None	replace
516	[BUG]  [BUGGY]  cast(buffer,  LONGFILE_GNU);  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  cast(buffer,  LONGFILE_GNU);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	cast(buffer,  LONGFILE_GNU);	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	30	None	replace
517	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	39	None	replace
518	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	39	None	replace
519	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	39	None	replace
520	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	39	None	replace
521	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  began  =  true;  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  began  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  began  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	39	None	replace
522	[BUG]  [BUGGY]  if(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	70	None	replace
523	[BUG]  [BUGGY]  after(recordBuf,  0,  out.length)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(recordBuf,  0,  out.length)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(recordBuf,  0,  out.length)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	70	None	replace
524	[BUG]  [BUGGY]  after(recordBuf,  0,  buffer.length))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(recordBuf,  0,  buffer.length))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(recordBuf,  0,  buffer.length))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	70	None	replace
525	[BUG]  [BUGGY]  after(recordBuf,  0,  buffer.length)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(recordBuf,  0,  buffer.length)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(recordBuf,  0,  buffer.length)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	70	None	replace
526	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	129	None	replace
527	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  out.close();  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	129	None	replace
528	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  OutputStream  out.close();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  OutputStream  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  OutputStream  out.close();  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	129	None	replace
529	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	61	None	replace
530	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	61	None	replace
531	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	61	None	replace
532	[BUG]  [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	61	None	replace
533	[BUG]  [BUGGY]  if(closed)  {  finish();  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finish();  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finish();  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  finish();    	non-compiled	[CE]  <identifier>  expected	133	None	replace
534	[BUG]  [BUGGY]  if(currName!=  null)  {  finish();  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  finish();  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  finish();  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  finish();    	non-compiled	[CE]  <identifier>  expected	133	None	replace
535	[BUG]  [BUGGY]  if(currName!=  null)  {  finish();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  finish();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  finish();  }  else  {  buffer.close();  }	  finish();    	non-compiled	[CE]  <identifier>  expected	133	None	replace
536	[BUG]  [BUGGY]  if(currName!=  null)  {  finish();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  finish();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  finish();  }  else  {  buffer.flushBlock();  }	  finish();    	non-compiled	[CE]  <identifier>  expected	133	None	replace
537	[BUG]  [BUGGY]  if(closed)  {  finish();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finish();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finish();  }  else  {  buffer.flushBlock();  }	  finish();    	non-compiled	[CE]  <identifier>  expected	133	None	replace
538	[BUG]  [BUGGY]  if(closed)  {  finish();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finish();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finish();  }  else  {  buffer.close();  }	  finish();    	non-compiled	[CE]  <identifier>  expected	133	None	replace
539	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  finish();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  finish();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  ==  0)  {  finish();  }  else  {  buffer.close();  }	  finish();    	non-compiled	[CE]  <identifier>  expected	133	None	replace
540	[BUG]  [BUGGY]  else  if(haveUnclosedEntry)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(haveUnclosedEntry)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(haveUnclosedEntry)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(closed)    {    finishEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	131	None	replace
541	[BUG]  [BUGGY]  else  if(closed)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(closed)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(closed)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  else    if(closed)    {    finishEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	131	None	replace
542	[BUG]  [BUGGY]  if(!finished)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(closed)    {    finishEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	131	None	replace
543	[BUG]  [BUGGY]  else  if(closed)  {  startEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(closed)  {  startEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(closed)  {  startEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(closed)    {    finishEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	131	None	replace
544	[BUG]  [BUGGY]  while(!finished)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(closed)    {    finishEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	131	None	replace
545	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	85	None	replace
546	[BUG]  [BUGGY]  if(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	85	None	replace
547	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	85	None	replace
548	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	85	None	replace
549	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	85	None	replace
550	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	57	None	replace
551	[BUG]  [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	57	None	replace
552	[BUG]  [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	57	None	replace
553	[BUG]  [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.AUTO_CLOSE_ERROR))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.AUTO_CLOSE_ERROR))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  buffer.isEnabled(Feature.AUTO_CLOSE_ERROR))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	57	None	replace
554	[BUG]  [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAME))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAME))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAME))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	57	None	replace
555	[BUG]  [BUGGY]  while(!finished)  {  closed  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  closed  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  closed  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	57	None	replace
556	[BUG]  [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTED_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTED_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  buffer.isEnabled(Feature.QUOTED_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	57	None	replace
557	[BUG]  [BUGGY]  if(closed)  {  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	60	None	replace
558	[BUG]  [BUGGY]  if(closed)  {  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	60	None	replace
559	[BUG]  [BUGGY]  if(isEOF())  {  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(isEOF())  {  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(isEOF())  {  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	60	None	replace
560	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	74	None	replace
561	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	74	None	replace
562	[BUG]  [BUGGY]  if(finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	74	None	replace
563	[BUG]  [BUGGY]  if(!finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	74	None	replace
564	[BUG]  [BUGGY]  if(closed)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	74	None	replace
565	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	2	None	replace
566	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	2	None	replace
567	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	2	None	replace
568	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  readEOFRecord();    buffer.flushBlock();    finished    =    true;    	non-compiled	[CE]  <identifier>  expected	62	None	replace
569	[BUG]  [BUGGY]  if(closed)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  readEOFRecord();    buffer.flushBlock();    finished    =    true;    	non-compiled	[CE]  <identifier>  expected	62	None	replace
570	[BUG]  [BUGGY]  if(!finished)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  readEOFRecord();    buffer.flushBlock();    finished    =    true;    	non-compiled	[CE]  <identifier>  expected	62	None	replace
571	[BUG]  [BUGGY]  if(finished)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  readEOFRecord();    buffer.flushBlock();    finished    =    true;    	non-compiled	[CE]  <identifier>  expected	62	None	replace
572	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }  else  {  throw  new  IOException( " ");  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }  else  {  throw  new  IOException( " ");  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }  else  {  throw  new  IOException( " ");  }	  readEOFRecord();    buffer.flushBlock();    finished    =    true;    	non-compiled	[CE]  <identifier>  expected	62	None	replace
573	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  }	  Finished    =    true;    	non-compiled	[CE]  <identifier>  expected	112	None	replace
574	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  0,  currSize);  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  0,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  0,  currSize);  }	  Finished    =    true;    	non-compiled	[CE]  <identifier>  expected	112	None	replace
575	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  currSize,  currSize);  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  currSize,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  currSize,  currSize);  }	  Finished    =    true;    	non-compiled	[CE]  <identifier>  expected	112	None	replace
576	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  currSize);  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer,  currSize);  }	  Finished    =    true;    	non-compiled	[CE]  <identifier>  expected	112	None	replace
577	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer.length);  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer.length);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  System.arraycopy(assemBuf,  0,  buffer.length);  }	  Finished    =    true;    	non-compiled	[CE]  <identifier>  expected	112	None	replace
578	[BUG]  [BUGGY]  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    start    =    true;    }    	non-compiled	[CE]  <identifier>  expected	41	None	replace
579	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    start    =    true;    }    	non-compiled	[CE]  <identifier>  expected	41	None	replace
580	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    start    =    true;    }    	non-compiled	[CE]  <identifier>  expected	41	None	replace
581	[BUG]  [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    start    =    true;    }    	non-compiled	[CE]  <identifier>  expected	41	None	replace
582	[BUG]  [BUGGY]  readEOFRecord();  buffer.flushBlock();  start  =  true;  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  readEOFRecord();  buffer.flushBlock();  start  =  true;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	readEOFRecord();  buffer.flushBlock();  start  =  true;	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    start    =    true;    }    	non-compiled	[CE]  <identifier>  expected	41	None	replace
583	[BUG]  [BUGGY]  while(!finished)  {  closed  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  closed  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  closed  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    start    =    true;    }    	non-compiled	[CE]  <identifier>  expected	41	None	replace
584	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	19	None	replace
585	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	119	None	replace
586	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  System.arraycopy(assemBuf,  0,  buffer.length);  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  System.arraycopy(assemBuf,  0,  buffer.length);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  System.arraycopy(assemBuf,  0,  buffer.length);  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	119	None	replace
587	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  System.arraycopy(assemBuf,  0,  buffer.length);  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  System.arraycopy(assemBuf,  0,  buffer.length);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  System.arraycopy(assemBuf,  0,  buffer.length);  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	119	None	replace
588	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  start  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  start  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  start  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	119	None	replace
589	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	128	None	replace
590	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	128	None	replace
591	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	128	None	replace
592	[BUG]  [BUGGY]  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	128	None	replace
593	[BUG]  [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	128	None	replace
594	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	128	None	replace
595	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	128	None	replace
596	[BUG]  [BUGGY]  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	136	None	replace
597	[BUG]  [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finish  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	136	None	replace
598	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.writeBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.writeBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  buffer.writeBlock();  finished  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	136	None	replace
599	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(hasUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  }	  if(hasUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	93	None	replace
600	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	54	None	replace
601	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	54	None	replace
602	[BUG]  [BUGGY]  if(!finished)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	54	None	replace
603	[BUG]  [BUGGY]  if(closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	54	None	replace
604	[BUG]  [BUGGY]  if(currName  ==  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    writeEOFRecord();    buffer.flushBlock();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	139	None	replace
605	[BUG]  [BUGGY]  if(!finished)  {  if(currName!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  if(currName!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  if(currName!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    writeEOFRecord();    buffer.flushBlock();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	139	None	replace
606	[BUG]  [BUGGY]  if(closed)  {  if(currName!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(currName!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(currName!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    writeEOFRecord();    buffer.flushBlock();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	139	None	replace
607	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  ==  0)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    writeEOFRecord();    buffer.flushBlock();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	139	None	replace
608	[BUG]  [BUGGY]  Thread.currentThread().setContextClassLoader(TarBuffer.class.getClassLoader());  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Thread.currentThread().setContextClassLoader(TarBuffer.class.getClassLoader());  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Thread.currentThread().setContextClassLoader(TarBuffer.class.getClassLoader());	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	67	None	replace
609	[BUG]  [BUGGY]  Thread.currentThread().setContextClassLoader(TarBuffer.class.getSimpleName());  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Thread.currentThread().setContextClassLoader(TarBuffer.class.getSimpleName());  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Thread.currentThread().setContextClassLoader(TarBuffer.class.getSimpleName());	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	67	None	replace
610	[BUG]  [BUGGY]  readEOFRecord();  buffer.flushBlock();  startBlock();  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  readEOFRecord();  buffer.flushBlock();  startBlock();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	readEOFRecord();  buffer.flushBlock();  startBlock();	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	67	None	replace
611	[BUG]  [BUGGY]  Thread.currentThread().setContextClassLoader(TarBuffer.class.getClassLoader(),  true);  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Thread.currentThread().setContextClassLoader(TarBuffer.class.getClassLoader(),  true);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Thread.currentThread().setContextClassLoader(TarBuffer.class.getClassLoader(),  true);	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	67	None	replace
612	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	17	None	replace
613	[BUG]  [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	17	None	replace
614	[BUG]  [BUGGY]  after(recordBuf,  0,  buffer.length))  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(recordBuf,  0,  buffer.length))  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(recordBuf,  0,  buffer.length))  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	17	None	replace
615	[BUG]  [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	42	None	replace
616	[BUG]  [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	42	None	replace
617	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finish  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finish  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finish  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	137	None	replace
618	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	137	None	replace
619	[BUG]  [BUGGY]  if(closed)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	137	None	replace
620	[BUG]  [BUGGY]  While(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  While(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	While(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	90	None	replace
621	[BUG]  [BUGGY]  While(!finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  While(!finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	While(!finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	90	None	replace
622	[BUG]  [BUGGY]  While(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  While(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	While(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	90	None	replace
623	[BUG]  [BUGGY]  While(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  While(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	While(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	90	None	replace
624	[BUG]  [BUGGY]  While(!finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  While(!finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	While(!finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	90	None	replace
625	[BUG]  [BUGGY]  if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	10	None	replace
626	[BUG]  [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.close();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	10	None	replace
627	[BUG]  [BUGGY]  if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.close();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	10	None	replace
628	[BUG]  [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.closeBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.closeBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.closeBlock();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	10	None	replace
629	[BUG]  [BUGGY]  if(currName!=  null)  {  for(int  i  =  1;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  for(int  i  =  1;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  for(int  i  =  1;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	10	None	replace
630	[BUG]  [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  len.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  len.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  for(int  i  =  0;  i  <  len.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	10	None	replace
631	[BUG]  [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	21	None	replace
632	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	21	None	replace
633	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	21	None	replace
634	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	21	None	replace
635	[BUG]  [BUGGY]  after(recordBuf,  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(recordBuf,  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(recordBuf,  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	21	None	replace
636	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	40	None	replace
637	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	40	None	replace
638	[BUG]  [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	40	None	replace
639	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	37	None	replace
640	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	86	None	replace
641	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	86	None	replace
642	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	4	None	replace
643	[BUG]  [BUGGY]  if(finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	4	None	replace
644	[BUG]  [BUGGY]  if(!finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	4	None	replace
645	[BUG]  [BUGGY]  if(closed)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	4	None	replace
646	[BUG]  [BUGGY]  readEOFRecord();  buffer.flushBuffer();  endBlock();  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  readEOFRecord();  buffer.flushBuffer();  endBlock();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	readEOFRecord();  buffer.flushBuffer();  endBlock();	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBuffer();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	69	None	replace
647	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock(LONGFILE_GNU);  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock(LONGFILE_GNU);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock(LONGFILE_GNU);	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBuffer();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	69	None	replace
648	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock(LONGFILE_GNU,  LONGFILE_GNU);  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock(LONGFILE_GNU,  LONGFILE_GNU);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_ERROR>  endBlock  =  new  EndBlock(LONGFILE_GNU,  LONGFILE_GNU);	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBuffer();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	69	None	replace
649	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	47	None	replace
650	[BUG]  [BUGGY]  if(closed)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	47	None	replace
651	[BUG]  [BUGGY]  if(!finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	47	None	replace
652	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	128	None	replace
653	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	128	None	replace
654	[BUG]  [BUGGY]  if(!finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	128	None	replace
655	[BUG]  [BUGGY]  if(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	128	None	replace
656	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	6	None	replace
657	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	89	None	replace
658	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	89	None	replace
659	[BUG]  [BUGGY]  if(finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	18	None	replace
660	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	18	None	replace
661	[BUG]  [BUGGY]  if(closed)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	18	None	replace
662	[BUG]  [BUGGY]  if(!finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	18	None	replace
663	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	87	None	replace
664	[BUG]  [BUGGY]  if(!haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	87	None	replace
665	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	31	None	replace
666	[BUG]  [BUGGY]  if(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	31	None	replace
667	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  completed  =  false;  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  completed  =  false;  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  completed  =  false;  }  else  {  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	31	None	replace
668	[BUG]  [BUGGY]  os.writeFieldName(currName);  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.writeFieldName(currName);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.writeFieldName(currName);	  os.flushBuffer();    	non-compiled	[CE]  <identifier>  expected	100	None	replace
669	[BUG]  [BUGGY]  if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	48	None	replace
670	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	49	None	replace
671	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	19	None	replace
672	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	65	None	replace
673	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	65	None	replace
674	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	65	None	replace
675	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.closeBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.closeBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.closeBlock();  endBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	65	None	replace
676	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  finished  =  true;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	94	None	replace
677	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();Finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();Finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();Finished  =  true;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	94	None	replace
678	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(currName!=    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	76	None	replace
679	[BUG]  [BUGGY]  if(currName!=  null)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(currName!=    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	76	None	replace
680	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(currName!=  null)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(currName!=  null)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(currName!=  null)  {  finished  =  false;  }	  if(currName!=    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	76	None	replace
681	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }	  if(currName!=    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	76	None	replace
682	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	110	None	replace
683	[BUG]  [BUGGY]  if(finish)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finish)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finish)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	110	None	replace
684	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	95	None	replace
685	[BUG]  [BUGGY]  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	95	None	replace
686	[BUG]  [BUGGY]  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	135	None	replace
687	[BUG]  [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append('/');  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append('/');  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append('/');  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	9	None	replace
688	[BUG]  [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]  + ", ");  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]  + ", ");  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]  + ", ");  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	9	None	replace
689	[BUG]  [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currSize.length();  i++)  {  buffer.append(currName[i]);  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currSize.length();  i++)  {  buffer.append(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  for(int  i  =  0;  i  <  currSize.length();  i++)  {  buffer.append(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	9	None	replace
690	[BUG]  [BUGGY]  os.copyCurrentStructure(buffer,  0,  buffer.length);  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.copyCurrentStructure(buffer,  0,  buffer.length);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.copyCurrentStructure(buffer,  0,  buffer.length);	  os.write(buffer,    0,    buffer.length);    	non-compiled	[CE]  <identifier>  expected	101	None	replace
691	[BUG]  [BUGGY]  os.write(buffer,  0,  buffer.length  -  4);  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.write(buffer,  0,  buffer.length  -  4);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.write(buffer,  0,  buffer.length  -  4);	  os.write(buffer,    0,    buffer.length);    	non-compiled	[CE]  <identifier>  expected	101	None	replace
692	[BUG]  [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.write(assemBuf,    0,    currSize);    }    	non-compiled	[CE]  <identifier>  expected	33	None	replace
693	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.writeBlock();  out.write(assemBuf,  0,  currSize);  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.writeBlock();  out.write(assemBuf,  0,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.writeBlock();  out.write(assemBuf,  0,  currSize);  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.write(assemBuf,    0,    currSize);    }    	non-compiled	[CE]  <identifier>  expected	33	None	replace
694	[BUG]  [BUGGY]  out.write(assemBuf,  0,  currSize);  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  out.write(assemBuf,  0,  currSize);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	out.write(assemBuf,  0,  currSize);	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.write(assemBuf,    0,    currSize);    }    	non-compiled	[CE]  <identifier>  expected	33	None	replace
695	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.bufferBlock();  out.write(assemBuf,  0,  currSize);  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.bufferBlock();  out.write(assemBuf,  0,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  buffer.bufferBlock();  out.write(assemBuf,  0,  currSize);  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.write(assemBuf,    0,    currSize);    }    	non-compiled	[CE]  <identifier>  expected	33	None	replace
696	[BUG]  [BUGGY]  while(!clocked)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!clocked)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!clocked)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  while(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	103	None	replace
697	[BUG]  [BUGGY]  while(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  while(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	103	None	replace
698	[BUG]  [BUGGY]  while(!closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  while(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	103	None	replace
699	[BUG]  [BUGGY]  while(!clocked)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!clocked)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!clocked)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  while(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	103	None	replace
700	[BUG]  [BUGGY]  if(finish)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finish)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finish)  {  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	84	None	replace
701	[BUG]  [BUGGY]  if(cloned)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(cloned)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(cloned)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	60	None	replace
702	[BUG]  [BUGGY]  if(currName!=  null  ||  currName  ==  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName  ==  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName  ==  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(currName!=    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	50	None	replace
703	[BUG]  [BUGGY]  if(currName!=  null)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(currName!=    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	50	None	replace
704	[BUG]  [BUGGY]  if(currName!=  null)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  finished  =  false;  }	  if(currName!=    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	50	None	replace
705	[BUG]  [BUGGY]  if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }	  if(currName!=    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	50	None	replace
706	[BUG]  [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	130	None	replace
707	[BUG]  [BUGGY]  AfterClosed  <  LONGFILE_ERROR  ||  finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterClosed  <  LONGFILE_ERROR  ||  finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterClosed  <  LONGFILE_ERROR  ||  finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	130	None	replace
708	[BUG]  [BUGGY]  AfterClosed  <  LONGFILE_ERROR  ||  closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterClosed  <  LONGFILE_ERROR  ||  closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterClosed  <  LONGFILE_ERROR  ||  closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	130	None	replace
709	[BUG]  [BUGGY]  AfterClosed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterClosed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterClosed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	130	None	replace
710	[BUG]  [BUGGY]  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    writeEOFRecord();    buffer.flushBlock();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	139	None	replace
711	[BUG]  [BUGGY]  if(!closed)  {  if(currName!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  if(currName!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  if(currName!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    writeEOFRecord();    buffer.flushBlock();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	139	None	replace
712	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(!closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	26	None	replace
713	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(!closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	26	None	replace
714	[BUG]  [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	105	None	replace
715	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  started  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	105	None	replace
716	[BUG]  [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc	  if(finished)    {    finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	20	None	replace
717	[BUG]  [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcr  =  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcr  =  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcr  =  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc	  if(finished)    {    finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	20	None	replace
718	[BUG]  [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcEr  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcEr  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcEr	  if(finished)    {    finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	20	None	replace
719	[BUG]  [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcA  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcA  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcA	  if(finished)    {    finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	20	None	replace
720	[BUG]  [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcr  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcr  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcr	  if(finished)    {    finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	20	None	replace
721	[BUG]  [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcErr  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcErr  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcErr	  if(finished)    {    finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	20	None	replace
722	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	77	None	replace
723	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  completed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  completed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  completed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	77	None	replace
724	[BUG]  [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  done  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  done  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  done  =  false;  }	  done    =    true;    	non-compiled	[CE]  <identifier>  expected	116	None	replace
725	[BUG]  [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  done  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  done  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  done  =  true;  }	  done    =    true;    	non-compiled	[CE]  <identifier>  expected	116	None	replace
726	[BUG]  [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  done  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  done  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  done  =  false;  }	  done    =    true;    	non-compiled	[CE]  <identifier>  expected	116	None	replace
727	[BUG]  [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  done  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  done  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	done  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  done  =  true;  }	  done    =    true;    	non-compiled	[CE]  <identifier>  expected	116	None	replace
728	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBuffer();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	69	None	replace
729	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBuffer();  endBlock();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBuffer();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  buffer.flushBuffer();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBuffer();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	69	None	replace
730	[BUG]  [BUGGY]  EndBlock  <  TarBuffer>  endBlock  =  new  EndBlock  <  TarBuffer>();  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  TarBuffer>  endBlock  =  new  EndBlock  <  TarBuffer>();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  TarBuffer>  endBlock  =  new  EndBlock  <  TarBuffer>();	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBuffer();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	69	None	replace
731	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  endBlock();  }  [CE]  <identifier>  expected  [FE]                                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBuffer();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	69	None	replace
732	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	40	None	replace
733	[BUG]  [BUGGY]  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	40	None	replace
734	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	40	None	replace
735	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBuffer();  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBuffer();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBuffer();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	56	None	replace
736	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(currName!=    null)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	140	None	replace
737	[BUG]  [BUGGY]  if(finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	74	None	replace
738	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	74	None	replace
739	[BUG]  [BUGGY]  if(closed)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	74	None	replace
740	[BUG]  [BUGGY]  if(!finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	74	None	replace
741	[BUG]  [BUGGY]  after(recordBuf,  0,  buffer.length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(recordBuf,  0,  buffer.length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(recordBuf,  0,  buffer.length)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	21	None	replace
742	[BUG]  [BUGGY]  if(cloned)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(cloned)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(cloned)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	37	None	replace
743	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	90	None	replace
744	[BUG]  [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	90	None	replace
745	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	90	None	replace
746	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	90	None	replace
747	[BUG]  [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	90	None	replace
748	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBuffer();  out.close();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBuffer();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBuffer();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	73	None	replace
749	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  System.arraycopy(assemBuf,  0,  out,  currSize,  currSize);  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  System.arraycopy(assemBuf,  0,  out,  currSize,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  System.arraycopy(assemBuf,  0,  out,  currSize,  currSize);  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	73	None	replace
750	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  out.close();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	73	None	replace
751	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  System.exit(0);  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  System.exit(0);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  System.exit(0);  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	73	None	replace
752	[BUG]  [BUGGY]  if(currName  ==  null  ||  currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null  ||  currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null  ||  currName!=  null)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(currName    ==    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	51	None	replace
753	[BUG]  [BUGGY]  if(currName  ==  null)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(currName    ==    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	51	None	replace
754	[BUG]  [BUGGY]  if(currName  ==  null  ||  currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null  ||  currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null  ||  currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.flushBlock();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	13	None	replace
755	[BUG]  [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.closeBlock();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.closeBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.closeBlock();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	13	None	replace
756	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName.charAt(i));    }    	non-compiled	[CE]  <identifier>  expected	14	None	replace
757	[BUG]  [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append('n');  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append('n');  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append('n');  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName.charAt(i));    }    	non-compiled	[CE]  <identifier>  expected	14	None	replace
758	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.flushBlock();  }	  writeEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	11	None	replace
759	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }	  writeEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	11	None	replace
760	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(closed)    {    finishEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	131	None	replace
761	[BUG]  [BUGGY]  else  if(hasUnclosedEntry)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(hasUnclosedEntry)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(hasUnclosedEntry)  {  finishEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(closed)    {    finishEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	131	None	replace
762	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	85	None	replace
763	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	85	None	replace
764	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.bufferBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.bufferBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.bufferBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	85	None	replace
765	[BUG]  [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    true;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	138	None	replace
766	[BUG]  [BUGGY]  AfterEOF)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterEOF)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterEOF)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    true;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	138	None	replace
767	[BUG]  [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }	  if(finished)    {    finished    =    true;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	138	None	replace
768	[BUG]  [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }	  if(finished)    {    finished    =    true;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	138	None	replace
769	[BUG]  [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  EOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  EOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  true;  }  else  {  EOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    true;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	138	None	replace
770	[BUG]  [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  startEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  startEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  true;  }  else  {  startEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    true;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	138	None	replace
771	[BUG]  [BUGGY]  AfterEOF)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterEOF)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterEOF)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }	  if(finished)    {    finished    =    true;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	138	None	replace
772	[BUG]  [BUGGY]  os.writeEndByte(buffer,  0,  buffer.length);  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.writeEndByte(buffer,  0,  buffer.length);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.writeEndByte(buffer,  0,  buffer.length);	  os.close();    	non-compiled	[CE]  <identifier>  expected	97	None	replace
773	[BUG]  [BUGGY]  os.writeEndByteBuffer(buffer);  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.writeEndByteBuffer(buffer);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.writeEndByteBuffer(buffer);	  os.close();    	non-compiled	[CE]  <identifier>  expected	97	None	replace
774	[BUG]  [BUGGY]  if(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
775	[BUG]  [BUGGY]  if(cloned)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(cloned)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(cloned)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
776	[BUG]  [BUGGY]  if(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
777	[BUG]  [BUGGY]  else  if(cloned)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(cloned)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(cloned)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	92	None	replace
778	[BUG]  [BUGGY]  if(!closed)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  readEOFRecord();    buffer.flushBlock();    finished    =    true;    	non-compiled	[CE]  <identifier>  expected	62	None	replace
779	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    completed    =    true;    }    	non-compiled	[CE]  <identifier>  expected	126	None	replace
780	[BUG]  [BUGGY]  if(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    completed    =    true;    }    	non-compiled	[CE]  <identifier>  expected	126	None	replace
781	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    completed    =    true;    }    	non-compiled	[CE]  <identifier>  expected	126	None	replace
782	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	23	None	replace
783	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  closed  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  closed  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  closed  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	23	None	replace
784	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	83	None	replace
785	[BUG]  [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcAs  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcAs  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcAs	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	83	None	replace
786	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	67	None	replace
787	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finishBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finishBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finishBlock();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	67	None	replace
788	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  beginBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  beginBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  beginBlock();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	67	None	replace
789	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startedBlock();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startedBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startedBlock();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	67	None	replace
790	[BUG]  [BUGGY]  if(haveUnclosed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(hasUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	93	None	replace
791	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }	  if(hasUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	93	None	replace
792	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  ==  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  ==  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  ==  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(hasUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	93	None	replace
793	[BUG]  [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	34	None	replace
794	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  started  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	34	None	replace
795	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	34	None	replace
796	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	79	None	replace
797	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }	  if(!closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	79	None	replace
798	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(!closed)  {  completed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(!closed)  {  completed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(!closed)  {  completed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	79	None	replace
799	[BUG]  [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	27	None	replace
800	[BUG]  [BUGGY]  after(readEOFRecord(),  closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(readEOFRecord(),  closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(readEOFRecord(),  closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	27	None	replace
801	[BUG]  [BUGGY]  while(!closed)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	27	None	replace
802	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	27	None	replace
803	[BUG]  [BUGGY]  if(finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	4	None	replace
804	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	4	None	replace
805	[BUG]  [BUGGY]  if(closed)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	4	None	replace
806	[BUG]  [BUGGY]  if(!finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	4	None	replace
807	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	64	None	replace
808	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	64	None	replace
809	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	64	None	replace
810	[BUG]  [BUGGY]  buffer.writeBlock(assemBuf,  0,  assemLen);  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  buffer.writeBlock(assemBuf,  0,  assemLen);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	buffer.writeBlock(assemBuf,  0,  assemLen);	  buffer.close();    	non-compiled	[CE]  <identifier>  expected	99	None	replace
811	[BUG]  [BUGGY]  buffer.writeBlock(assemBuf);  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  buffer.writeBlock(assemBuf);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	buffer.writeBlock(assemBuf);	  buffer.close();    	non-compiled	[CE]  <identifier>  expected	99	None	replace
812	[BUG]  [BUGGY]  buffer.writeBlock(assemBuf,  0,  currSize);  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  buffer.writeBlock(assemBuf,  0,  currSize);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	buffer.writeBlock(assemBuf,  0,  currSize);	  buffer.close();    	non-compiled	[CE]  <identifier>  expected	99	None	replace
813	[BUG]  [BUGGY]  finished  =  new  StringBuffer();  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  new  StringBuffer();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  new  StringBuffer();	  finished    =   "   ";    	non-compiled	[CE]  <identifier>  expected	115	None	replace
814	[BUG]  [BUGGY]  finished  =  new  StringBuffer(LONGFILE_ERROR);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  new  StringBuffer(LONGFILE_ERROR);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  new  StringBuffer(LONGFILE_ERROR);	  finished    =   "   ";    	non-compiled	[CE]  <identifier>  expected	115	None	replace
815	[BUG]  [BUGGY]  finished  =  'n';  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  'n';  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  'n';	  finished    =   "   ";    	non-compiled	[CE]  <identifier>  expected	115	None	replace
816	[BUG]  [BUGGY]  finished  ='{  ';  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  ='{  ';  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  ='{  ';	  finished    =   "   ";    	non-compiled	[CE]  <identifier>  expected	115	None	replace
817	[BUG]  [BUGGY]  out.write(assemBuf,  0,  buffer.length);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  out.write(assemBuf,  0,  buffer.length);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	out.write(assemBuf,  0,  buffer.length);	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	2	None	replace
818	[BUG]  [BUGGY]  out.write(assemBuf,  0,  assemLen);  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  out.write(assemBuf,  0,  assemLen);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	out.write(assemBuf,  0,  assemLen);	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	2	None	replace
819	[BUG]  [BUGGY]  readEOFRecord();  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  readEOFRecord();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	readEOFRecord();	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	2	None	replace
820	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	57	None	replace
821	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	57	None	replace
822	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBuffer();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBuffer();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBuffer();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	57	None	replace
823	[BUG]  [BUGGY]  if(!haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	61	None	replace
824	[BUG]  [BUGGY]  if(haveUnclosedEntry  ||!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry  ||!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry  ||!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	61	None	replace
825	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  readEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  readEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  readEOFRecord();  buffer.flushBlock();  }	  readEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	28	None	replace
826	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  readEOFRecord();  buffer.flushBlock();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  readEOFRecord();  buffer.flushBlock();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  readEOFRecord();  buffer.flushBlock();  }  else  {  buffer.flushBlock();  }	  readEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	28	None	replace
827	[BUG]  [BUGGY]  if(currName!=  null)  {  readEOFRecord();  buffer.flushBlock();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  readEOFRecord();  buffer.flushBlock();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  readEOFRecord();  buffer.flushBlock();  }  else  {  buffer.flushBlock();  }	  readEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	28	None	replace
828	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
829	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
830	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
831	[BUG]  [BUGGY]  if(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	118	None	replace
832	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	118	None	replace
833	[BUG]  [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	86	None	replace
834	[BUG]  [BUGGY]  while(!closed)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	86	None	replace
835	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  started  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	86	None	replace
836	[BUG]  [BUGGY]  while(!closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	86	None	replace
837	[BUG]  [BUGGY]  if(finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	47	None	replace
838	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	47	None	replace
839	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	47	None	replace
840	[BUG]  [BUGGY]  if(closed)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	47	None	replace
841	[BUG]  [BUGGY]  AfterClosed  <  LONGFILE_ERROR  ||  finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterClosed  <  LONGFILE_ERROR  ||  finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterClosed  <  LONGFILE_ERROR  ||  finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	30	None	replace
842	[BUG]  [BUGGY]  AfterClosed  <  LONGFILE_GNU)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterClosed  <  LONGFILE_GNU)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterClosed  <  LONGFILE_GNU)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	30	None	replace
843	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	30	None	replace
844	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	7	None	replace
845	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	7	None	replace
846	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	7	None	replace
847	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	7	None	replace
848	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	91	None	replace
849	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	91	None	replace
850	[BUG]  [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	91	None	replace
851	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finish  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finish  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finish  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	91	None	replace
852	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	91	None	replace
853	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	91	None	replace
854	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	91	None	replace
855	[BUG]  [BUGGY]  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	72	None	replace
856	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  closed  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  closed  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  closed  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	72	None	replace
857	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  out.close();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  out.close();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	72	None	replace
858	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBuffer();  out.close();  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBuffer();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBuffer();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	70	None	replace
859	[BUG]  [BUGGY]  DesertionFailedError  t  =  new  DesertionFailedError( "Tar  Archive  has  already  been  finished. ");  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  DesertionFailedError  t  =  new  DesertionFailedError( "Tar  Archive  has  already  been  finished. ");  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	DesertionFailedError  t  =  new  DesertionFailedError( "Tar  Archive  has  already  been  finished. ");	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	70	None	replace
860	[BUG]  [BUGGY]  DesertionFailedError  t  =  new  DesertionFailedError( "TarArchiveOutputStream  has  already  been  finished. ");  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  DesertionFailedError  t  =  new  DesertionFailedError( "TarArchiveOutputStream  has  already  been  finished. ");  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	DesertionFailedError  t  =  new  DesertionFailedError( "TarArchiveOutputStream  has  already  been  finished. ");	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	70	None	replace
861	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  OutputStream  out.close();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  OutputStream  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  OutputStream  out.close();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	70	None	replace
862	[BUG]  [BUGGY]  if(!clocked)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!clocked)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!clocked)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	44	None	replace
863	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	44	None	replace
864	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	44	None	replace
865	[BUG]  [BUGGY]  Finished  =  false;  System.arraycopy(assemBuf,  0,  buffer,  assemLen,  currSize);  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  System.arraycopy(assemBuf,  0,  buffer,  assemLen,  currSize);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  System.arraycopy(assemBuf,  0,  buffer,  assemLen,  currSize);	  Finished    =    true;    	non-compiled	[CE]  <identifier>  expected	112	None	replace
866	[BUG]  [BUGGY]  Finished  =  false;  System.arraycopy(assemBuf,  0,  buffer,  assemBuf,  0,  currSize);  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  System.arraycopy(assemBuf,  0,  buffer,  assemBuf,  0,  currSize);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  System.arraycopy(assemBuf,  0,  buffer,  assemBuf,  0,  currSize);	  Finished    =    true;    	non-compiled	[CE]  <identifier>  expected	112	None	replace
867	[BUG]  [BUGGY]  Finished  =  false;  System.arraycopy(assemBuf,  0,  buffer,  currSize,  currSize);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  System.arraycopy(assemBuf,  0,  buffer,  currSize,  currSize);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  System.arraycopy(assemBuf,  0,  buffer,  currSize,  currSize);	  Finished    =    true;    	non-compiled	[CE]  <identifier>  expected	112	None	replace
868	[BUG]  [BUGGY]  Finished  =  false;  notifyListeners(new  Runnable()  {  public  void  run()  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  notifyListeners(new  Runnable()  {  public  void  run()  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  notifyListeners(new  Runnable()  {  public  void  run()  {  buffer.flushBlock();  }	  Finished    =    true;    	non-compiled	[CE]  <identifier>  expected	112	None	replace
869	[BUG]  [BUGGY]  Finished  =  false;  System.err.println( "TarArchiveOutputStream:  finished "  +  currName);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  System.err.println( "TarArchiveOutputStream:  finished "  +  currName);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  System.err.println( "TarArchiveOutputStream:  finished "  +  currName);	  Finished    =    true;    	non-compiled	[CE]  <identifier>  expected	112	None	replace
870	[BUG]  [BUGGY]  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();	  Finished    =    true;    	non-compiled	[CE]  <identifier>  expected	112	None	replace
871	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	68	None	replace
872	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	68	None	replace
873	[BUG]  [BUGGY]  wired  =  false;  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  wired  =  false;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	wired  =  false;	  if(haveUnclosedEntry)    {    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	123	None	replace
874	[BUG]  [BUGGY]  after(readEOFRecord(),  buffer.getBlockSize())  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(readEOFRecord(),  buffer.getBlockSize())  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(readEOFRecord(),  buffer.getBlockSize())  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	43	None	replace
875	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  sealed  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  sealed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  sealed  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	43	None	replace
876	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEEFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEEFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEEFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	43	None	replace
877	[BUG]  [BUGGY]  os.writeEndByte();  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.writeEndByte();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.writeEndByte();	  os.flush();    	non-compiled	[CE]  <identifier>  expected	96	None	replace
878	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  >=  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  >=  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  >=  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	8	None	replace
879	[BUG]  [BUGGY]  if(currName  ==  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	8	None	replace
880	[BUG]  [BUGGY]  if(currName  ==  null  ||  currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null  ||  currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null  ||  currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	8	None	replace
881	[BUG]  [BUGGY]  if(currName  ==  null  ||  currName.length()!=  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null  ||  currName.length()!=  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null  ||  currName.length()!=  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	8	None	replace
882	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  closed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  closed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  closed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	17	None	replace
883	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	17	None	replace
884	[BUG]  [BUGGY]  after(recordBuf,  0,  buffer.length))  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(recordBuf,  0,  buffer.length))  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(recordBuf,  0,  buffer.length))  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	137	None	replace
885	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  completed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  completed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  completed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	54	None	replace
886	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	54	None	replace
887	[BUG]  [BUGGY]  AfterClosed  <  LONGFILE_ERROR  ||  finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterClosed  <  LONGFILE_ERROR  ||  finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterClosed  <  LONGFILE_ERROR  ||  finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	119	None	replace
888	[BUG]  [BUGGY]  AfterClosed  <  LONGFILE_ERROR  ||  closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterClosed  <  LONGFILE_ERROR  ||  closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterClosed  <  LONGFILE_ERROR  ||  closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	119	None	replace
889	[BUG]  [BUGGY]  AfterClosed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  AfterClosed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	AfterClosed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	119	None	replace
890	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  started  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	119	None	replace
891	[BUG]  [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  buffer.isEnabled(Feature.QUOTE_FIELD_NAMES))  {  finished  =  false;	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	81	None	replace
892	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  if(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(!closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	55	None	replace
893	[BUG]  [BUGGY]  while(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	121	None	replace
894	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	121	None	replace
895	[BUG]  [BUGGY]  while(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	121	None	replace
896	[BUG]  [BUGGY]  while(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	121	None	replace
897	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	66	None	replace
898	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.writeBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.writeBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.writeBlock();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	66	None	replace
899	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finishBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finishBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finishBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	66	None	replace
900	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	10	None	replace
901	[BUG]  [BUGGY]  if(currName  ==  null  ||  currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null  ||  currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null  ||  currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	10	None	replace
902	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  >=  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  >=  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  >=  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	10	None	replace
903	[BUG]  [BUGGY]  if(closed)  {  finish();  }  else  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finish();  }  else  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finish();  }  else  {  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();  }	  finish();    	non-compiled	[CE]  <identifier>  expected	133	None	replace
904	[BUG]  [BUGGY]  if(closed)  {  finish();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finish();  }	  finish();    	non-compiled	[CE]  <identifier>  expected	133	None	replace
905	[BUG]  [BUGGY]  if(currName  ==  null)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(currName    ==    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	78	None	replace
906	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	132	None	replace
907	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	132	None	replace
908	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	132	None	replace
909	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	132	None	replace
910	[BUG]  [BUGGY]  if(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    start    =    true;    }    	non-compiled	[CE]  <identifier>  expected	41	None	replace
911	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    start    =    true;    }    	non-compiled	[CE]  <identifier>  expected	41	None	replace
912	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    start    =    true;    }    	non-compiled	[CE]  <identifier>  expected	41	None	replace
913	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.bufferBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.bufferBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  buffer.bufferBlock();  finished  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	136	None	replace
914	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.releaseBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.releaseBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  buffer.releaseBlock();  finished  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	136	None	replace
915	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  writeEOFRecord();  }  else  {  buffer.flushBlock();  }	  writeEOFRecord();    	non-compiled	[CE]  <identifier>  expected	98	None	replace
916	[BUG]  [BUGGY]  if(currName!=  null)  {  currName  =  buffer.toString();  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  currName  =  buffer.toString();  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  currName  =  buffer.toString();  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.write(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	12	None	replace
917	[BUG]  [BUGGY]  buffer.write(currName[i]);  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  buffer.write(currName[i]);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	buffer.write(currName[i]);	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.write(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	12	None	replace
918	[BUG]  [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currSize.length();  i++)  {  buffer.write(currName[i]);  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currSize.length();  i++)  {  buffer.write(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  for(int  i  =  0;  i  <  currSize.length();  i++)  {  buffer.write(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.write(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	12	None	replace
919	[BUG]  [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  len.length();  i++)  {  buffer.write(currName[i]);  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  len.length();  i++)  {  buffer.write(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  for(int  i  =  0;  i  <  len.length();  i++)  {  buffer.write(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.write(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	12	None	replace
920	[BUG]  [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]  + ", ");  }  [CE]  <identifier>  expected  [FE]                                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]  + ", ");  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]  + ", ");  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.write(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	12	None	replace
921	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  writeEOFRecord();    buffer.flushBlock();    finished    =    true;    	non-compiled	[CE]  <identifier>  expected	120	None	replace
922	[BUG]  [BUGGY]  OutputStream  os  =  getOutputStream();  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  OutputStream  os  =  getOutputStream();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	OutputStream  os  =  getOutputStream();	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	71	None	replace
923	[BUG]  [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	109	None	replace
924	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	109	None	replace
925	[BUG]  [BUGGY]  if(!haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	52	None	replace
926	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	52	None	replace
927	[BUG]  [BUGGY]  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	5	None	replace
928	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  closed  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  closed  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  closed  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	5	None	replace
929	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	29	None	replace
930	[BUG]  [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	29	None	replace
931	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  started  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	29	None	replace
932	[BUG]  [BUGGY]  if(haveUnclosed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(hasUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	122	None	replace
933	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  completed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  completed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  completed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(hasUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	122	None	replace
934	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  false;  }	  if(hasUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	122	None	replace
935	[BUG]  [BUGGY]  if(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	104	None	replace
936	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	104	None	replace
937	[BUG]  [BUGGY]  if(closed)  {  wrapped  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  wrapped  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  wrapped  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	104	None	replace
938	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	16	None	replace
939	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  if(!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	16	None	replace
940	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	46	None	replace
941	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  started  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	46	None	replace
942	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	46	None	replace
943	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	46	None	replace
944	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	46	None	replace
945	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.bufferBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.bufferBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.bufferBlock();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	108	None	replace
946	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.writeBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.writeBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  buffer.writeBlock();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	108	None	replace
947	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  out.close();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  out.close();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	32	None	replace
948	[BUG]  [BUGGY]  EndBlock  <  T>  endBlock  =  new  EndBlock  <  T>();  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  T>  endBlock  =  new  EndBlock  <  T>();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  T>  endBlock  =  new  EndBlock  <  T>();	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	63	None	replace
949	[BUG]  [BUGGY]  if(closed)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	142	None	replace
950	[BUG]  [BUGGY]  if(!closed)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	142	None	replace
951	[BUG]  [BUGGY]  buffer.close();  writeEOFRecord();  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  buffer.close();  writeEOFRecord();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	buffer.close();  writeEOFRecord();	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	142	None	replace
952	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  closed  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  closed  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  closed  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	25	None	replace
953	[BUG]  [BUGGY]  finish  |=  EOFRecord.EXPR_RESULT;  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  |=  EOFRecord.EXPR_RESULT;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  |=  EOFRecord.EXPR_RESULT;	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
954	[BUG]  [BUGGY]  finish  |=  EOFRecord.EXTERN_FILE_ERROR;  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  |=  EOFRecord.EXTERN_FILE_ERROR;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  |=  EOFRecord.EXTERN_FILE_ERROR;	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
955	[BUG]  [BUGGY]  finish  |=  EOFRecord.DEFAULT;  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  |=  EOFRecord.DEFAULT;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  |=  EOFRecord.DEFAULT;	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
956	[BUG]  [BUGGY]  finish  |=  EOFRecord.EXTENDS_PER_ERROR;  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  |=  EOFRecord.EXTENDS_PER_ERROR;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  |=  EOFRecord.EXTENDS_PER_ERROR;	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
957	[BUG]  [BUGGY]  finish  =  null;  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  =  null;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  =  null;	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
958	[BUG]  [BUGGY]  finish  |=  EOFRecord.EXTERN_ERROR;  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  |=  EOFRecord.EXTERN_ERROR;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  |=  EOFRecord.EXTERN_ERROR;	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
959	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	88	None	replace
960	[BUG]  [BUGGY]  if(haveUnclosedEntry  ||!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry  ||!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry  ||!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	88	None	replace
961	[BUG]  [BUGGY]  while(!closed)  {  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	124	None	replace
962	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	124	None	replace
963	[BUG]  [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	106	None	replace
964	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	106	None	replace
965	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBuffer();  endBlock();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	106	None	replace
966	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finishBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finishBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finishBlock();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	106	None	replace
967	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	134	None	replace
968	[BUG]  [BUGGY]  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(hasUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	134	None	replace
969	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	134	None	replace
970	[BUG]  [BUGGY]  if(!finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	134	None	replace
971	[BUG]  [BUGGY]  after(recordBuf,  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(recordBuf,  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(recordBuf,  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	102	None	replace
972	[BUG]  [BUGGY]  after(recordBuf,  finished,  currSize)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(recordBuf,  finished,  currSize)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(recordBuf,  finished,  currSize)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	102	None	replace
973	[BUG]  [BUGGY]  after(recordBuf)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(recordBuf)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(recordBuf)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	102	None	replace
974	[BUG]  [BUGGY]  while(!finished)  {  closed  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  closed  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  closed  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	102	None	replace
975	[BUG]  [BUGGY]  if(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	38	None	replace
976	[BUG]  [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	75	None	replace
977	[BUG]  [BUGGY]  after(recordBuf)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(recordBuf)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(recordBuf)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	75	None	replace
978	[BUG]  [BUGGY]  after(recordBuf,  0,  out.length)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(recordBuf,  0,  out.length)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(recordBuf,  0,  out.length)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	75	None	replace
979	[BUG]  [BUGGY]  while(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	75	None	replace
980	[BUG]  [BUGGY]  if(closed)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	143	None	replace
981	[BUG]  [BUGGY]  if(currName!=  null  ||  hasUnclosedEntry)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  hasUnclosedEntry)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  hasUnclosedEntry)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	143	None	replace
982	[BUG]  [BUGGY]  if(!closed)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!closed)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!closed)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	143	None	replace
983	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	53	None	replace
984	[BUG]  [BUGGY]  finished  =  buffer.getEndBytes();  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  buffer.getEndBytes();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  buffer.getEndBytes();	  finished    =    null;    	non-compiled	[CE]  <identifier>  expected	114	None	replace
985	[BUG]  [BUGGY]  finished  =  buffer.release();  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  buffer.release();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  buffer.release();	  finished    =    null;    	non-compiled	[CE]  <identifier>  expected	114	None	replace
986	[BUG]  [BUGGY]  finished  =  buffer.next();  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  buffer.next();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  buffer.next();	  finished    =    null;    	non-compiled	[CE]  <identifier>  expected	114	None	replace
987	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	39	None	replace
988	[BUG]  [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	39	None	replace
989	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	39	None	replace
990	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  started  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	39	None	replace
991	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	39	None	replace
992	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  started  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	15	None	replace
993	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBuffer();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBuffer();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBuffer();  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	15	None	replace
994	[BUG]  [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	117	None	replace
995	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  started  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  started  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	117	None	replace
996	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	117	None	replace
997	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	107	None	replace
998	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	107	None	replace
999	[BUG]  [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  after(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	after(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	107	None	replace
1000	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  startEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  startEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  startEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	107	None	replace
1001	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  startBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  startBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  startBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	107	None	replace
1002	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBuffer();  endBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBuffer();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBuffer();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	107	None	replace
1003	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  startBlock();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  startBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  startBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	107	None	replace
1004	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	125	None	replace
1005	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	125	None	replace
1006	[BUG]  [BUGGY]  if(hasUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(hasUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(hasUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	125	None	replace
1007	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	132	None	replace
1008	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  endBlock();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	132	None	replace
1009	[BUG]  [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(i));  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName.charAt(i));    }    	non-compiled	[CE]  <identifier>  expected	14	None	replace
1010	[BUG]  [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(0));  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(0));  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName.charAt(0));  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName.charAt(i));    }    	non-compiled	[CE]  <identifier>  expected	14	None	replace
1011	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	43	None	replace
1012	[BUG]  [BUGGY]  finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endTime  =  System.currentTimeMillis();  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endTime  =  System.currentTimeMillis();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endTime  =  System.currentTimeMillis();  }	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
1013	[BUG]  [BUGGY]  finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
1014	[BUG]  [BUGGY]  finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  }	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
1015	[BUG]  [BUGGY]  finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
1016	[BUG]  [BUGGY]  finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
1017	[BUG]  [BUGGY]  finish  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finish  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finish  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  finish    =    true;    	non-compiled	[CE]  <identifier>  expected	113	None	replace
1018	[BUG]  [BUGGY]  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }	  writeEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	11	None	replace
1019	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  wrapped  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  wrapped  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  wrapped  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	17	None	replace
1020	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed ")  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed ")  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed ")  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	17	None	replace
1021	[BUG]  [BUGGY]  os.writeRaw('n');  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.writeRaw('n');  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.writeRaw('n');	  os.flush();    	non-compiled	[CE]  <identifier>  expected	96	None	replace
1022	[BUG]  [BUGGY]  if(finished)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  readEOFRecord();  buffer.flushBlock();  finished  =  true;  }  else  {  buffer.close();  }	  readEOFRecord();    buffer.flushBlock();    finished    =    true;    	non-compiled	[CE]  <identifier>  expected	62	None	replace
1023	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	10	None	replace
1024	[BUG]  [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currSize.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currSize.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  for(int  i  =  0;  i  <  currSize.length();  i++)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	10	None	replace
1025	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  currName  =  currName.substring(0,  currName.length()  -  1);  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  currName  =  currName.substring(0,  currName.length()  -  1);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  currName  =  currName.substring(0,  currName.length()  -  1);	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	10	None	replace
1026	[BUG]  [BUGGY]  while(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	106	None	replace
1027	[BUG]  [BUGGY]  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  start  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    start    =    true;    }    	non-compiled	[CE]  <identifier>  expected	41	None	replace
1028	[BUG]  [BUGGY]  finished  =  buffer.toByteArray();  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  buffer.toByteArray();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  buffer.toByteArray();	  finished    =    null;    	non-compiled	[CE]  <identifier>  expected	114	None	replace
1029	[BUG]  [BUGGY]  finished  =  buffer.getBlockSize();  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  buffer.getBlockSize();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  buffer.getBlockSize();	  finished    =    null;    	non-compiled	[CE]  <identifier>  expected	114	None	replace
1030	[BUG]  [BUGGY]  finished  =  buffer.nextBlock();  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  buffer.nextBlock();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  buffer.nextBlock();	  finished    =    null;    	non-compiled	[CE]  <identifier>  expected	114	None	replace
1031	[BUG]  [BUGGY]  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  completed  =  true;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	53	None	replace
1032	[BUG]  [BUGGY]  while(!closed)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  false;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	30	None	replace
1033	[BUG]  [BUGGY]  cast(buffer,  LONGFILE_GNU,  LONGFILE_TRUNCATE);  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  cast(buffer,  LONGFILE_GNU,  LONGFILE_TRUNCATE);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	cast(buffer,  LONGFILE_GNU,  LONGFILE_TRUNCATE);	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	30	None	replace
1034	[BUG]  [BUGGY]  else  if(closed)  {  writeBlock();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(closed)  {  writeBlock();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(closed)  {  writeBlock();  buffer.flushBlock();  finished  =  true;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	95	None	replace
1035	[BUG]  [BUGGY]  else  if(closed)  {  writePRINT();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(closed)  {  writePRINT();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(closed)  {  writePRINT();  buffer.flushBlock();  finished  =  true;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	95	None	replace
1036	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  end();  }	  finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	6	None	replace
1037	[BUG]  [BUGGY]  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	22	None	replace
1038	[BUG]  [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }	  if(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	45	None	replace
1039	[BUG]  [BUGGY]  if(finished)  {  Finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  Finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  Finished  =  true;  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	18	None	replace
1040	[BUG]  [BUGGY]  while(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	119	None	replace
1041	[BUG]  [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	119	None	replace
1042	[BUG]  [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finish  =  false;  }  else  {  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	119	None	replace
1043	[BUG]  [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.write(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	12	None	replace
1044	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  ==  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.write(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	12	None	replace
1045	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  currName[i]  =  buffer.toString();  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  currName[i]  =  buffer.toString();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  currName[i]  =  buffer.toString();	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.write(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	12	None	replace
1046	[BUG]  [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  }  [CE]  <identifier>  expected  [FE]                                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.write(currName[i]);  }  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.write(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	12	None	replace
1047	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed  ||  closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed  ||  closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed  ||  closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	15	None	replace
1048	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  ==  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  ==  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  ==  writeEOFRecord();  buffer.flushBlock();  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	15	None	replace
1049	[BUG]  [BUGGY]  while(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	31	None	replace
1050	[BUG]  [BUGGY]  if(finished)  {  readEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  readEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  readEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }	  readEOFRecord();    buffer.flushBlock();    	non-compiled	[CE]  <identifier>  expected	28	None	replace
1051	[BUG]  [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  started  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    started    =    true;    }    	non-compiled	[CE]  <identifier>  expected	117	None	replace
1052	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  closed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  closed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  closed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	77	None	replace
1053	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  Finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	77	None	replace
1054	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  wrapped  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  wrapped  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  wrapped  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	77	None	replace
1055	[BUG]  [BUGGY]  if(finished)  {  Finished  =  true;  }  else  {  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  Finished  =  true;  }  else  {  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  Finished  =  true;  }  else  {  buffer.flushBlock();  out.close();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	74	None	replace
1056	[BUG]  [BUGGY]  if(Finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(Finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(Finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	74	None	replace
1057	[BUG]  [BUGGY]  while(!finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	92	None	replace
1058	[BUG]  [BUGGY]  os.write(assemBuf,  0,  assemLen);  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.write(assemBuf,  0,  assemLen);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.write(assemBuf,  0,  assemLen);	  os.flushBuffer();    	non-compiled	[CE]  <identifier>  expected	100	None	replace
1059	[BUG]  [BUGGY]  os.writeBlock(assemBuf,  0,  assemLen);  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.writeBlock(assemBuf,  0,  assemLen);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.writeBlock(assemBuf,  0,  assemLen);	  os.flushBuffer();    	non-compiled	[CE]  <identifier>  expected	100	None	replace
1060	[BUG]  [BUGGY]  os.write(assemBuf,  0,  assemSize);  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  os.write(assemBuf,  0,  assemSize);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	os.write(assemBuf,  0,  assemSize);	  os.flushBuffer();    	non-compiled	[CE]  <identifier>  expected	100	None	replace
1061	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(haveUnclosedEntry)    {    finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	80	None	replace
1062	[BUG]  [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  hasUnclosedEntry)  {  finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(haveUnclosedEntry)    {    finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	80	None	replace
1063	[BUG]  [BUGGY]  if(cloned)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(cloned)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(cloned)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	136	None	replace
1064	[BUG]  [BUGGY]  if(clocked)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(clocked)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(clocked)  {  finished  =  false;  }  else  {  buffer.flushBlock();  finished  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	136	None	replace
1065	[BUG]  [BUGGY]  if(closed)  {  wrapped  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  wrapped  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  wrapped  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	102	None	replace
1066	[BUG]  [BUGGY]  if(buffer!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(buffer!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(buffer!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }	  writeEOFRecord();    	non-compiled	[CE]  <identifier>  expected	98	None	replace
1067	[BUG]  [BUGGY]  if(buffer!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(buffer!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(buffer!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }	  writeEOFRecord();    	non-compiled	[CE]  <identifier>  expected	98	None	replace
1068	[BUG]  [BUGGY]  if(buffer!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(buffer!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(buffer!=  null)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.flushBlock();  }	  writeEOFRecord();    	non-compiled	[CE]  <identifier>  expected	98	None	replace
1069	[BUG]  [BUGGY]  if(!finished)  {  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  writeEOFRecord();  }  else  {  buffer.flushBlock();  }	  writeEOFRecord();    	non-compiled	[CE]  <identifier>  expected	98	None	replace
1070	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  closed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  closed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  closed  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	54	None	replace
1071	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_ERROR  ||  endBlock  >  LONGFILE_GNU);  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_ERROR  ||  endBlock  >  LONGFILE_GNU);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_ERROR  ||  endBlock  >  LONGFILE_GNU);	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	64	None	replace
1072	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_ERROR  ||  endBlock(LONGFILE_GNU);  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_ERROR  ||  endBlock(LONGFILE_GNU);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_ERROR  ||  endBlock(LONGFILE_GNU);	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	64	None	replace
1073	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_ERROR  ||  endBlock  >  LONGFILE_GNU)  {  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_ERROR  ||  endBlock  >  LONGFILE_GNU)  {  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_ERROR  ||  endBlock  >  LONGFILE_GNU)  {  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	64	None	replace
1074	[BUG]  [BUGGY]  while(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(closed)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	21	None	replace
1075	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(closed)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	23	None	replace
1076	[BUG]  [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	27	None	replace
1077	[BUG]  [BUGGY]  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	68	None	replace
1078	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	68	None	replace
1079	[BUG]  [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.flushBlock();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	142	None	replace
1080	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  writeEOFRecord();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  writeEOFRecord();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  writeEOFRecord();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	142	None	replace
1081	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	91	None	replace
1082	[BUG]  [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finish  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	91	None	replace
1083	[BUG]  [BUGGY]  if(finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	47	None	replace
1084	[BUG]  [BUGGY]  else  if(closed)  {  writeBlock();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(closed)  {  writeBlock();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(closed)  {  writeBlock();  buffer.flushBlock();  finished  =  false;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	134	None	replace
1085	[BUG]  [BUGGY]  else  if(closed)  {  writePRINT();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(closed)  {  writePRINT();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(closed)  {  writePRINT();  buffer.flushBlock();  finished  =  false;  }	  else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	134	None	replace
1086	[BUG]  [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	7	None	replace
1087	[BUG]  [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	143	None	replace
1088	[BUG]  [BUGGY]  if(currName!=  null  &&  currName.length  >  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  &&  currName.length  >  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  &&  currName.length  >  0)  {  buffer.close();  writeEOFRecord();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	143	None	replace
1089	[BUG]  [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  writeEOFRecord();  }  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  writeEOFRecord();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  writeEOFRecord();  }	  if(currName!=    null)    {    buffer.close();    writeEOFRecord();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	143	None	replace
1090	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_ERROR  ||  endBlock  >  LONGFILE_GNU)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_ERROR  ||  endBlock  >  LONGFILE_GNU)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_ERROR  ||  endBlock  >  LONGFILE_GNU)  {  finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	66	None	replace
1091	[BUG]  [BUGGY]  buffer.writeBlock(currName);  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  buffer.writeBlock(currName);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	buffer.writeBlock(currName);	  buffer.close();    	non-compiled	[CE]  <identifier>  expected	99	None	replace
1092	[BUG]  [BUGGY]  buffer.flushCurrentLength();  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  buffer.flushCurrentLength();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	buffer.flushCurrentLength();	  buffer.close();    	non-compiled	[CE]  <identifier>  expected	99	None	replace
1093	[BUG]  [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	141	None	replace
1094	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  buffer.close();  }	  if(currName!=    null)    {    buffer.close();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	141	None	replace
1095	[BUG]  [BUGGY]  if(currName  ==  null  ||  currName.length()  <  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null  ||  currName.length()  <  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null  ||  currName.length()  <  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(currName    ==    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	78	None	replace
1096	[BUG]  [BUGGY]  if(closed)  {  finish();  }  else  {  buffer.flushBuffer();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finish();  }  else  {  buffer.flushBuffer();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finish();  }  else  {  buffer.flushBuffer();  }	  finish();    	non-compiled	[CE]  <identifier>  expected	133	None	replace
1097	[BUG]  [BUGGY]  if(closed)  {  finish();  }  else  {  System.arraycopy(assemBuf,  0,  buffer,  assemLen,  currSize);  writeEOFRecord();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finish();  }  else  {  System.arraycopy(assemBuf,  0,  buffer,  assemLen,  currSize);  writeEOFRecord();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finish();  }  else  {  System.arraycopy(assemBuf,  0,  buffer,  assemLen,  currSize);  writeEOFRecord();  }	  finish();    	non-compiled	[CE]  <identifier>  expected	133	None	replace
1098	[BUG]  [BUGGY]  if(closed)  {  finish();  }  else  {  System.arraycopy(assemBuf,  0,  buffer,  assemBuf,  0,  assemLen);  writeEOFRecord();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finish();  }  else  {  System.arraycopy(assemBuf,  0,  buffer,  assemBuf,  0,  assemLen);  writeEOFRecord();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finish();  }  else  {  System.arraycopy(assemBuf,  0,  buffer,  assemBuf,  0,  assemLen);  writeEOFRecord();  }	  finish();    	non-compiled	[CE]  <identifier>  expected	133	None	replace
1099	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  finish();  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	127	None	replace
1100	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  end();  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	127	None	replace
1101	[BUG]  [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcing  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcing  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcing	  if(finished)    {    finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	20	None	replace
1102	[BUG]  [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcAsEOF();  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcAsEOF();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcAsEOF();	  if(finished)    {    finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	20	None	replace
1103	[BUG]  [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcs  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcs  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcs	  if(finished)    {    finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	20	None	replace
1104	[BUG]  [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcsAndUpdate();  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcsAndUpdate();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcsAndUpdate();	  if(finished)    {    finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	20	None	replace
1105	[BUG]  [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  start();  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	2	None	replace
1106	[BUG]  [BUGGY]  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  else  {  buffer.close();  }	  writeEOFRecord();    buffer.flushBlock();    finished    =    true;    	non-compiled	[CE]  <identifier>  expected	120	None	replace
1107	[BUG]  [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	137	None	replace
1108	[BUG]  [BUGGY]  if(!finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	16	None	replace
1109	[BUG]  [BUGGY]  if(!finished)  {  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(!finished)  {  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(!finished)  {  finished  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	16	None	replace
1110	[BUG]  [BUGGY]  reportError( "TarArchiveOutputStream  finished: "  +  currName);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  reportError( "TarArchiveOutputStream  finished: "  +  currName);  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	reportError( "TarArchiveOutputStream  finished: "  +  currName);	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	16	None	replace
1111	[BUG]  [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  &&  currName.length()  >  0)  {  writeEOFRecord();  buffer.flushBlock();  }  else  {  buffer.close();  }	  if(currName!=    null)    {    writeEOFRecord();    buffer.flushBlock();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	139	None	replace
1112	[BUG]  [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  &&  currName.length()  >  0)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(currName!=    null)    {    writeEOFRecord();    buffer.flushBlock();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	139	None	replace
1113	[BUG]  [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	9	None	replace
1114	[BUG]  [BUGGY]  if(currName!=  null)  {  currName  =  buffer.toString();  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  currName  =  buffer.toString();  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  currName  =  buffer.toString();  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.append(currName[i]);  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.append(currName[i]);    }    	non-compiled	[CE]  <identifier>  expected	9	None	replace
1115	[BUG]  [BUGGY]  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	128	None	replace
1116	[BUG]  [BUGGY]  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  true;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  false;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	128	None	replace
1117	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	128	None	replace
1118	[BUG]  [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc(new  EOFRecord();  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc(new  EOFRecord();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc(new  EOFRecord();	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	56	None	replace
1119	[BUG]  [BUGGY]  if(Finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(Finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(Finished)  {  Finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  Finished    =    true;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	4	None	replace
1120	[BUG]  [BUGGY]  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  Finished    =    true;    	non-compiled	[CE]  <identifier>  expected	112	None	replace
1121	[BUG]  [BUGGY]  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  out.close();	  Finished    =    true;    	non-compiled	[CE]  <identifier>  expected	112	None	replace
1122	[BUG]  [BUGGY]  Finished  =  false;  }  catch(IOException  ioe)  {  throw  new  IOException( " ");  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  catch(IOException  ioe)  {  throw  new  IOException( " ");  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  catch(IOException  ioe)  {  throw  new  IOException( " ");  }	  Finished    =    true;    	non-compiled	[CE]  <identifier>  expected	112	None	replace
1123	[BUG]  [BUGGY]  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  closed  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  closed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Finished  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  closed  =  true;  }	  Finished    =    true;    	non-compiled	[CE]  <identifier>  expected	112	None	replace
1124	[BUG]  [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  buffer.flush();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  buffer.flush();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  &&  currName.length()  >  0)  {  buffer.flush();  }	  if(currName!=    null)    {    buffer.flush();    }    else    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	144	None	replace
1125	[BUG]  [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  &&  currName.length()  >  0)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.close();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	8	None	replace
1126	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  currName  =  currName.substring(0,  currName.length()  -  1);  buffer.flushBlock();  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  currName  =  currName.substring(0,  currName.length()  -  1);  buffer.flushBlock();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  currName  =  currName.substring(0,  currName.length()  -  1);  buffer.flushBlock();	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	8	None	replace
1127	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  buffer.flushBlock();  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  buffer.flushBlock();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  buffer.flushBlock();	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.close();    }    	non-compiled	[CE]  <identifier>  expected	8	None	replace
1128	[BUG]  [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finish  =  false;  }  else  {  writeEOFRecord();  buffer.flushBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	29	None	replace
1129	[BUG]  [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(currName!=  null  &&  currName.length()  >  0)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(currName!=  null  &&  currName.length()  >  0)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(currName!=    null)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	140	None	replace
1130	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  <  0)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  <  0)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  <  0)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(currName!=    null)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	140	None	replace
1131	[BUG]  [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  &&  currName.length()  >  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(currName!=    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	76	None	replace
1132	[BUG]  [BUGGY]  if(currName!=  null  ||  currName.length()  <  =  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  ||  currName.length()  <  =  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  ||  currName.length()  <  =  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  true;  }	  if(currName!=    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	76	None	replace
1133	[BUG]  [BUGGY]  if(currName  ==  null  ||  currName.length()  <  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null  ||  currName.length()  <  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null  ||  currName.length()  <  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(currName    ==    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	51	None	replace
1134	[BUG]  [BUGGY]  if(currName  ==  null  ||  currName.length()  <  =  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null  ||  currName.length()  <  =  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null  ||  currName.length()  <  =  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(currName    ==    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	51	None	replace
1135	[BUG]  [BUGGY]  if(currName  ==  null  ||  currName.length()!=  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName  ==  null  ||  currName.length()!=  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName  ==  null  ||  currName.length()!=  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(currName    ==    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	51	None	replace
1136	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	107	None	replace
1137	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_ERROR  ||  endBlock  >  LONGFILE_GNU)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_ERROR  ||  endBlock  >  LONGFILE_GNU)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_ERROR  ||  endBlock  >  LONGFILE_GNU)  {  finished  =  false;  }  else  {  finishEOFRecord();  buffer.flushBlock();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    finishEOFRecord();    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	107	None	replace
1138	[BUG]  [BUGGY]  Thread.currentThread().getIntermediateThread().intermediateThread();  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Thread.currentThread().getIntermediateThread().intermediateThread();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Thread.currentThread().getIntermediateThread().intermediateThread();	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
1139	[BUG]  [BUGGY]  Thread.currentThread().getIntermediateThread().intermediateThread().intermediateThread();  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  Thread.currentThread().getIntermediateThread().intermediateThread().intermediateThread();  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	Thread.currentThread().getIntermediateThread().intermediateThread().intermediateThread();	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
1140	[BUG]  [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null  &&  currName.length()  >  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null  &&  currName.length()  >  0)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(currName!=    null)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	50	None	replace
1141	[BUG]  [BUGGY]  while(!finished)  {  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  true;  }	  while(!closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	103	None	replace
1142	[BUG]  [BUGGY]  if(haveUnclosedEntry  ||  sealed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry  ||  sealed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry  ||  sealed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	105	None	replace
1143	[BUG]  [BUGGY]  else  if(closed)  {  finishUp();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(closed)  {  finishUp();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(closed)  {  finishUp();  buffer.flushBlock();  finished  =  true;  }	  else    if(closed)    {    finishEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	131	None	replace
1144	[BUG]  [BUGGY]  else  if(closed)  {  finish();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(closed)  {  finish();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(closed)  {  finish();  buffer.flushBlock();  finished  =  true;  }	  else    if(closed)    {    finishEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	131	None	replace
1145	[BUG]  [BUGGY]  else  if(closed)  {  finishArchive();  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  else  if(closed)  {  finishArchive();  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	else  if(closed)  {  finishArchive();  buffer.flushBlock();  finished  =  true;  }	  else    if(closed)    {    finishEOFRecord();    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	131	None	replace
1146	[BUG]  [BUGGY]  while(!finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	90	None	replace
1147	[BUG]  [BUGGY]  while(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!closed)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	90	None	replace
1148	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  out.close();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  out.close();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  out.close();  }	  finished    =    true;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    out.close();    }    	non-compiled	[CE]  <identifier>  expected	129	None	replace
1149	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.write(assemBuf,    0,    currSize);    }    	non-compiled	[CE]  <identifier>  expected	33	None	replace
1150	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  out.write(assemBuf,  0,  currSize);  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.write(assemBuf,    0,    currSize);    }    	non-compiled	[CE]  <identifier>  expected	33	None	replace
1151	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  buffer.writeBlock();  out.write(assemBuf,  0,  currSize);  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  buffer.writeBlock();  out.write(assemBuf,  0,  currSize);  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  {  buffer.writeBlock();  out.write(assemBuf,  0,  currSize);  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    out.write(assemBuf,    0,    currSize);    }    	non-compiled	[CE]  <identifier>  expected	33	None	replace
1152	[BUG]  [BUGGY]  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	49	None	replace
1153	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_ERROR>  endBlock  =  false;  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_ERROR>  endBlock  =  false;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_ERROR>  endBlock  =  false;	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBuffer();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	69	None	replace
1154	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_ERROR>  endBlock  =  true;  [CE]  <identifier>  expected  [FE]                                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_ERROR>  endBlock  =  true;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_ERROR>  endBlock  =  true;	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBuffer();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	69	None	replace
1155	[BUG]  [BUGGY]  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  end();  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
1156	[BUG]  [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(finished)  {  finished  =  true;  }  else  {  writeEOFRecord();  buffer.flushBlock();  startBlock();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	67	None	replace
1157	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  startBlock();  }  [CE]  <identifier>  expected  [FE]                                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  startBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  {  buffer.flushBlock();  startBlock();  }	  if(finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    startBlock();    }    	non-compiled	[CE]  <identifier>  expected	67	None	replace
1158	[BUG]  [BUGGY]  if(haveUnclosedEntry  ||!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry  ||!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry  ||!finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  finished  =  false;  }	  if(!finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    finished    =    false;    }    	non-compiled	[CE]  <identifier>  expected	52	None	replace
1159	[BUG]  [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&  hasUnclosedEntry)  {  finished  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrap  =  true;  }	  if(!finished)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	44	None	replace
1160	[BUG]  [BUGGY]  while(!finished  &&!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished  &&!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished  &&!closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  }	  if(haveUnclosedEntry)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	81	None	replace
1161	[BUG]  [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	46	None	replace
1162	[BUG]  [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry  ||  finished)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	46	None	replace
1163	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  sealed  =  true;  }  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  sealed  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  {  writeEOFRecord();  buffer.flushBlock();  sealed  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	46	None	replace
1164	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  ==  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                                AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  ==  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  false;  }  else  if(closed)  ==  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(finished)    {    finished    =    false;    }    else    if(closed)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	46	None	replace
1165	[BUG]  [BUGGY]  finished  =  new  byte[LONGFILE_GNU];  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  finished  =  new  byte[LONGFILE_GNU];  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	finished  =  new  byte[LONGFILE_GNU];	  finished    =   "   ";    	non-compiled	[CE]  <identifier>  expected	115	None	replace
1166	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  endBlock();  }  [CE]  <identifier>  expected  [FE]                            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  endBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  buffer.flushBlock();  endBlock();  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	108	None	replace
1167	[BUG]  [BUGGY]  EndBlock  <  LONGFILE_GNU>  endBlock  =  true;  [CE]  <identifier>  expected  [FE]                              AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  EndBlock  <  LONGFILE_GNU>  endBlock  =  true;  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	EndBlock  <  LONGFILE_GNU>  endBlock  =  true;	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    endBlock();    }    	non-compiled	[CE]  <identifier>  expected	108	None	replace
1168	[BUG]  [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finish  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finish  =  false;  }  else  {  buffer.flushBlock();  finished  =  true;  }	  if(finished)    {    finished    =    false;    }    else    {    buffer.flushBlock();    finished    =    true;    }    	non-compiled	[CE]  <identifier>  expected	130	None	replace
1169	[BUG]  [BUGGY]  while(!finished)  {  closed  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  while(!finished)  {  closed  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	while(!finished)  {  closed  =  false;  }  else  if(haveUnclosedEntry)  {  writeEOFRecord();  buffer.flushBlock();  wrapped  =  true;  }	  if(closed)    {    finished    =    false;    }    else    if(haveUnclosedEntry)    {    writeEOFRecord();    buffer.flushBlock();    wrapped    =    true;    }    	non-compiled	[CE]  <identifier>  expected	42	None	replace
1170	[BUG]  [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcBu  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcBu  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcBu	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	83	None	replace
1171	[BUG]  [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcBuffer  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcBuffer  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarc  descarcBuffer	  if(finished)    {    finished    =    true;    }    else    {    writeEOFRecord();    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	83	None	replace
1172	[BUG]  [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.releaseBlock();  }  [CE]  <identifier>  expected  [FE]                                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.releaseBlock();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(currName!=  null)  {  for(int  i  =  0;  i  <  currName.length();  i++)  {  buffer.releaseBlock();  }	  if(currName!=    null)    {    for(int    i    =    0;    i    <    currName.length();    i++)    {    buffer.flushBlock();    }    	non-compiled	[CE]  <identifier>  expected	13	None	replace
1173	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [CE]  <identifier>  expected  [FE]                    AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  finish();  }	  if(finished)    {    finished    =    true;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	138	None	replace
1174	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                      AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }	  if(finished)    {    finished    =    true;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	138	None	replace
1175	[BUG]  [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }  [CE]  <identifier>  expected  [FE]                        AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(closed)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  end();  }	  if(finished)    {    finished    =    true;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	138	None	replace
1176	[BUG]  [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }  [CE]  <identifier>  expected  [FE]                          AssertionFailedError      [CONTEXT]      if  (finished)  {  throw  new  IOException(     "This  archive  has  already  been  finished     ");  }  if(haveUnclosedEntry)  {  throw  new  IOException(     "This  archives  contains  unclosed  entries.     ");  }  writeEOFRecord();  writeEOFRecord();  buffer.flushBlock();      [BUGGY]  if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }  [BUGGY]      }  [CLASS]  TarArchiveOutputStream  [METHOD]  finish  [RETURN_TYPE]  void  [VARIABLES]  byte[]  assemBuf  recordBuf  boolean  closed  finished  haveUnclosedEntry  OutputStream  os  out  TarBuffer  buffer  String  currName  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  blockSize  longFileMode  recordSize  long  currBytes  currSize  	projects/Compress9/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java	1.0	131	131	1	replace	if(haveUnclosedEntry)  {  finished  =  true;  }  else  {  finishEOFRecord();  buffer.flushBlock();  start();  }	  if(finished)    {    finished    =    true;    }    else    {    finishEOFRecord();    buffer.flushBlock();    finish();    }    	non-compiled	[CE]  <identifier>  expected	138	None	replace
