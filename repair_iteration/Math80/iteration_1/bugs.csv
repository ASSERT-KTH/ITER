bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	original_buggy	action	patch	execution_result	diagnosis	previous_bug_id	new_failing_test_number
1	[BUG]  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[j]  /  work[j])  {  if(work[i]  <=  TOLERANCE_2  *  d)  {  work[j]  =  -0.0;  d  =  work[j]  /  work[j];  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[j]  /  work[j])  {  if(work[i]  <=  TOLERANCE_2  *  d)  {  work[j]  =  -0.0;  d  =  work[j]  /  work[j];  }  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	    if(MathUtils.SAFE_MIN  *  work[j]  /  work[j])  {  if(work[i]  <=  TOLERANCE_2  *  d)  {  work[j]  =  -0.0;  d  =  work[j]  /  work[j];  }		non-compiled	[CE]  illegal  start  of  expression	14	None
2	[BUG]  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[j]  /  work[j])  {  if(work[i]  >=  TOLERANCE_2  *  d)  {  work[j]  =  -0.0;  d  =  work[j]  /  work[j];  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[j]  /  work[j])  {  if(work[i]  >=  TOLERANCE_2  *  d)  {  work[j]  =  -0.0;  d  =  work[j]  /  work[j];  }  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	    if(MathUtils.SAFE_MIN  *  work[j]  /  work[j])  {  if(work[i]  >=  TOLERANCE_2  *  d)  {  work[j]  =  -0.0;  d  =  work[j]  /  work[j];  }		non-compiled	[CE]  illegal  start  of  expression	14	None
3	[BUG]  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[j]  /  work[j])  {  if(work[i]  <=  TOLERANCE_2  *  d)  {  work[j]  =  -1.0;  d  =  work[j]  /  work[j];  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[j]  /  work[j])  {  if(work[i]  <=  TOLERANCE_2  *  d)  {  work[j]  =  -1.0;  d  =  work[j]  /  work[j];  }  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	    if(MathUtils.SAFE_MIN  *  work[j]  /  work[j])  {  if(work[i]  <=  TOLERANCE_2  *  d)  {  work[j]  =  -1.0;  d  =  work[j]  /  work[j];  }		non-compiled	[CE]  illegal  start  of  expression	14	None
4	[BUG]  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[j]  /  work[j])  {  if(work[i]  >=  TOLERANCE_2  *  d)  {  work[j]  =  -1.0;  d  =  work[j]  /  work[j];  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[j]  /  work[j])  {  if(work[i]  >=  TOLERANCE_2  *  d)  {  work[j]  =  -1.0;  d  =  work[j]  /  work[j];  }  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	    if(MathUtils.SAFE_MIN  *  work[j]  /  work[j])  {  if(work[i]  >=  TOLERANCE_2  *  d)  {  work[j]  =  -1.0;  d  =  work[j]  /  work[j];  }		non-compiled	[CE]  illegal  start  of  expression	14	None
5	[BUG]  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[j]  /  work[j])  {  if(work[i]  <=  TOLERANCE_2  *  d)  {  work[j]  =  -2.0;  d  =  work[j]  /  work[j];  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[j]  /  work[j])  {  if(work[i]  <=  TOLERANCE_2  *  d)  {  work[j]  =  -2.0;  d  =  work[j]  /  work[j];  }  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	    if(MathUtils.SAFE_MIN  *  work[j]  /  work[j])  {  if(work[i]  <=  TOLERANCE_2  *  d)  {  work[j]  =  -2.0;  d  =  work[j]  /  work[j];  }		non-compiled	[CE]  illegal  start  of  expression	14	None
11	[BUG]  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[i  +  1]  &&  (MathUtils.SAFE_MIN  *  work[j]  /  work[j]))  {  d  =  work[i  +  2]  /  work[j];  d  *=  [CE]  illegal  start  of  expression  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[i  +  1]  &&  (MathUtils.SAFE_MIN  *  work[j]  /  work[j]))  {  d  =  work[i  +  2]  /  work[j];  d  *=  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	    if(MathUtils.SAFE_MIN  *  work[i  +  1]  &&  (MathUtils.SAFE_MIN  *  work[j]  /  work[j]))  {  d  =  work[i  +  2]  /  work[j];  d  *=		non-compiled	[CE]  illegal  start  of  expression	16	None
12	[BUG]  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[i  +  1]  &&  (MathUtils.SAFE_MIN  *  work[j]  /  work[j]))  {  d  =  work[i  +  2];  if(work[i]  <=  TOLERANCE_2  *  [CE]  ')'  expected  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[i  +  1]  &&  (MathUtils.SAFE_MIN  *  work[j]  /  work[j]))  {  d  =  work[i  +  2];  if(work[i]  <=  TOLERANCE_2  *  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	    if(MathUtils.SAFE_MIN  *  work[i  +  1]  &&  (MathUtils.SAFE_MIN  *  work[j]  /  work[j]))  {  d  =  work[i  +  2];  if(work[i]  <=  TOLERANCE_2  *		non-compiled	[CE]  ')'  expected	16	None
13	[BUG]  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[i  +  1]  &&  (MathUtils.SAFE_MIN  *  work[j]  -  d))  {  d  =  work[i  +  2]  /  work[j];  d  *=  tmp;  }  [CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[i  +  1]  &&  (MathUtils.SAFE_MIN  *  work[j]  -  d))  {  d  =  work[i  +  2]  /  work[j];  d  *=  tmp;  }  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	    if(MathUtils.SAFE_MIN  *  work[i  +  1]  &&  (MathUtils.SAFE_MIN  *  work[j]  -  d))  {  d  =  work[i  +  2]  /  work[j];  d  *=  tmp;  }		non-compiled	[CE]  bad  operand  types  for  binary  operator  '&&'	16	None
14	[BUG]  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[i  +  1]  &&  (MathUtils.SAFE_MIN  *  work[j]  /  work[j]))  {  d  =  work[i  +  2];  if(work[i]  <  TOLERANCE_2  *  [CE]  ')'  expected  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[i  +  1]  &&  (MathUtils.SAFE_MIN  *  work[j]  /  work[j]))  {  d  =  work[i  +  2];  if(work[i]  <  TOLERANCE_2  *  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	    if(MathUtils.SAFE_MIN  *  work[i  +  1]  &&  (MathUtils.SAFE_MIN  *  work[j]  /  work[j]))  {  d  =  work[i  +  2];  if(work[i]  <  TOLERANCE_2  *		non-compiled	[CE]  ')'  expected	16	None
15	[BUG]  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[i  +  1]  &&  (MathUtils.SAFE_MIN  *  work[j]  /  work[j]))  {  d  =  work[i  +  2]  /  work[j];  d  [CE]  illegal  start  of  expression  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[i  +  1]  &&  (MathUtils.SAFE_MIN  *  work[j]  /  work[j]))  {  d  =  work[i  +  2]  /  work[j];  d  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	    if(MathUtils.SAFE_MIN  *  work[i  +  1]  &&  (MathUtils.SAFE_MIN  *  work[j]  /  work[j]))  {  d  =  work[i  +  2]  /  work[j];  d		non-compiled	[CE]  illegal  start  of  expression	16	None
21	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  2]  =  -1.0;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	work[i  +  2]  =  -1.0;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
22	[BUG]  [BUGGY]  work[i  +  2]  =  -1.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  2]  =  -1.0;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	work[i  +  2]  =  -1.0;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
22	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  2]  =  -10.0;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	work[i  +  2]  =  -10.0;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
23	[BUG]  [BUGGY]  work[i  +  2]  =  -10.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  2]  =  -10.0;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	work[i  +  2]  =  -10.0;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
23	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  2]  =  -2.0;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	work[i  +  2]  =  -2.0;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
24	[BUG]  [BUGGY]  work[i  +  2]  =  -2.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  2]  =  -2.0;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	work[i  +  2]  =  -2.0;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
24	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  2]  =  -1;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	work[i  +  2]  =  -1;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
25	[BUG]  [BUGGY]  work[i  +  2]  =  -1;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  2]  =  -1;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	work[i  +  2]  =  -1;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
25	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	  	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
26	[BUG]  [BUGGY]    [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	  	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
31	[BUG]  [BUGGY]    i  =  Math.max(work[i  +  2]);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    i  =  Math.max(work[i  +  2]);  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	    i  =  Math.max(work[i  +  2]);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	2	None
32	[BUG]  [BUGGY]    i  =  Math.min(work[i  +  2]);  [CE]  no  suitable  method  found  for  min(double)  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    i  =  Math.min(work[i  +  2]);  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	    i  =  Math.min(work[i  +  2]);		non-compiled	[CE]  no  suitable  method  found  for  min(double)	2	None
33	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    i  =  1;  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	    i  =  1;		compilable	  [FE]  AssertionFailedError  testMathpbx02	2	1
34	[BUG]  [BUGGY]    i  =  1;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    i  =  1;  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	    i  =  1;		compilable	  [FE]  AssertionFailedError  testMathpbx02	2	1
34	[BUG]  [BUGGY]    i  =  Math.max(work[i  +  1]);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    i  =  Math.max(work[i  +  1]);  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	    i  =  Math.max(work[i  +  1]);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	2	None
35	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    i  =  1  +  i  /  2;  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	    i  =  1  +  i  /  2;		compilable	  [FE]  AssertionFailedError  testMathpbx02	2	1
36	[BUG]  [BUGGY]    i  =  1  +  i  /  2;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    i  =  1  +  i  /  2;  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	    i  =  1  +  i  /  2;		compilable	  [FE]  AssertionFailedError  testMathpbx02	2	1
41	[BUG]  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1,  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));  [CE]  ']'  expected  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1,  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));  [BUGGY]  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	work[l  -  1]  =  Math.min(work[l  -  1,  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));	work[l  -  1]  =    Math.min(work[l  -  1],        Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  	non-compiled	[CE]  ']'  expected	19	None
42	[BUG]  [BUGGY]  if(flipIfWarranted(deflatedEnd  -  1))  {  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  }  [CE]  method  flipIfWarranted  in  class  EigenDecompositionImpl  cannot  be  applied  to  given  types;  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]  if(flipIfWarranted(deflatedEnd  -  1))  {  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  }  [BUGGY]  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	if(flipIfWarranted(deflatedEnd  -  1))  {  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  }	work[l  -  1]  =    Math.min(work[l  -  1],        Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  	non-compiled	[CE]  method  flipIfWarranted  in  class  EigenDecompositionImpl  cannot  be  applied  to  given  types;	19	None
43	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  2]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  [BUGGY]  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	add	work[l  -  2]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));	work[l  -  1]  =    Math.min(work[l  -  1],        Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  	compilable	  [FE]  AssertionFailedError  testMathpbx02	19	1
44	[BUG]  [BUGGY]  work[l  -  2]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  2]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  [BUGGY]  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	work[l  -  2]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));	work[l  -  1]  =    Math.min(work[l  -  1],        Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  	compilable	  [FE]  AssertionFailedError  testMathpbx02	19	1
44	[BUG]  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1,  Math.min(work[3  +  pingPong],  work[4  *  pingPong]));  [CE]  ']'  expected  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1,  Math.min(work[3  +  pingPong],  work[4  *  pingPong]));  [BUGGY]  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	work[l  -  1]  =  Math.min(work[l  -  1,  Math.min(work[3  +  pingPong],  work[4  *  pingPong]));	work[l  -  1]  =    Math.min(work[l  -  1],        Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  	non-compiled	[CE]  ']'  expected	19	None
45	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    [BUGGY]  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	add	  	work[l  -  1]  =    Math.min(work[l  -  1],        Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  	compilable	  [FE]  AssertionFailedError  testMathpbx02	19	1
46	[BUG]  [BUGGY]    [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    [BUGGY]  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	  	work[l  -  1]  =    Math.min(work[l  -  1],        Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  	compilable	  [FE]  AssertionFailedError  testMathpbx02	19	1
51	[BUG]  [BUGGY]    dMin3  =  Math.max(dMin2,  work[l  -  1]));  [CE]  ';'  expected  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMin3  =  Math.max(dMin2,  work[l  -  1]));  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	    dMin3  =  Math.max(dMin2,  work[l  -  1]));		non-compiled	[CE]  ';'  expected	20	None
52	[BUG]  [BUGGY]    dMin3  =  Math.min(dMin3,  work[l  -  1]));  [CE]  ';'  expected  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMin3  =  Math.min(dMin3,  work[l  -  1]));  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	    dMin3  =  Math.min(dMin3,  work[l  -  1]));		non-compiled	[CE]  ';'  expected	20	None
53	[BUG]  [BUGGY]    dMin3  =  Math.min(dMin2,  work[l  -  1]));  [CE]  ';'  expected  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMin3  =  Math.min(dMin2,  work[l  -  1]));  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	    dMin3  =  Math.min(dMin2,  work[l  -  1]));		non-compiled	[CE]  ';'  expected	20	None
54	[BUG]  [BUGGY]    dMin3  =  Math.min(dMin3,  work[1]));  [CE]  ';'  expected  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMin3  =  Math.min(dMin3,  work[1]));  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	    dMin3  =  Math.min(dMin3,  work[1]));		non-compiled	[CE]  ';'  expected	20	None
55	[BUG]  [BUGGY]    dMin3  =  Math.max(dMin3,  work[1]));  [CE]  ';'  expected  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMin3  =  Math.max(dMin3,  work[1]));  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	    dMin3  =  Math.max(dMin3,  work[1]));		non-compiled	[CE]  ';'  expected	20	None
61	[BUG]  [BUGGY]  timeout  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]  i0  =  1  +  i  /  2;  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	i0  =  1  +  i  /  2;	i0  =  1  +  i  /  4;  	compilable	timeout	1	1
62	[BUG]  [BUGGY]  i0  =  1  +  i  /  2;  timeout  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]  i0  =  1  +  i  /  2;  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  +  i  /  2;	i0  =  1  +  i  /  4;  	compilable	timeout	1	1
62	[BUG]  [BUGGY]  timeout  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]  i0  =  1  +  i  *  4;  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	i0  =  1  +  i  *  4;	i0  =  1  +  i  /  4;  	compilable	timeout	1	1
63	[BUG]  [BUGGY]  i0  =  1  +  i  *  4;  timeout  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]  i0  =  1  +  i  *  4;  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  +  i  *  4;	i0  =  1  +  i  /  4;  	compilable	timeout	1	1
63	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]  i0  =  1  *  i  /  4;  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	i0  =  1  *  i  /  4;	i0  =  1  +  i  /  4;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	1	1
64	[BUG]  [BUGGY]  i0  =  1  *  i  /  4;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]  i0  =  1  *  i  /  4;  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  *  i  /  4;	i0  =  1  +  i  /  4;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	1	1
72	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]  i0  =  1  +  i  /  4;  [BUGGY]  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	add	i0  =  1  +  i  /  4;	break;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	3	1
73	[BUG]  [BUGGY]  i0  =  1  +  i  /  4;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]  i0  =  1  +  i  /  4;  [BUGGY]  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	i0  =  1  +  i  /  4;	break;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	3	1
73	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]  if(work[i0  +  1]  ==  0)  {  break;  }  [BUGGY]  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	add	if(work[i0  +  1]  ==  0)  {  break;  }	break;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	3	1
74	[BUG]  [BUGGY]  if(work[i0  +  1]  ==  0)  {  break;  }  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]  if(work[i0  +  1]  ==  0)  {  break;  }  [BUGGY]  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	if(work[i0  +  1]  ==  0)  {  break;  }	break;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	3	1
74	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]  if(work[i0]  >  0)  {  break;  }  [BUGGY]  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	add	if(work[i0]  >  0)  {  break;  }	break;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	3	1
75	[BUG]  [BUGGY]  if(work[i0]  >  0)  {  break;  }  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]  if(work[i0]  >  0)  {  break;  }  [BUGGY]  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	if(work[i0]  >  0)  {  break;  }	break;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	3	1
75	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]    [BUGGY]  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	add	  	break;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	3	1
76	[BUG]  [BUGGY]    [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]    [BUGGY]  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	  	break;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	3	1
81	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]  dMin2  =  Math.min(dMin,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	add	dMin2  =  Math.min(dMin,  work[l  -  1]);	dMin2  =  Math.min(dMin2,  work[l  -  1]);  	compilable	  [FE]  AssertionFailedError  testMathpbx02	17	1
82	[BUG]  [BUGGY]  dMin2  =  Math.min(dMin,  work[l  -  1]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]  dMin2  =  Math.min(dMin,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	dMin2  =  Math.min(dMin,  work[l  -  1]);	dMin2  =  Math.min(dMin2,  work[l  -  1]);  	compilable	  [FE]  AssertionFailedError  testMathpbx02	17	1
82	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]  dMin2  =  Math.max(dMin,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	add	dMin2  =  Math.max(dMin,  work[l  -  1]);	dMin2  =  Math.min(dMin2,  work[l  -  1]);  	compilable	  [FE]  AssertionFailedError  testMathpbx02	17	1
83	[BUG]  [BUGGY]  dMin2  =  Math.max(dMin,  work[l  -  1]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]  dMin2  =  Math.max(dMin,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	dMin2  =  Math.max(dMin,  work[l  -  1]);	dMin2  =  Math.min(dMin2,  work[l  -  1]);  	compilable	  [FE]  AssertionFailedError  testMathpbx02	17	1
84	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]  dMin2  =  Math.max(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	add	dMin2  =  Math.max(dMin2,  work[l  -  1]);	dMin2  =  Math.min(dMin2,  work[l  -  1]);  	compilable	  [FE]  AssertionFailedError  testMathpbx02	17	1
85	[BUG]  [BUGGY]  dMin2  =  Math.max(dMin2,  work[l  -  1]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]  dMin2  =  Math.max(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	dMin2  =  Math.max(dMin2,  work[l  -  1]);	dMin2  =  Math.min(dMin2,  work[l  -  1]);  	compilable	  [FE]  AssertionFailedError  testMathpbx02	17	1
85	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	add	  	dMin2  =  Math.min(dMin2,  work[l  -  1]);  	compilable	  [FE]  AssertionFailedError  testMathpbx02	17	1
86	[BUG]  [BUGGY]    [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	  	dMin2  =  Math.min(dMin2,  work[l  -  1]);  	compilable	  [FE]  AssertionFailedError  testMathpbx02	17	1
91	[BUG]  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  2]  ==  TolerANCE_2  *  d)  {  work[i  +  2]  =  -1.0;  }  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  2]  ==  TolerANCE_2  *  d)  {  work[i  +  2]  =  -1.0;  }  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  2]  ==  TolerANCE_2  *  d)  {  work[i  +  2]  =  -1.0;  }		non-compiled	[CE]  illegal  start  of  expression	8	None
92	[BUG]  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  2]  ==  TolerANCE_2  *  d)  {  work[i  +  2]  =  -2.0;  }  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  2]  ==  TolerANCE_2  *  d)  {  work[i  +  2]  =  -2.0;  }  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  2]  ==  TolerANCE_2  *  d)  {  work[i  +  2]  =  -2.0;  }		non-compiled	[CE]  illegal  start  of  expression	8	None
93	[BUG]  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  2]  ==  TolerANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  }  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  2]  ==  TolerANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  }  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  2]  ==  TolerANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  }		non-compiled	[CE]  illegal  start  of  expression	8	None
94	[BUG]  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  2]  ==  TolerANCE_2  *  d)  {  d  =  work[i  +  2];  }  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  2]  ==  TolerANCE_2  *  d)  {  d  =  work[i  +  2];  }  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  2]  ==  TolerANCE_2  *  d)  {  d  =  work[i  +  2];  }		non-compiled	[CE]  illegal  start  of  expression	8	None
95	[BUG]  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  2]  ==  TolerANCE_2  *  d)  {  work[i  +  2]  =  -0.5;  }  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  2]  ==  TolerANCE_2  *  d)  {  work[i  +  2]  =  -0.5;  }  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  2]  ==  TolerANCE_2  *  d)  {  work[i  +  2]  =  -0.5;  }		non-compiled	[CE]  illegal  start  of  expression	8	None
101	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i]  =  -10.0;  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	add	work[i]  =  -10.0;	work[i]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	9	1
102	[BUG]  [BUGGY]  work[i]  =  -10.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i]  =  -10.0;  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	work[i]  =  -10.0;	work[i]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	9	1
102	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i]  =  -1.0;  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	add	work[i]  =  -1.0;	work[i]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	9	1
103	[BUG]  [BUGGY]  work[i]  =  -1.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i]  =  -1.0;  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	work[i]  =  -1.0;	work[i]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	9	1
103	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i]  =  -1;  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	add	work[i]  =  -1;	work[i]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	9	1
104	[BUG]  [BUGGY]  work[i]  =  -1;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i]  =  -1;  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	work[i]  =  -1;	work[i]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	9	1
104	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i]  =  0.0;  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	add	work[i]  =  0.0;	work[i]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	9	1
105	[BUG]  [BUGGY]  work[i]  =  0.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i]  =  0.0;  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	work[i]  =  0.0;	work[i]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	9	1
105	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	add	  	work[i]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	9	1
106	[BUG]  [BUGGY]    [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	  	work[i]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	9	1
111	[BUG]  [BUGGY]  work[j]  =  TOLERANCE_1;  [CE]  cannot  find  symbol  TOLERANCE_1  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]  work[j]  =  TOLERANCE_1;  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	work[j]  =  TOLERANCE_1;	work[j]  =  d;  	non-compiled	[CE]  cannot  find  symbol  TOLERANCE_1	11	None
112	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]  work[j]  =  i;  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	add	work[j]  =  i;	work[j]  =  d;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	11	1
113	[BUG]  [BUGGY]  work[j]  =  i;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]  work[j]  =  i;  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	work[j]  =  i;	work[j]  =  d;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	11	1
113	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]  work[j]  =  TOLERANCE_2;  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	add	work[j]  =  TOLERANCE_2;	work[j]  =  d;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	11	1
114	[BUG]  [BUGGY]  work[j]  =  TOLERANCE_2;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]  work[j]  =  TOLERANCE_2;  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	work[j]  =  TOLERANCE_2;	work[j]  =  d;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	11	1
114	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]  work[j]  =  0;  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	add	work[j]  =  0;	work[j]  =  d;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	11	1
115	[BUG]  [BUGGY]  work[j]  =  0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]  work[j]  =  0;  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	work[j]  =  0;	work[j]  =  d;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	11	1
115	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	add	  	work[j]  =  d;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	11	1
116	[BUG]  [BUGGY]    [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	  	work[j]  =  d;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	11	1
121	[BUG]  [BUGGY]    work[i]  =  tolerance_1  *  d;  [CE]  cannot  find  symbol  tolerance_1  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =  tolerance_1  *  d;  [BUGGY]  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	    work[i]  =  tolerance_1  *  d;		non-compiled	[CE]  cannot  find  symbol  tolerance_1	10	None
122	[BUG]  [BUGGY]    work[i]  =  tolerance_2  *  d;  [CE]  cannot  find  symbol  tolerance_2  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =  tolerance_2  *  d;  [BUGGY]  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	    work[i]  =  tolerance_2  *  d;		non-compiled	[CE]  cannot  find  symbol  tolerance_2	10	None
123	[BUG]  [BUGGY]    work[i]  =  MathUtils.SAFE_2  *  work[j];  [CE]  cannot  find  symbol  SAFE_2  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =  MathUtils.SAFE_2  *  work[j];  [BUGGY]  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	    work[i]  =  MathUtils.SAFE_2  *  work[j];		non-compiled	[CE]  cannot  find  symbol  SAFE_2	10	None
124	[BUG]  [BUGGY]    work[i]  =  MathUtils.SAFE_1  *  work[i];  [CE]  cannot  find  symbol  SAFE_1  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =  MathUtils.SAFE_1  *  work[i];  [BUGGY]  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	    work[i]  =  MathUtils.SAFE_1  *  work[i];		non-compiled	[CE]  cannot  find  symbol  SAFE_1	10	None
125	[BUG]  [BUGGY]    work[i]  =  MathUtils.SAFE_2  *  work[i];  [CE]  cannot  find  symbol  SAFE_2  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =  MathUtils.SAFE_2  *  work[i];  [BUGGY]  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	    work[i]  =  MathUtils.SAFE_2  *  work[i];		non-compiled	[CE]  cannot  find  symbol  SAFE_2	10	None
131	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]  work[j]  =  0.0;  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	add	work[j]  =  0.0;	work[j  +  2]  =  0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	13	1
132	[BUG]  [BUGGY]  work[j]  =  0.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]  work[j]  =  0.0;  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	work[j]  =  0.0;	work[j  +  2]  =  0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	13	1
132	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]  work[i  +  2]  =  0.0;  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	add	work[i  +  2]  =  0.0;	work[j  +  2]  =  0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	13	1
133	[BUG]  [BUGGY]  work[i  +  2]  =  0.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]  work[i  +  2]  =  0.0;  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	work[i  +  2]  =  0.0;	work[j  +  2]  =  0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	13	1
134	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]  work[j  +  1]  =  0.0;  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	add	work[j  +  1]  =  0.0;	work[j  +  2]  =  0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	13	1
135	[BUG]  [BUGGY]  work[j  +  1]  =  0.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]  work[j  +  1]  =  0.0;  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	work[j  +  1]  =  0.0;	work[j  +  2]  =  0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	13	1
141	[BUG]  [BUGGY]  [FE]  InvalidMatrixException  testMathpbx02  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    d  =  work[i]  /  work[j];  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	add	    d  =  work[i]  /  work[j];		compilable	  [FE]  InvalidMatrixException  testMathpbx02	12	1
142	[BUG]  [BUGGY]    d  =  work[i]  /  work[j];  [FE]  InvalidMatrixException  testMathpbx02  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    d  =  work[i]  /  work[j];  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	    d  =  work[i]  /  work[j];		compilable	  [FE]  InvalidMatrixException  testMathpbx02	12	1
142	[BUG]  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[i]  /  work[j])  {  if(work[i]  <=  TOLERANCE_2  *  d)  {  work[j]  =  -0.0;  d  =  work[i]  /  work[j];  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[i]  /  work[j])  {  if(work[i]  <=  TOLERANCE_2  *  d)  {  work[j]  =  -0.0;  d  =  work[i]  /  work[j];  }  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	    if(MathUtils.SAFE_MIN  *  work[i]  /  work[j])  {  if(work[i]  <=  TOLERANCE_2  *  d)  {  work[j]  =  -0.0;  d  =  work[i]  /  work[j];  }		non-compiled	[CE]  illegal  start  of  expression	12	None
143	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    d  =  work[i  +  1];  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	add	    d  =  work[i  +  1];		compilable	  [FE]  AssertionFailedError  testMathpbx02	12	1
144	[BUG]  [BUGGY]    d  =  work[i  +  1];  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    d  =  work[i  +  1];  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	    d  =  work[i  +  1];		compilable	  [FE]  AssertionFailedError  testMathpbx02	12	1
144	[BUG]  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[i]  /  work[j])  {  if(work[i]  >=  TOLERANCE_2  *  d)  {  work[j]  =  -0.0;  d  =  work[i]  /  work[j];  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[i]  /  work[j])  {  if(work[i]  >=  TOLERANCE_2  *  d)  {  work[j]  =  -0.0;  d  =  work[i]  /  work[j];  }  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	    if(MathUtils.SAFE_MIN  *  work[i]  /  work[j])  {  if(work[i]  >=  TOLERANCE_2  *  d)  {  work[j]  =  -0.0;  d  =  work[i]  /  work[j];  }		non-compiled	[CE]  illegal  start  of  expression	12	None
145	[BUG]  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[i]  /  work[j])  {  if(work[i]  <=  TOLERANCE_2  *  d)  {  work[j]  =  -1.0;  d  =  work[i]  /  work[j];  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    if(MathUtils.SAFE_MIN  *  work[i]  /  work[j])  {  if(work[i]  <=  TOLERANCE_2  *  d)  {  work[j]  =  -1.0;  d  =  work[i]  /  work[j];  }  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	    if(MathUtils.SAFE_MIN  *  work[i]  /  work[j])  {  if(work[i]  <=  TOLERANCE_2  *  d)  {  work[j]  =  -1.0;  d  =  work[i]  /  work[j];  }		non-compiled	[CE]  illegal  start  of  expression	12	None
151	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    d  *=  work[i]  /(d  +  work[i  +  2]);  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	    d  *=  work[i]  /(d  +  work[i  +  2]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	6	1
152	[BUG]  [BUGGY]    d  *=  work[i]  /(d  +  work[i  +  2]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    d  *=  work[i]  /(d  +  work[i  +  2]);  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	    d  *=  work[i]  /(d  +  work[i  +  2]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	6	1
152	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    d  *=  work[i  +  1]  /(d  +  work[i  +  2]);  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	    d  *=  work[i  +  1]  /(d  +  work[i  +  2]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	6	1
153	[BUG]  [BUGGY]    d  *=  work[i  +  1]  /(d  +  work[i  +  2]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    d  *=  work[i  +  1]  /(d  +  work[i  +  2]);  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	    d  *=  work[i  +  1]  /(d  +  work[i  +  2]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	6	1
153	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    d  *=  work[i]  /(d  +  work[i  +  1]);  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	    d  *=  work[i]  /(d  +  work[i  +  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	6	1
154	[BUG]  [BUGGY]    d  *=  work[i]  /(d  +  work[i  +  1]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    d  *=  work[i]  /(d  +  work[i  +  1]);  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	    d  *=  work[i]  /(d  +  work[i  +  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	6	1
154	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    d  =  work[i]  /(d  +  work[i  +  2]);  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	    d  =  work[i]  /(d  +  work[i  +  2]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	6	1
155	[BUG]  [BUGGY]    d  =  work[i]  /(d  +  work[i  +  2]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    d  =  work[i]  /(d  +  work[i  +  2]);  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	    d  =  work[i]  /(d  +  work[i  +  2]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	6	1
155	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    d  =  work[i]  /(d  +  work[i  +  1]);  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	    d  =  work[i]  /(d  +  work[i  +  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	6	1
156	[BUG]  [BUGGY]    d  =  work[i]  /(d  +  work[i  +  1]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    d  =  work[i]  /(d  +  work[i  +  1]);  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	    d  =  work[i]  /(d  +  work[i  +  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	6	1
162	[BUG]  [BUGGY]    i0  =  Math.max(work[i]  +  work[i  +  2]);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]    i0  =  Math.max(work[i]  +  work[i  +  2]);  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	    i0  =  Math.max(work[i]  +  work[i  +  2]);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	4	None
163	[BUG]  [BUGGY]    i0  =  Math.min(i0,  work[i  +  2]);  [CE]  possible  loss  of  precision  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]    i0  =  Math.min(i0,  work[i  +  2]);  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	    i0  =  Math.min(i0,  work[i  +  2]);		non-compiled	[CE]  possible  loss  of  precision	4	None
164	[BUG]  [BUGGY]    i0  =  Math.min(i0,  work[i  +  1]);  [CE]  possible  loss  of  precision  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]    i0  =  Math.min(i0,  work[i  +  1]);  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	    i0  =  Math.min(i0,  work[i  +  1]);		non-compiled	[CE]  possible  loss  of  precision	4	None
165	[BUG]  [BUGGY]    i0  =  Math.min(i0,  work[i  +  4]);  [CE]  possible  loss  of  precision  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]    i0  =  Math.min(i0,  work[i  +  4]);  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	    i0  =  Math.min(i0,  work[i  +  4]);		non-compiled	[CE]  possible  loss  of  precision	4	None
171	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]  d  =  work[i  +  1];  [BUGGY]  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	add	d  =  work[i  +  1];	d  =  work[i];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	7	1
172	[BUG]  [BUGGY]  d  =  work[i  +  1];  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]  d  =  work[i  +  1];  [BUGGY]  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	d  =  work[i  +  1];	d  =  work[i];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	7	1
172	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]  d  =  work[i  +  2];  [BUGGY]  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	add	d  =  work[i  +  2];	d  =  work[i];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	7	1
173	[BUG]  [BUGGY]  d  =  work[i  +  2];  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]  d  =  work[i  +  2];  [BUGGY]  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	d  =  work[i  +  2];	d  =  work[i];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	7	1
173	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]  d  =  work[i]  -  1;  [BUGGY]  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	add	d  =  work[i]  -  1;	d  =  work[i];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	7	1
174	[BUG]  [BUGGY]  d  =  work[i]  -  1;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]  d  =  work[i]  -  1;  [BUGGY]  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	d  =  work[i]  -  1;	d  =  work[i];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	7	1
174	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]  d  =  work[i  +  3];  [BUGGY]  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	add	d  =  work[i  +  3];	d  =  work[i];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	7	1
175	[BUG]  [BUGGY]  d  =  work[i  +  3];  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]  d  =  work[i  +  3];  [BUGGY]  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	d  =  work[i  +  3];	d  =  work[i];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	7	1
181	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    dMin1  =  Math.min(dMin1,  work[0]);  [BUGGY]  dMin2  =  Math.min(dMin2,  work[l  -  1]);  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	add	    dMin1  =  Math.min(dMin1,  work[0]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	18	1
182	[BUG]  [BUGGY]    dMin1  =  Math.min(dMin1,  work[0]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    dMin1  =  Math.min(dMin1,  work[0]);  [BUGGY]  dMin2  =  Math.min(dMin2,  work[l  -  1]);  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	    dMin1  =  Math.min(dMin1,  work[0]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	18	1
182	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    dMin1  =  Math.max(dMin1,  work[0]);  [BUGGY]  dMin2  =  Math.min(dMin2,  work[l  -  1]);  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	add	    dMin1  =  Math.max(dMin1,  work[0]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	18	1
183	[BUG]  [BUGGY]    dMin1  =  Math.max(dMin1,  work[0]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    dMin1  =  Math.max(dMin1,  work[0]);  [BUGGY]  dMin2  =  Math.min(dMin2,  work[l  -  1]);  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	    dMin1  =  Math.max(dMin1,  work[0]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	18	1
183	[BUG]  [BUGGY]    dMin1  =  Math.min(dMin1);  [CE]  no  suitable  method  found  for  min(double)  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    dMin1  =  Math.min(dMin1);  [BUGGY]  dMin2  =  Math.min(dMin2,  work[l  -  1]);  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	    dMin1  =  Math.min(dMin1);		non-compiled	[CE]  no  suitable  method  found  for  min(double)	18	None
184	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    dMin1  =  Math.min(dMin1,  work[l  -  1]);  [BUGGY]  dMin2  =  Math.min(dMin2,  work[l  -  1]);  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	add	    dMin1  =  Math.min(dMin1,  work[l  -  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	18	1
185	[BUG]  [BUGGY]    dMin1  =  Math.min(dMin1,  work[l  -  1]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    dMin1  =  Math.min(dMin1,  work[l  -  1]);  [BUGGY]  dMin2  =  Math.min(dMin2,  work[l  -  1]);  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	    dMin1  =  Math.min(dMin1,  work[l  -  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	18	1
185	[BUG]  [BUGGY]    dMin1  =  Math.min(dMin1,  work[0]));  [CE]  ';'  expected  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    dMin1  =  Math.min(dMin1,  work[0]));  [BUGGY]  dMin2  =  Math.min(dMin2,  work[l  -  1]);  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	    dMin1  =  Math.min(dMin1,  work[0]));		non-compiled	[CE]  ';'  expected	18	None
191	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]  d  =  work[i  +  1];  [BUGGY]  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	add	d  =  work[i  +  1];	d  =  work[i  +  2];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	15	1
192	[BUG]  [BUGGY]  d  =  work[i  +  1];  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]  d  =  work[i  +  1];  [BUGGY]  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	d  =  work[i  +  1];	d  =  work[i  +  2];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	15	1
192	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]  d  =  work[i  +  3];  [BUGGY]  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	add	d  =  work[i  +  3];	d  =  work[i  +  2];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	15	1
193	[BUG]  [BUGGY]  d  =  work[i  +  3];  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]  d  =  work[i  +  3];  [BUGGY]  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	d  =  work[i  +  3];	d  =  work[i  +  2];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	15	1
194	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]  d  =  work[j  +  2];  [BUGGY]  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	add	d  =  work[j  +  2];	d  =  work[i  +  2];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	15	1
195	[BUG]  [BUGGY]  d  =  work[j  +  2];  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]  d  =  work[j  +  2];  [BUGGY]  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	d  =  work[j  +  2];	d  =  work[i  +  2];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	15	1
1	[BUG]  [BUGGY]    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  Tolerance_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -1.0;  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  Tolerance_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -1.0;  }  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  Tolerance_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -1.0;  }		non-compiled	[CE]  illegal  start  of  expression	14	None
2	[BUG]  [BUGGY]    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  Tolerance_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j  *=  d;  }  [CE]  ']'  expected  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  Tolerance_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j  *=  d;  }  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  Tolerance_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j  *=  d;  }		non-compiled	[CE]  ']'  expected	14	None
3	[BUG]  [BUGGY]    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j  *=  d;  }  [CE]  ']'  expected  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j  *=  d;  }  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j  *=  d;  }		non-compiled	[CE]  ']'  expected	14	None
4	[BUG]  [BUGGY]    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  Tolerance_2)  {  if(work[j  +  1]  ==  0)  {  work[j  *=  d;  }  [CE]  ']'  expected  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  Tolerance_2)  {  if(work[j  +  1]  ==  0)  {  work[j  *=  d;  }  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  Tolerance_2)  {  if(work[j  +  1]  ==  0)  {  work[j  *=  d;  }		non-compiled	[CE]  ']'  expected	14	None
5	[BUG]  [BUGGY]    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -1.0;  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -1.0;  }  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -1.0;  }		non-compiled	[CE]  illegal  start  of  expression	14	None
23	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]  work[i  +  1]  =  0.0;  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	add	work[i  +  1]  =  0.0;	work[j  +  2]  =  0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	13	1
24	[BUG]  [BUGGY]  work[i  +  1]  =  0.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]  work[i  +  1]  =  0.0;  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	work[i  +  1]  =  0.0;	work[j  +  2]  =  0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	13	1
41	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    d  =  work[i  +  1]  /  TOLERANCE_2;  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	    d  =  work[i  +  1]  /  TOLERANCE_2;		compilable	  [FE]  AssertionFailedError  testMathpbx02	6	1
42	[BUG]  [BUGGY]    d  =  work[i  +  1]  /  TOLERANCE_2;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    d  =  work[i  +  1]  /  TOLERANCE_2;  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	    d  =  work[i  +  1]  /  TOLERANCE_2;		compilable	  [FE]  AssertionFailedError  testMathpbx02	6	1
42	[BUG]  [BUGGY]    d  =  work[i  +  1]  /  TOLERANCE_1  *  d;  [CE]  cannot  find  symbol  TOLERANCE_1  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    d  =  work[i  +  1]  /  TOLERANCE_1  *  d;  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	    d  =  work[i  +  1]  /  TOLERANCE_1  *  d;		non-compiled	[CE]  cannot  find  symbol  TOLERANCE_1	6	None
43	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    d  *=  work[i  +  1]  /  TOLERANCE_2;  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	    d  *=  work[i  +  1]  /  TOLERANCE_2;		compilable	  [FE]  AssertionFailedError  testMathpbx02	6	1
44	[BUG]  [BUGGY]    d  *=  work[i  +  1]  /  TOLERANCE_2;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    d  *=  work[i  +  1]  /  TOLERANCE_2;  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	    d  *=  work[i  +  1]  /  TOLERANCE_2;		compilable	  [FE]  AssertionFailedError  testMathpbx02	6	1
44	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i  +  1]  =  -1.0;  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	    work[i  +  1]  =  -1.0;		compilable	  [FE]  AssertionFailedError  testMathpbx02	6	1
45	[BUG]  [BUGGY]    work[i  +  1]  =  -1.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i  +  1]  =  -1.0;  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	    work[i  +  1]  =  -1.0;		compilable	  [FE]  AssertionFailedError  testMathpbx02	6	1
45	[BUG]  [BUGGY]    d  =  work[i  +  1]  /  TOLERANCE_1;  [CE]  cannot  find  symbol  TOLERANCE_1  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    d  =  work[i  +  1]  /  TOLERANCE_1;  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	    d  =  work[i  +  1]  /  TOLERANCE_1;		non-compiled	[CE]  cannot  find  symbol  TOLERANCE_1	6	None
61	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  /  TOLERANCE_2);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =  Math.max(work[i]  /  TOLERANCE_2);  [BUGGY]  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	    work[i]  =  Math.max(work[i]  /  TOLERANCE_2);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	10	None
62	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  *  TOLERANCE_2);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =  Math.max(work[i]  *  TOLERANCE_2);  [BUGGY]  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	    work[i]  =  Math.max(work[i]  *  TOLERANCE_2);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	10	None
63	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  -  tolerance_2);  [CE]  cannot  find  symbol  tolerance_2  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =  Math.max(work[i]  -  tolerance_2);  [BUGGY]  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	    work[i]  =  Math.max(work[i]  -  tolerance_2);		non-compiled	[CE]  cannot  find  symbol  tolerance_2	10	None
64	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  *  TOLERANCE_2;  [CE]  ')'  expected  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =  Math.max(work[i]  *  TOLERANCE_2;  [BUGGY]  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	    work[i]  =  Math.max(work[i]  *  TOLERANCE_2;		non-compiled	[CE]  ')'  expected	10	None
65	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  /  TOLERANCE_2;  [CE]  ')'  expected  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =  Math.max(work[i]  /  TOLERANCE_2;  [BUGGY]  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	    work[i]  =  Math.max(work[i]  /  TOLERANCE_2;		non-compiled	[CE]  ')'  expected	10	None
81	[BUG]  [BUGGY]    i0  =  Math.max(i0,  work[i  +  2]);  [CE]  possible  loss  of  precision  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]    i0  =  Math.max(i0,  work[i  +  2]);  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	    i0  =  Math.max(i0,  work[i  +  2]);		non-compiled	[CE]  possible  loss  of  precision	4	None
82	[BUG]  [BUGGY]    i0  =  Math.max(i0,  work[i  +  4]);  [CE]  possible  loss  of  precision  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]    i0  =  Math.max(i0,  work[i  +  4]);  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	    i0  =  Math.max(i0,  work[i  +  4]);		non-compiled	[CE]  possible  loss  of  precision	4	None
83	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]    offDiagMax  =  Math.max(i0,  work[i  +  2]);  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	add	    offDiagMax  =  Math.max(i0,  work[i  +  2]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	4	1
84	[BUG]  [BUGGY]    offDiagMax  =  Math.max(i0,  work[i  +  2]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]    offDiagMax  =  Math.max(i0,  work[i  +  2]);  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	    offDiagMax  =  Math.max(i0,  work[i  +  2]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	4	1
84	[BUG]  [BUGGY]    i0  =  Math.max(i0,  work[i  +  1]);  [CE]  possible  loss  of  precision  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]    i0  =  Math.max(i0,  work[i  +  1]);  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	    i0  =  Math.max(i0,  work[i  +  1]);		non-compiled	[CE]  possible  loss  of  precision	4	None
85	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  /  2);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]    work[i]  =  Math.max(work[i]  /  2);  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	    work[i]  =  Math.max(work[i]  /  2);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	4	None
101	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  /  TOLERANCE_2);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    work[i]  =  Math.max(work[i]  /  TOLERANCE_2);  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	    work[i]  =  Math.max(work[i]  /  TOLERANCE_2);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	12	None
102	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  /  TOLERANCE_3);  [CE]  cannot  find  symbol  TOLERANCE_3  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    work[i]  =  Math.max(work[i]  /  TOLERANCE_3);  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	    work[i]  =  Math.max(work[i]  /  TOLERANCE_3);		non-compiled	[CE]  cannot  find  symbol  TOLERANCE_3	12	None
103	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  *  TOLERANCE_2);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    work[i]  =  Math.max(work[i]  *  TOLERANCE_2);  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	    work[i]  =  Math.max(work[i]  *  TOLERANCE_2);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	12	None
104	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  -  toLERANCE_2);  [CE]  cannot  find  symbol  toLERANCE_2  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    work[i]  =  Math.max(work[i]  -  toLERANCE_2);  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	    work[i]  =  Math.max(work[i]  -  toLERANCE_2);		non-compiled	[CE]  cannot  find  symbol  toLERANCE_2	12	None
105	[BUG]  [BUGGY]    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  Tolerance_2)  {  if(work[j  +  1]  ==  d)  {  work[j]  =  -work;  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  Tolerance_2)  {  if(work[j  +  1]  ==  d)  {  work[j]  =  -work;  }  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	    if(work[i  +  1]  <  TOLERANCE_1  &&  work[i]  <=  Tolerance_2)  {  if(work[j  +  1]  ==  d)  {  work[j]  =  -work;  }		non-compiled	[CE]  illegal  start  of  expression	12	None
121	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]  i0  =  0  +  i  /  4;  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	i0  =  0  +  i  /  4;	i0  =  1  +  i  /  4;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	1	1
122	[BUG]  [BUGGY]  i0  =  0  +  i  /  4;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]  i0  =  0  +  i  /  4;  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  0  +  i  /  4;	i0  =  1  +  i  /  4;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	1	1
123	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]  i0  =  0  *  i  /  4;  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	i0  =  0  *  i  /  4;	i0  =  1  +  i  /  4;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	1	1
124	[BUG]  [BUGGY]  i0  =  0  *  i  /  4;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]  i0  =  0  *  i  /  4;  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  0  *  i  /  4;	i0  =  1  +  i  /  4;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	1	1
124	[BUG]  [BUGGY]  i0  =  0  +  work  /  4;  [CE]  bad  operand  types  for  binary  operator  '/'  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]  i0  =  0  +  work  /  4;  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  0  +  work  /  4;	i0  =  1  +  i  /  4;  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	1	None
141	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    dMin1  =  Math.max(dMin1,  work[l  -  1]);  [BUGGY]  dMin2  =  Math.min(dMin2,  work[l  -  1]);  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	add	    dMin1  =  Math.max(dMin1,  work[l  -  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	18	1
142	[BUG]  [BUGGY]    dMin1  =  Math.max(dMin1,  work[l  -  1]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    dMin1  =  Math.max(dMin1,  work[l  -  1]);  [BUGGY]  dMin2  =  Math.min(dMin2,  work[l  -  1]);  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	    dMin1  =  Math.max(dMin1,  work[l  -  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	18	1
143	[BUG]  [BUGGY]    work  =  Math.max(dMin1,  dMin2);  [CE]  incompatible  types  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    work  =  Math.max(dMin1,  dMin2);  [BUGGY]  dMin2  =  Math.min(dMin2,  work[l  -  1]);  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	    work  =  Math.max(dMin1,  dMin2);		non-compiled	[CE]  incompatible  types	18	None
144	[BUG]  [BUGGY]    dMin1  =  Math.max(dMin1,  work[0],  work[1]);  [CE]  no  suitable  method  found  for  max(double,double,double)  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    dMin1  =  Math.max(dMin1,  work[0],  work[1]);  [BUGGY]  dMin2  =  Math.min(dMin2,  work[l  -  1]);  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	    dMin1  =  Math.max(dMin1,  work[0],  work[1]);		non-compiled	[CE]  no  suitable  method  found  for  max(double,double,double)	18	None
145	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    dMin1  =  Math.max(dMin1,  work[l  +  1]);  [BUGGY]  dMin2  =  Math.min(dMin2,  work[l  -  1]);  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	add	    dMin1  =  Math.max(dMin1,  work[l  +  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	18	1
146	[BUG]  [BUGGY]    dMin1  =  Math.max(dMin1,  work[l  +  1]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    dMin1  =  Math.max(dMin1,  work[l  +  1]);  [BUGGY]  dMin2  =  Math.min(dMin2,  work[l  -  1]);  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	    dMin1  =  Math.max(dMin1,  work[l  +  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	18	1
162	[BUG]  [BUGGY]  work[j]  =  TOLERANCE_3;  [CE]  cannot  find  symbol  TOLERANCE_3  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]  work[j]  =  TOLERANCE_3;  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	work[j]  =  TOLERANCE_3;	work[j]  =  d;  	non-compiled	[CE]  cannot  find  symbol  TOLERANCE_3	11	None
181	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]  if(work[i  +  1]  <  0)  {  break;  }  [BUGGY]  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	add	if(work[i  +  1]  <  0)  {  break;  }	break;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	3	1
182	[BUG]  [BUGGY]  if(work[i  +  1]  <  0)  {  break;  }  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]  if(work[i  +  1]  <  0)  {  break;  }  [BUGGY]  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	if(work[i  +  1]  <  0)  {  break;  }	break;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	3	1
182	[BUG]  [BUGGY]  if(i0  >=  n2)  {  break;  }  [CE]  cannot  find  symbol  n2  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]  if(i0  >=  n2)  {  break;  }  [BUGGY]  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	if(i0  >=  n2)  {  break;  }	break;  	non-compiled	[CE]  cannot  find  symbol  n2	3	None
183	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]  if(i0  >  0)  {  break;  }  [BUGGY]  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	add	if(i0  >  0)  {  break;  }	break;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	3	1
184	[BUG]  [BUGGY]  if(i0  >  0)  {  break;  }  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]  if(i0  >  0)  {  break;  }  [BUGGY]  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	if(i0  >  0)  {  break;  }	break;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	3	1
221	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  1]  =  -10.0;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	work[i  +  1]  =  -10.0;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
222	[BUG]  [BUGGY]  work[i  +  1]  =  -10.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  1]  =  -10.0;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	work[i  +  1]  =  -10.0;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
224	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  1]  =  -0.0;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	work[i  +  1]  =  -0.0;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
225	[BUG]  [BUGGY]  work[i  +  1]  =  -0.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  1]  =  -0.0;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	work[i  +  1]  =  -0.0;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
241	[BUG]  [BUGGY]    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  2]);  [CE]  method  pow  in  class  Math  cannot  be  applied  to  given  types;  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  2]);  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  2]);		non-compiled	[CE]  method  pow  in  class  Math  cannot  be  applied  to  given  types;	16	None
242	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  2],  TOLERANCE_2);  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	add	    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  2],  TOLERANCE_2);		compilable	  [FE]  AssertionFailedError  testMathpbx02	16	1
243	[BUG]  [BUGGY]    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  2],  TOLERANCE_2);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  2],  TOLERANCE_2);  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  2],  TOLERANCE_2);		compilable	  [FE]  AssertionFailedError  testMathpbx02	16	1
243	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  1],  TOLERANCE_2  *  work[i]);  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	add	    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  1],  TOLERANCE_2  *  work[i]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	16	1
244	[BUG]  [BUGGY]    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  1],  TOLERANCE_2  *  work[i]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  1],  TOLERANCE_2  *  work[i]);  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  1],  TOLERANCE_2  *  work[i]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	16	1
244	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  1],  TOLERANCE_2);  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	add	    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  1],  TOLERANCE_2);		compilable	  [FE]  AssertionFailedError  testMathpbx02	16	1
245	[BUG]  [BUGGY]    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  1],  TOLERANCE_2);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  1],  TOLERANCE_2);  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  1],  TOLERANCE_2);		compilable	  [FE]  AssertionFailedError  testMathpbx02	16	1
245	[BUG]  [BUGGY]    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  2]  /  work[j]);  [CE]  method  pow  in  class  Math  cannot  be  applied  to  given  types;  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  2]  /  work[j]);  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	    work[i]  =  Math.pow(MathUtils.SAFE_MIN  *  work[i  +  2]  /  work[j]);		non-compiled	[CE]  method  pow  in  class  Math  cannot  be  applied  to  given  types;	16	None
264	[BUG]  [BUGGY]  d  =  work[i]  /  TOLERANCE_3;  [CE]  cannot  find  symbol  TOLERANCE_3  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]  d  =  work[i]  /  TOLERANCE_3;  [BUGGY]  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	d  =  work[i]  /  TOLERANCE_3;	d  =  work[i];  	non-compiled	[CE]  cannot  find  symbol  TOLERANCE_3	7	None
301	[BUG]  [BUGGY]  work[l  -  1]  =  Math.min(dMin2,  work[l  -  1],  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));  [CE]  no  suitable  method  found  for  min(double,double,double)  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.min(dMin2,  work[l  -  1],  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));  [BUGGY]  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	work[l  -  1]  =  Math.min(dMin2,  work[l  -  1],  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));	work[l  -  1]  =    Math.min(work[l  -  1],        Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  	non-compiled	[CE]  no  suitable  method  found  for  min(double,double,double)	19	None
302	[BUG]  [BUGGY]  work[l  -  1]  =  Math.max(dMin2,  work[l  -  1],  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));  [CE]  no  suitable  method  found  for  max(double,double,double)  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.max(dMin2,  work[l  -  1],  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));  [BUGGY]  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	work[l  -  1]  =  Math.max(dMin2,  work[l  -  1],  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));	work[l  -  1]  =    Math.min(work[l  -  1],        Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  	non-compiled	[CE]  no  suitable  method  found  for  max(double,double,double)	19	None
303	[BUG]  [BUGGY]  work[l  -  1]  =  Math.min(dMin1,  work[l  -  1],  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));  [CE]  no  suitable  method  found  for  min(double,double,double)  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.min(dMin1,  work[l  -  1],  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));  [BUGGY]  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	work[l  -  1]  =  Math.min(dMin1,  work[l  -  1],  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));	work[l  -  1]  =    Math.min(work[l  -  1],        Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  	non-compiled	[CE]  no  suitable  method  found  for  min(double,double,double)	19	None
304	[BUG]  [BUGGY]  work[l  -  1]  =  Math.min(dMin2,  work[l  +  1],  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));  [CE]  no  suitable  method  found  for  min(double,double,double)  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.min(dMin2,  work[l  +  1],  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));  [BUGGY]  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	work[l  -  1]  =  Math.min(dMin2,  work[l  +  1],  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));	work[l  -  1]  =    Math.min(work[l  -  1],        Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  	non-compiled	[CE]  no  suitable  method  found  for  min(double,double,double)	19	None
321	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMin1  =  Math.max(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	add	    dMin1  =  Math.max(dMin2,  work[l  -  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	20	1
322	[BUG]  [BUGGY]    dMin1  =  Math.max(dMin2,  work[l  -  1]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMin1  =  Math.max(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	    dMin1  =  Math.max(dMin2,  work[l  -  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	20	1
322	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMin1  =  Math.max(dMin2,  work[l  +  1]);  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	add	    dMin1  =  Math.max(dMin2,  work[l  +  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	20	1
323	[BUG]  [BUGGY]    dMin1  =  Math.max(dMin2,  work[l  +  1]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMin1  =  Math.max(dMin2,  work[l  +  1]);  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	    dMin1  =  Math.max(dMin2,  work[l  +  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	20	1
323	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMin2  =  Math.max(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	add	    dMin2  =  Math.max(dMin2,  work[l  -  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	20	1
324	[BUG]  [BUGGY]    dMin2  =  Math.max(dMin2,  work[l  -  1]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMin2  =  Math.max(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	    dMin2  =  Math.max(dMin2,  work[l  -  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	20	1
324	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    work[l  -  1]  =  Math.max(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	add	    work[l  -  1]  =  Math.max(dMin2,  work[l  -  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	20	1
325	[BUG]  [BUGGY]    work[l  -  1]  =  Math.max(dMin2,  work[l  -  1]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    work[l  -  1]  =  Math.max(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	    work[l  -  1]  =  Math.max(dMin2,  work[l  -  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	20	1
325	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMin1  =  Math.max(dMin2,  work[l]);  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	add	    dMin1  =  Math.max(dMin2,  work[l]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	20	1
326	[BUG]  [BUGGY]    dMin1  =  Math.max(dMin2,  work[l]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMin1  =  Math.max(dMin2,  work[l]);  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	    dMin1  =  Math.max(dMin2,  work[l]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	20	1
341	[BUG]  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  1]  ==  TOLERANCE_2  *  d)  {  work[i  +  1]  =  -1.0;  }  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  1]  ==  TOLERANCE_2  *  d)  {  work[i  +  1]  =  -1.0;  }  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  1]  ==  TOLERANCE_2  *  d)  {  work[i  +  1]  =  -1.0;  }		non-compiled	[CE]  illegal  start  of  expression	8	None
342	[BUG]  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  1]  ==  TOLERANCE_2  *  d)  {  work[i]  =  -1.0;  }  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  1]  ==  TOLERANCE_2  *  d)  {  work[i]  =  -1.0;  }  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  1]  ==  TOLERANCE_2  *  d)  {  work[i]  =  -1.0;  }		non-compiled	[CE]  illegal  start  of  expression	8	None
343	[BUG]  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  1]  ==  TOLERANCE_2  *  d)  {  work[i  +  1]  =  -0.5;  }  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  1]  ==  TOLERANCE_2  *  d)  {  work[i  +  1]  =  -0.5;  }  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  +  1]  ==  TOLERANCE_2  *  d)  {  work[i  +  1]  =  -0.5;  }		non-compiled	[CE]  illegal  start  of  expression	8	None
344	[BUG]  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  for(int  k  =  0;  k  <  k;  ++k)  {  d  *=  work[i  +  1];  }  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  for(int  k  =  0;  k  <  k;  ++k)  {  d  *=  work[i  +  1];  }  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  for(int  k  =  0;  k  <  k;  ++k)  {  d  *=  work[i  +  1];  }		non-compiled	[CE]  illegal  start  of  expression	8	None
345	[BUG]  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  for(int  k  =  0;  k  <  k;  ++k)  {  work[i  +  1]  =  -1.0;  }  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  for(int  k  =  0;  k  <  k;  ++k)  {  work[i  +  1]  =  -1.0;  }  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  for(int  k  =  0;  k  <  k;  ++k)  {  work[i  +  1]  =  -1.0;  }		non-compiled	[CE]  illegal  start  of  expression	8	None
361	[BUG]  [BUGGY]    work  =  Math.max(work[i  +  2]);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    work  =  Math.max(work[i  +  2]);  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	    work  =  Math.max(work[i  +  2]);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	2	None
362	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    offDiagMax  =  Math.max(diagMin,  work[i  +  2]);  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	    offDiagMax  =  Math.max(diagMin,  work[i  +  2]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	2	1
363	[BUG]  [BUGGY]    offDiagMax  =  Math.max(diagMin,  work[i  +  2]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    offDiagMax  =  Math.max(diagMin,  work[i  +  2]);  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	    offDiagMax  =  Math.max(diagMin,  work[i  +  2]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	2	1
363	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i  +  2]);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    work[i]  =  Math.max(work[i  +  2]);  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	    work[i]  =  Math.max(work[i  +  2]);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	2	None
364	[BUG]  [BUGGY]    work[i  +  1]  =  Math.max(work[i  +  1]);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    work[i  +  1]  =  Math.max(work[i  +  1]);  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	    work[i  +  1]  =  Math.max(work[i  +  1]);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	2	None
365	[BUG]  [BUGGY]    work  =  Math.max(work[i  +  2]  -  0);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    work  =  Math.max(work[i  +  2]  -  0);  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	    work  =  Math.max(work[i  +  2]  -  0);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	2	None
3	[BUG]  [BUGGY]    work[l]  =  Math.max(work[0],  Math.min(work[1],  work[2],  work[3]);  [CE]  ')'  expected  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    work[l]  =  Math.max(work[0],  Math.min(work[1],  work[2],  work[3]);  [BUGGY]  dMin2  =  Math.min(dMin2,  work[l  -  1]);  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	    work[l]  =  Math.max(work[0],  Math.min(work[1],  work[2],  work[3]);		non-compiled	[CE]  ')'  expected	18	None
4	[BUG]  [BUGGY]    dMin1  =  Math.max(work[0],  Math.min(work[1],  work[2],  work[3]);  [CE]  ')'  expected  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]    dMin1  =  Math.max(work[0],  Math.min(work[1],  work[2],  work[3]);  [BUGGY]  dMin2  =  Math.min(dMin2,  work[l  -  1]);  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	    dMin1  =  Math.max(work[0],  Math.min(work[1],  work[2],  work[3]);		non-compiled	[CE]  ')'  expected	18	None
31	[BUG]  [BUGGY]    if(work[i]  >=  TOLERANCE_1  *  work[j])  {  if(work[i  +  1]  ==  TOLERANCE_2  &&  work[i]  <=  TOLERANCE_3)  {  work[j]  =  d;  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]    if(work[i]  >=  TOLERANCE_1  *  work[j])  {  if(work[i  +  1]  ==  TOLERANCE_2  &&  work[i]  <=  TOLERANCE_3)  {  work[j]  =  d;  }  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	    if(work[i]  >=  TOLERANCE_1  *  work[j])  {  if(work[i  +  1]  ==  TOLERANCE_2  &&  work[i]  <=  TOLERANCE_3)  {  work[j]  =  d;  }		non-compiled	[CE]  illegal  start  of  expression	14	None
32	[BUG]  [BUGGY]    if(work[i]  >=  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[j]  <=  tolerance_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  d;  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]    if(work[i]  >=  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[j]  <=  tolerance_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  d;  }  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	    if(work[i]  >=  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[j]  <=  tolerance_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  d;  }		non-compiled	[CE]  illegal  start  of  expression	14	None
33	[BUG]  [BUGGY]    if(work[i]  >=  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[j]  }  tolerance_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  d;  }  [CE]  ')'  expected  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]    if(work[i]  >=  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[j]  }  tolerance_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  d;  }  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	    if(work[i]  >=  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[j]  }  tolerance_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  d;  }		non-compiled	[CE]  ')'  expected	14	None
34	[BUG]  [BUGGY]    if(work[i]  >=  TOLERANCE_1  *  work[j])  {  if(work[i  +  1]  ==  TOLERANCE_2  &&  work[i]  <=  TOLERANCE_3)  {  work[j]  =  -work;  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]    if(work[i]  >=  TOLERANCE_1  *  work[j])  {  if(work[i  +  1]  ==  TOLERANCE_2  &&  work[i]  <=  TOLERANCE_3)  {  work[j]  =  -work;  }  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	    if(work[i]  >=  TOLERANCE_1  *  work[j])  {  if(work[i  +  1]  ==  TOLERANCE_2  &&  work[i]  <=  TOLERANCE_3)  {  work[j]  =  -work;  }		non-compiled	[CE]  illegal  start  of  expression	14	None
35	[BUG]  [BUGGY]    if(work[i]  >=  TOLERANCE_1  *  work[j])  {  if(work[i  +  1]  ==  TOLERANCE_2  &&  work[i]  <=  TOLERANCE_3)  {  work[j  =  d;  }  [CE]  ']'  expected  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]    if(work[i]  >=  TOLERANCE_1  *  work[j])  {  if(work[i  +  1]  ==  TOLERANCE_2  &&  work[i]  <=  TOLERANCE_3)  {  work[j  =  d;  }  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	    if(work[i]  >=  TOLERANCE_1  *  work[j])  {  if(work[i  +  1]  ==  TOLERANCE_2  &&  work[i]  <=  TOLERANCE_3)  {  work[j  =  d;  }		non-compiled	[CE]  ']'  expected	14	None
61	[BUG]  [BUGGY]    if(work[i]  ==  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[i]  <=  Tolerance_3)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -work;  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    if(work[i]  ==  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[i]  <=  Tolerance_3)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -work;  }  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	    if(work[i]  ==  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[i]  <=  Tolerance_3)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -work;  }		non-compiled	[CE]  illegal  start  of  expression	12	None
62	[BUG]  [BUGGY]    if(work[i]  ==  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -work;  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    if(work[i]  ==  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -work;  }  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	    if(work[i]  ==  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -work;  }		non-compiled	[CE]  illegal  start  of  expression	12	None
63	[BUG]  [BUGGY]    if(work[i]  ==  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[i]  <=  tolerance_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -work;  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    if(work[i]  ==  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[i]  <=  tolerance_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -work;  }  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	    if(work[i]  ==  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[i]  <=  tolerance_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -work;  }		non-compiled	[CE]  illegal  start  of  expression	12	None
64	[BUG]  [BUGGY]    if(work[i]  ==  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[i]  <=  tolerANCE_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -work;  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    if(work[i]  ==  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[i]  <=  tolerANCE_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -work;  }  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	    if(work[i]  ==  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[i]  <=  tolerANCE_2)  {  if(work[j  +  1]  ==  0.0)  {  work[j]  =  -work;  }		non-compiled	[CE]  illegal  start  of  expression	12	None
65	[BUG]  [BUGGY]    if(work[i]  ==  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[i]  <=  Tolerance_3)  {  if(work[j  +  1]  ==  d)  {  work[j]  =  -work;  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]    if(work[i]  ==  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[i]  <=  Tolerance_3)  {  if(work[j  +  1]  ==  d)  {  work[j]  =  -work;  }  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	    if(work[i]  ==  TOLERANCE_1  &&  work[i]  <=  TOLERANCE_2  &&  work[i]  <=  Tolerance_3)  {  if(work[j  +  1]  ==  d)  {  work[j]  =  -work;  }		non-compiled	[CE]  illegal  start  of  expression	12	None
92	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i]  =  -2.0;  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	add	work[i]  =  -2.0;	work[i]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	9	1
93	[BUG]  [BUGGY]  work[i]  =  -2.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i]  =  -2.0;  [BUGGY]  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	work[i]  =  -2.0;	work[i]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	9	1
122	[BUG]  [BUGGY]  work[j]  =  -work;  [CE]  bad  operand  type  double[]  for  unary  operator  '-'  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]  work[j]  =  -work;  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	work[j]  =  -work;	work[j]  =  d;  	non-compiled	[CE]  bad  operand  type  double[]  for  unary  operator  '-'	11	None
123	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]  work[j]  -=  d;  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	add	work[j]  -=  d;	work[j]  =  d;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	11	1
124	[BUG]  [BUGGY]  work[j]  -=  d;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  [BUGGY]  work[j]  -=  d;  [BUGGY]  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	work[j]  -=  d;	work[j]  =  d;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	11	1
151	[BUG]  [BUGGY]    if(work[i  -  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  -  1]  ==  ToLERANCE_2  *  d)  {  work[i  +  1]  =  -1.0;  }  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]    if(work[i  -  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  -  1]  ==  ToLERANCE_2  *  d)  {  work[i  +  1]  =  -1.0;  }  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	    if(work[i  -  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  -  1]  ==  ToLERANCE_2  *  d)  {  work[i  +  1]  =  -1.0;  }		non-compiled	[CE]  illegal  start  of  expression	8	None
153	[BUG]  [BUGGY]    if(work[i  -  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  -  1]  ==  ToLERANCE_2  *  d)  {  work[i  -=  0;  }  [CE]  ']'  expected  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]    if(work[i  -  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  -  1]  ==  ToLERANCE_2  *  d)  {  work[i  -=  0;  }  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	    if(work[i  -  1]  ==  TOLERANCE_1  *  d)  {  if(work[i  -  1]  ==  ToLERANCE_2  *  d)  {  work[i  -=  0;  }		non-compiled	[CE]  ']'  expected	8	None
154	[BUG]  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  for(int  i  =  0;  i  <  work.length;  ++i)  {  work[i]  =  -1.0;  }  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  for(int  i  =  0;  i  <  work.length;  ++i)  {  work[i]  =  -1.0;  }  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  for(int  i  =  0;  i  <  work.length;  ++i)  {  work[i]  =  -1.0;  }		non-compiled	[CE]  illegal  start  of  expression	8	None
155	[BUG]  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  for(int  i  =  0;  i  <  work.length;  ++i)  {  work[i]  =  -work;  }  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  for(int  i  =  0;  i  <  work.length;  ++i)  {  work[i]  =  -work;  }  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	    if(work[i  +  1]  ==  TOLERANCE_1  *  d)  {  for(int  i  =  0;  i  <  work.length;  ++i)  {  work[i]  =  -work;  }		non-compiled	[CE]  illegal  start  of  expression	8	None
181	[BUG]  [BUGGY]    dMin3  =  Math.max(dMin2,  work[l  -  1]);  [CE]  cannot  find  symbol  dMin3  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMin3  =  Math.max(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	    dMin3  =  Math.max(dMin2,  work[l  -  1]);		non-compiled	[CE]  cannot  find  symbol  dMin3	20	None
182	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMin1  =  Math.max(dMin1,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	add	    dMin1  =  Math.max(dMin1,  work[l  -  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	20	1
183	[BUG]  [BUGGY]    dMin1  =  Math.max(dMin1,  work[l  -  1]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMin1  =  Math.max(dMin1,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	    dMin1  =  Math.max(dMin1,  work[l  -  1]);		compilable	  [FE]  AssertionFailedError  testMathpbx02	20	1
184	[BUG]  [BUGGY]    dMin3  =  Math.max(dMin3,  work[l  -  1]);  [CE]  cannot  find  symbol  dMin3  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMin3  =  Math.max(dMin3,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	    dMin3  =  Math.max(dMin3,  work[l  -  1]);		non-compiled	[CE]  cannot  find  symbol  dMin3	20	None
185	[BUG]  [BUGGY]    dMax  =  Math.max(dMax,  work[l  -  1]);  [CE]  cannot  find  symbol  dMax  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]    dMax  =  Math.max(dMax,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =      Math.min(work[l  -  1],                Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	    dMax  =  Math.max(dMax,  work[l  -  1]);		non-compiled	[CE]  cannot  find  symbol  dMax	20	None
212	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  3]  =  -2.0;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	work[i  +  3]  =  -2.0;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
213	[BUG]  [BUGGY]  work[i  +  3]  =  -2.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  3]  =  -2.0;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	work[i  +  3]  =  -2.0;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
213	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  3]  =  -0.0;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	work[i  +  3]  =  -0.0;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
214	[BUG]  [BUGGY]  work[i  +  3]  =  -0.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  3]  =  -0.0;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	work[i  +  3]  =  -0.0;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
214	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  3]  =  -1.0;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	work[i  +  3]  =  -1.0;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
215	[BUG]  [BUGGY]  work[i  +  3]  =  -1.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]  work[i  +  3]  =  -1.0;  [BUGGY]  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	work[i  +  3]  =  -1.0;	work[i  +  2]  =  -0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	5	1
241	[BUG]  [BUGGY]    work[j]  -=  Math.max(work[i  +  1]  -  TOLERANCE_2);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    work[j]  -=  Math.max(work[i  +  1]  -  TOLERANCE_2);  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	    work[j]  -=  Math.max(work[i  +  1]  -  TOLERANCE_2);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	16	None
242	[BUG]  [BUGGY]    work[j]  -=  Math.max(work[i]  /  TOLERANCE_1]);  [CE]  ')'  expected  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    work[j]  -=  Math.max(work[i]  /  TOLERANCE_1]);  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	    work[j]  -=  Math.max(work[i]  /  TOLERANCE_1]);		non-compiled	[CE]  ')'  expected	16	None
243	[BUG]  [BUGGY]    work[j]  -=  Math.max(work[i]  /  TOLERANCE_3);  [CE]  cannot  find  symbol  TOLERANCE_3  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    work[j]  -=  Math.max(work[i]  /  TOLERANCE_3);  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	    work[j]  -=  Math.max(work[i]  /  TOLERANCE_3);		non-compiled	[CE]  cannot  find  symbol  TOLERANCE_3	16	None
244	[BUG]  [BUGGY]    work[j]  -=  Math.max(work[i]  /  TOLERANCE_2);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    work[j]  -=  Math.max(work[i]  /  TOLERANCE_2);  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	    work[j]  -=  Math.max(work[i]  /  TOLERANCE_2);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	16	None
245	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    work[i]  -=  work[i  +  1];  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	add	    work[i]  -=  work[i  +  1];		compilable	  [FE]  AssertionFailedError  testMathpbx02	16	1
246	[BUG]  [BUGGY]    work[i]  -=  work[i  +  1];  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]    work[i]  -=  work[i  +  1];  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	    work[i]  -=  work[i  +  1];		compilable	  [FE]  AssertionFailedError  testMathpbx02	16	1
271	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  -  TOLERANCE_2);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =  Math.max(work[i]  -  TOLERANCE_2);  [BUGGY]  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	    work[i]  =  Math.max(work[i]  -  TOLERANCE_2);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	10	None
273	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  -  tolerANCE_2);  [CE]  cannot  find  symbol  tolerANCE_2  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =  Math.max(work[i]  -  tolerANCE_2);  [BUGGY]  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	    work[i]  =  Math.max(work[i]  -  tolerANCE_2);		non-compiled	[CE]  cannot  find  symbol  tolerANCE_2	10	None
274	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  -  work[i]);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =  Math.max(work[i]  -  work[i]);  [BUGGY]  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	    work[i]  =  Math.max(work[i]  -  work[i]);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	10	None
275	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  -  TOLERANCE_1]);  [CE]  ')'  expected  [CONTEXT]  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =  Math.max(work[i]  -  TOLERANCE_1]);  [BUGGY]  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	    work[i]  =  Math.max(work[i]  -  TOLERANCE_1]);		non-compiled	[CE]  ')'  expected	10	None
301	[BUG]  [BUGGY]    work[i]  =  solve(work[i]);  [CE]  cannot  find  symbol  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =  solve(work[i]);  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	    work[i]  =  solve(work[i]);		non-compiled	[CE]  cannot  find  symbol	6	None
302	[BUG]  [BUGGY]    work[i]  =(work[i  +  1]  ==  TOLERANCE_1  *  d)?  work[i  +  1]  :  work[i].doubleValue();  [CE]  cannot  find  symbol  TOLERANCE_1  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =(work[i  +  1]  ==  TOLERANCE_1  *  d)?  work[i  +  1]  :  work[i].doubleValue();  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	    work[i]  =(work[i  +  1]  ==  TOLERANCE_1  *  d)?  work[i  +  1]  :  work[i].doubleValue();		non-compiled	[CE]  cannot  find  symbol  TOLERANCE_1	6	None
303	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =(work[i  +  1]  ==  TOLERANCE_2  *  d)?  work[i  -  1]  :  work[i  -  1];  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	    work[i]  =(work[i  +  1]  ==  TOLERANCE_2  *  d)?  work[i  -  1]  :  work[i  -  1];		compilable	  [FE]  ArrayIndexOutOfBoundsException  testMathpbx02	6	1
304	[BUG]  [BUGGY]    work[i]  =(work[i  +  1]  ==  TOLERANCE_2  *  d)?  work[i  -  1]  :  work[i  -  1];  [FE]  ArrayIndexOutOfBoundsException  testMathpbx02  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =(work[i  +  1]  ==  TOLERANCE_2  *  d)?  work[i  -  1]  :  work[i  -  1];  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	    work[i]  =(work[i  +  1]  ==  TOLERANCE_2  *  d)?  work[i  -  1]  :  work[i  -  1];		compilable	  [FE]  ArrayIndexOutOfBoundsException  testMathpbx02	6	1
304	[BUG]  [BUGGY]    work[i]  =(work[i  +  1]  ==  TOLERANCE_1  *  d)?  work[i  +  1]  :  work[i];  [CE]  cannot  find  symbol  TOLERANCE_1  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =(work[i  +  1]  ==  TOLERANCE_1  *  d)?  work[i  +  1]  :  work[i];  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	    work[i]  =(work[i  +  1]  ==  TOLERANCE_1  *  d)?  work[i  +  1]  :  work[i];		non-compiled	[CE]  cannot  find  symbol  TOLERANCE_1	6	None
305	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  /  TOLERANCE_2);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  [BUGGY]    work[i]  =  Math.max(work[i]  /  TOLERANCE_2);  [BUGGY]  work[i  +  2]  =  -0.0;  d  =  work[i];  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	    work[i]  =  Math.max(work[i]  /  TOLERANCE_2);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	6	None
334	[BUG]  [BUGGY]  i0  =  1  +  work[i  +  4];  [CE]  possible  loss  of  precision  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]  i0  =  1  +  work[i  +  4];  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  +  work[i  +  4];	i0  =  1  +  i  /  4;  	non-compiled	[CE]  possible  loss  of  precision	1	None
361	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));  [BUGGY]  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	add	work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));	work[l  -  1]  =    Math.min(work[l  -  1],        Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  	compilable	  [FE]  AssertionFailedError  testMathpbx02	19	1
362	[BUG]  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));  [BUGGY]  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[4  +  pingPong]));	work[l  -  1]  =    Math.min(work[l  -  1],        Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  	compilable	  [FE]  AssertionFailedError  testMathpbx02	19	1
362	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[2  +  pingPong],  work[3  +  pingPong]));  [BUGGY]  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	add	work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[2  +  pingPong],  work[3  +  pingPong]));	work[l  -  1]  =    Math.min(work[l  -  1],        Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  	compilable	  [FE]  AssertionFailedError  testMathpbx02	19	1
363	[BUG]  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[2  +  pingPong],  work[3  +  pingPong]));  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[2  +  pingPong],  work[3  +  pingPong]));  [BUGGY]  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[2  +  pingPong],  work[3  +  pingPong]));	work[l  -  1]  =    Math.min(work[l  -  1],        Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  	compilable	  [FE]  AssertionFailedError  testMathpbx02	19	1
364	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  *  pingPong],  work[4  *  pingPong]));  [BUGGY]  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	add	work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  *  pingPong],  work[4  *  pingPong]));	work[l  -  1]  =    Math.min(work[l  -  1],        Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  	compilable	  [FE]  AssertionFailedError  testMathpbx02	19	1
365	[BUG]  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  *  pingPong],  work[4  *  pingPong]));  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  dMin2  =  Math.min(dMin2,  work[l  -  1]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  *  pingPong],  work[4  *  pingPong]));  [BUGGY]  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  *  pingPong],  work[4  *  pingPong]));	work[l  -  1]  =    Math.min(work[l  -  1],        Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  	compilable	  [FE]  AssertionFailedError  testMathpbx02	19	1
391	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i  +  1]);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    work[i]  =  Math.max(work[i  +  1]);  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	    work[i]  =  Math.max(work[i  +  1]);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	2	None
392	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i  +  3]);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    work[i]  =  Math.max(work[i  +  3]);  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	    work[i]  =  Math.max(work[i  +  3]);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	2	None
393	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i  +  1]  -  diagMin);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    work[i]  =  Math.max(work[i  +  1]  -  diagMin);  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	    work[i]  =  Math.max(work[i  +  1]  -  diagMin);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	2	None
394	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    work[i]  =(work[i  +  1]  ==  0)?  work[i  +  1]  :  null;  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	    work[i]  =(work[i  +  1]  ==  0)?  work[i  +  1]  :  null;		compilable	  [FE]  AssertionFailedError  testMathpbx02	2	1
395	[BUG]  [BUGGY]    work[i]  =(work[i  +  1]  ==  0)?  work[i  +  1]  :  null;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    work[i]  =(work[i  +  1]  ==  0)?  work[i  +  1]  :  null;  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	    work[i]  =(work[i  +  1]  ==  0)?  work[i  +  1]  :  null;		compilable	  [FE]  AssertionFailedError  testMathpbx02	2	1
395	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i  +  1]  -  0);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  [BUGGY]    work[i]  =  Math.max(work[i  +  1]  -  0);  [BUGGY]  i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	    work[i]  =  Math.max(work[i  +  1]  -  0);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	2	None
421	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]  d  =  work[j  +  3];  [BUGGY]  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	add	d  =  work[j  +  3];	d  =  work[i  +  2];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	15	1
422	[BUG]  [BUGGY]  d  =  work[j  +  3];  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]  d  =  work[j  +  3];  [BUGGY]  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	d  =  work[j  +  3];	d  =  work[i  +  2];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	15	1
423	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]  d  =  work[j  +  1];  [BUGGY]  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	add	d  =  work[j  +  1];	d  =  work[i  +  2];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	15	1
424	[BUG]  [BUGGY]  d  =  work[j  +  1];  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]    d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  work[j  +  2]  =  0.0;  [BUGGY]  d  =  work[j  +  1];  [BUGGY]  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	d  =  work[j  +  1];	d  =  work[i  +  2];  	compilable	  [FE]  AssertionFailedError  testMathpbx02	15	1
452	[BUG]  [BUGGY]  dMin2  =  Math.min(dMin,  work[l  -  1,  1]);  [CE]  ']'  expected  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]  dMin2  =  Math.min(dMin,  work[l  -  1,  1]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	dMin2  =  Math.min(dMin,  work[l  -  1,  1]);	dMin2  =  Math.min(dMin2,  work[l  -  1]);  	non-compiled	[CE]  ']'  expected	17	None
453	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]  dMin2  =  Math.min(dMin,  work[0]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	add	dMin2  =  Math.min(dMin,  work[0]);	dMin2  =  Math.min(dMin2,  work[l  -  1]);  	compilable	  [FE]  AssertionFailedError  testMathpbx02	17	1
454	[BUG]  [BUGGY]  dMin2  =  Math.min(dMin,  work[0]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]  dMin2  =  Math.min(dMin,  work[0]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	dMin2  =  Math.min(dMin,  work[0]);	dMin2  =  Math.min(dMin2,  work[l  -  1]);  	compilable	  [FE]  AssertionFailedError  testMathpbx02	17	1
454	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]  dMin2  =  Math.min(dMin,  work[1]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	add	dMin2  =  Math.min(dMin,  work[1]);	dMin2  =  Math.min(dMin2,  work[l  -  1]);  	compilable	  [FE]  AssertionFailedError  testMathpbx02	17	1
455	[BUG]  [BUGGY]  dMin2  =  Math.min(dMin,  work[1]);  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  }  final  int  l  =  4  *  deflatedEnd  +  pingPong  -  1;  if  ((dMin  <=  0)  ||  (deflatedEnd  <  end))  {  if  (flipIfWarranted(deflatedEnd,  1))  {  [BUGGY]  dMin2  =  Math.min(dMin,  work[1]);  [BUGGY]  work[l  -  1]  =  Math.min(work[l  -  1],  Math.min(work[3  +  pingPong],  work[7  +  pingPong]));  work[l  -  2  *  pingPong]  =  Math.min(work[l  -  2  *  pingPong],  Math.min(work[6  +  pingPong],  work[6  +  pingPong]));  qMax=  Math.max(qMax,  Math.max(work[3  +  pingPong],  work[7  +  pingPong]));  dMin=  -0.0;  }  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  goodStep  [RETURN_TYPE]  int  final  int  start  final  int  end  [VARIABLES]  boolean  deflating  loop  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  deflatedEnd  end  fourI  i  i0  index  j  k  l  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  start  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	dMin2  =  Math.min(dMin,  work[1]);	dMin2  =  Math.min(dMin2,  work[l  -  1]);  	compilable	  [FE]  AssertionFailedError  testMathpbx02	17	1
481	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  -  i0);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]    work[i]  =  Math.max(work[i]  -  i0);  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	    work[i]  =  Math.max(work[i]  -  i0);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	4	None
482	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  -  i1);  i0  =  Math.min(i0  -  work[i]  -  1);  [CE]  cannot  find  symbol  i1  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]    work[i]  =  Math.max(work[i]  -  i1);  i0  =  Math.min(i0  -  work[i]  -  1);  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	    work[i]  =  Math.max(work[i]  -  i1);  i0  =  Math.min(i0  -  work[i]  -  1);		non-compiled	[CE]  cannot  find  symbol  i1	4	None
483	[BUG]  [BUGGY]    i0  =  Math.max(i0,  work[i]);  [CE]  possible  loss  of  precision  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]    i0  =  Math.max(i0,  work[i]);  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	    i0  =  Math.max(i0,  work[i]);		non-compiled	[CE]  possible  loss  of  precision	4	None
484	[BUG]  [BUGGY]    work[i]  =  Math.max(work[i]  -  i1);  i0  =  Math.min(i0  -  work[i]);  [CE]  cannot  find  symbol  i1  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]    work[i]  =  Math.max(work[i]  -  i1);  i0  =  Math.min(i0  -  work[i]);  [BUGGY]  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	    work[i]  =  Math.max(work[i]  -  i1);  i0  =  Math.min(i0  -  work[i]);		non-compiled	[CE]  cannot  find  symbol  i1	4	None
513	[BUG]  [BUGGY]  i0  =  Math.max(i0,  work[i  +  3]);  [CE]  possible  loss  of  precision  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]  i0  =  Math.max(i0,  work[i  +  3]);  [BUGGY]  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	i0  =  Math.max(i0,  work[i  +  3]);	break;  	non-compiled	[CE]  possible  loss  of  precision	3	None
514	[BUG]  [BUGGY]  i0  =  Math.min(i0,  work[i]);  [CE]  possible  loss  of  precision  [CONTEXT]    double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {  i0  =  1  +  i  /  4;  [BUGGY]  i0  =  Math.min(i0,  work[i]);  [BUGGY]  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	i0  =  Math.min(i0,  work[i]);	break;  	non-compiled	[CE]  possible  loss  of  precision	3	None
543	[BUG]  [BUGGY]  d  =  work[i]  /  TOLERANCE_1;  [CE]  cannot  find  symbol  TOLERANCE_1  [CONTEXT]  private  void  initialSplits(final  int  n)  {  pingPong  =  0;  for  (int  k  =  0;  k  <  2;  ++k)  {  double  d  =  work[4  *  (n  -  1)  +  pingPong];  for  (int  i  =  4  *  (n  -  2)  +  pingPong;  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  TOLERANCE_2  *  d)  {  work[i  +  2]  =  -0.0;  [BUGGY]  d  =  work[i]  /  TOLERANCE_1;  [BUGGY]  }  else  {  d  *=  work[i]  /  (d  +  work[i  +  2]);  }  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	d  =  work[i]  /  TOLERANCE_1;	d  =  work[i];  	non-compiled	[CE]  cannot  find  symbol  TOLERANCE_1	7	None
574	[BUG]  [BUGGY]  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]  work[i  +  3]  =  0.0;  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	add	work[i  +  3]  =  0.0;	work[j  +  2]  =  0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	13	1
575	[BUG]  [BUGGY]  work[i  +  3]  =  0.0;  [FE]  AssertionFailedError  testMathpbx02  [CONTEXT]  }  d  =  work[pingPong];  for  (int  i  =  2  +  pingPong;  i  <  4  *  n  -  2;  i  +=  4)  {  final  int  j  =  i  -  2  *  pingPong  -  1;  work[j]  =  d  +  work[i];  if  (work[i]  <=  TOLERANCE_2  *  d)  {  work[i]  =  -0.0;  work[j]  =  d;  [BUGGY]  work[i  +  3]  =  0.0;  [BUGGY]  d  =  work[i  +  2];  }  else  if  ((MathUtils.SAFE_MIN  *  work[i  +  2]  <  work[j])  &&  (MathUtils.SAFE_MIN  *  work[j]  <  work[i  +  2]))  {  final  double  tmp  =  work[i  +  2]  /  work[j];  work[j  +  2]  =  work[i]  *  tmp;  d  *=  tmp;  }  else  {  work[j  +  2]  =  work[i  +  2]  *  (work[i]  /  work[j]);  d  *=  work[i  +  2]  /  work[j];  }  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  initialSplits  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	work[i  +  3]  =  0.0;	work[j  +  2]  =  0.0;  	compilable	  [FE]  AssertionFailedError  testMathpbx02	13	1
