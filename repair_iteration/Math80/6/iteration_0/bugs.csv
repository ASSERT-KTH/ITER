bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
11	[BUG] [BUGGY] work[j] = d; [FE] AssertionFailedError [CONTEXT] } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { work[i] = -0.0; [BUGGY] work[j] = d; [BUGGY] work[j + 2] = 0.0; d = work[i + 2]; } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); d *= work[i + 2] / work[j]; [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	
12	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { work[i] = -0.0; [BUGGY] [BUGGY] work[j] = d; work[j + 2] = 0.0; d = work[i + 2]; } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); d *= work[i + 2] / work[j]; [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	add	
