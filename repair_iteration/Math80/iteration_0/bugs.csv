bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] i0 = 1 + i / 4; [FE] AssertionFailedError testMathpbx02 [CONTEXT] sigmaLow = 0;  double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6]; double offDiagMax = 0; double diagMax= work[4 * n0 - 4]; double diagMin= diagMax; i0 = 0; for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { if (work[i + 2] <= 0) { [BUGGY] i0 = 1 + i / 4; [BUGGY] break; } if (diagMin >= 4 * offDiagMax) { diagMin= Math.min(diagMin, work[i + 4]); offDiagMax = Math.max(offDiagMax, work[i + 2]); } diagMax= Math.max(diagMax, work[i] + work[i + 2]); offDiagMin = Math.min(offDiagMin, work[i + 2]); } work[4 * n0 - 2] = offDiagMin; [CLASS] EigenDecompositionImpl Solver [METHOD] processGeneralBlock [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	
2	[BUG] [BUGGY] [FE] AssertionFailedError testMathpbx02 [CONTEXT] sigmaLow = 0;  double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6]; double offDiagMax = 0; double diagMax= work[4 * n0 - 4]; double diagMin= diagMax; i0 = 0; for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { if (work[i + 2] <= 0) { [BUGGY] [BUGGY] i0 = 1 + i / 4; break; } if (diagMin >= 4 * offDiagMax) { diagMin= Math.min(diagMin, work[i + 4]); offDiagMax = Math.max(offDiagMax, work[i + 2]); } diagMax= Math.max(diagMax, work[i] + work[i + 2]); offDiagMin = Math.min(offDiagMin, work[i + 2]); } work[4 * n0 - 2] = offDiagMin; [CLASS] EigenDecompositionImpl Solver [METHOD] processGeneralBlock [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	
3	[BUG] [BUGGY] break; [FE] AssertionFailedError testMathpbx02 [CONTEXT]  double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6]; double offDiagMax = 0; double diagMax= work[4 * n0 - 4]; double diagMin= diagMax; i0 = 0; for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { if (work[i + 2] <= 0) { i0 = 1 + i / 4; [BUGGY] break; [BUGGY] } if (diagMin >= 4 * offDiagMax) { diagMin= Math.min(diagMin, work[i + 4]); offDiagMax = Math.max(offDiagMax, work[i + 2]); } diagMax= Math.max(diagMax, work[i] + work[i + 2]); offDiagMin = Math.min(offDiagMin, work[i + 2]); } work[4 * n0 - 2] = offDiagMin;  [CLASS] EigenDecompositionImpl Solver [METHOD] processGeneralBlock [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	
4	[BUG] [BUGGY] [FE] AssertionFailedError testMathpbx02 [CONTEXT]  double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6]; double offDiagMax = 0; double diagMax= work[4 * n0 - 4]; double diagMin= diagMax; i0 = 0; for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { if (work[i + 2] <= 0) { i0 = 1 + i / 4; [BUGGY] [BUGGY] break; } if (diagMin >= 4 * offDiagMax) { diagMin= Math.min(diagMin, work[i + 4]); offDiagMax = Math.max(offDiagMax, work[i + 2]); } diagMax= Math.max(diagMax, work[i] + work[i + 2]); offDiagMin = Math.min(offDiagMin, work[i + 2]); } work[4 * n0 - 2] = offDiagMin;  [CLASS] EigenDecompositionImpl Solver [METHOD] processGeneralBlock [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	add	
5	[BUG] [BUGGY] work[i + 2] = -0.0; [FE] AssertionFailedError testMathpbx02 [CONTEXT] private void initialSplits(final int n) { pingPong = 0; for (int k = 0; k < 2; ++k) {  double d = work[4 * (n - 1) + pingPong]; for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) { if (work[i + 2] <= TOLERANCE_2 * d) { [BUGGY] work[i + 2] = -0.0; [BUGGY] d = work[i]; } else { d *= work[i] / (d + work[i + 2]); } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	
6	[BUG] [BUGGY] [FE] AssertionFailedError testMathpbx02 [CONTEXT] private void initialSplits(final int n) { pingPong = 0; for (int k = 0; k < 2; ++k) {  double d = work[4 * (n - 1) + pingPong]; for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) { if (work[i + 2] <= TOLERANCE_2 * d) { [BUGGY] [BUGGY] work[i + 2] = -0.0; d = work[i]; } else { d *= work[i] / (d + work[i + 2]); } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	
7	[BUG] [BUGGY] d = work[i]; [FE] AssertionFailedError testMathpbx02 [CONTEXT] private void initialSplits(final int n) { pingPong = 0; for (int k = 0; k < 2; ++k) {  double d = work[4 * (n - 1) + pingPong]; for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) { if (work[i + 2] <= TOLERANCE_2 * d) { work[i + 2] = -0.0; [BUGGY] d = work[i]; [BUGGY] } else { d *= work[i] / (d + work[i + 2]); } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	
8	[BUG] [BUGGY] [FE] AssertionFailedError testMathpbx02 [CONTEXT] private void initialSplits(final int n) { pingPong = 0; for (int k = 0; k < 2; ++k) {  double d = work[4 * (n - 1) + pingPong]; for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) { if (work[i + 2] <= TOLERANCE_2 * d) { work[i + 2] = -0.0; [BUGGY] [BUGGY] d = work[i]; } else { d *= work[i] / (d + work[i + 2]); } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	add	
9	[BUG] [BUGGY] work[i] = -0.0; [FE] AssertionFailedError testMathpbx02 [CONTEXT] d *= work[i] / (d + work[i + 2]); } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { [BUGGY] work[i] = -0.0; [BUGGY] work[j] = d; work[j + 2] = 0.0; d = work[i + 2]; } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	
10	[BUG] [BUGGY] [FE] AssertionFailedError testMathpbx02 [CONTEXT] d *= work[i] / (d + work[i + 2]); } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { [BUGGY] [BUGGY] work[i] = -0.0; work[j] = d; work[j + 2] = 0.0; d = work[i + 2]; } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	add	
11	[BUG] [BUGGY] work[j] = d; [FE] AssertionFailedError testMathpbx02 [CONTEXT] } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { work[i] = -0.0; [BUGGY] work[j] = d; [BUGGY] work[j + 2] = 0.0; d = work[i + 2]; } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); d *= work[i + 2] / work[j]; [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	
12	[BUG] [BUGGY] [FE] AssertionFailedError testMathpbx02 [CONTEXT] } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { work[i] = -0.0; [BUGGY] [BUGGY] work[j] = d; work[j + 2] = 0.0; d = work[i + 2]; } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); d *= work[i + 2] / work[j]; [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	add	
13	[BUG] [BUGGY] work[j + 2] = 0.0; [FE] AssertionFailedError testMathpbx02 [CONTEXT] }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { work[i] = -0.0; work[j] = d; [BUGGY] work[j + 2] = 0.0; [BUGGY] d = work[i + 2]; } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); d *= work[i + 2] / work[j]; } [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	
14	[BUG] [BUGGY] [FE] AssertionFailedError testMathpbx02 [CONTEXT] }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { work[i] = -0.0; work[j] = d; [BUGGY] [BUGGY] work[j + 2] = 0.0; d = work[i + 2]; } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); d *= work[i + 2] / work[j]; } [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	add	
15	[BUG] [BUGGY] d = work[i + 2]; [FE] AssertionFailedError testMathpbx02 [CONTEXT]  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { work[i] = -0.0; work[j] = d; work[j + 2] = 0.0; [BUGGY] d = work[i + 2]; [BUGGY] } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); d *= work[i + 2] / work[j]; } } [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	
16	[BUG] [BUGGY] [FE] AssertionFailedError testMathpbx02 [CONTEXT]  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { work[i] = -0.0; work[j] = d; work[j + 2] = 0.0; [BUGGY] [BUGGY] d = work[i + 2]; } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); d *= work[i + 2] / work[j]; } } [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	add	
17	[BUG] [BUGGY] dMin2 = Math.min(dMin2, work[l - 1]); [FE] AssertionFailedError testMathpbx02 [CONTEXT] } } final int l = 4 * deflatedEnd + pingPong - 1;  if ((dMin <= 0) || (deflatedEnd < end)) { if (flipIfWarranted(deflatedEnd, 1)) { [BUGGY] dMin2 = Math.min(dMin2, work[l - 1]); [BUGGY] work[l - 1] = Math.min(work[l - 1], Math.min(work[3 + pingPong], work[7 + pingPong])); work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); qMax= Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); dMin= -0.0; } } [CLASS] EigenDecompositionImpl Solver [METHOD] goodStep [RETURN_TYPE] int  final int start final int end [VARIABLES] boolean deflating loop double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	
18	[BUG] [BUGGY] [FE] AssertionFailedError testMathpbx02 [CONTEXT] } } final int l = 4 * deflatedEnd + pingPong - 1;  if ((dMin <= 0) || (deflatedEnd < end)) { if (flipIfWarranted(deflatedEnd, 1)) { [BUGGY] [BUGGY] dMin2 = Math.min(dMin2, work[l - 1]); work[l - 1] = Math.min(work[l - 1], Math.min(work[3 + pingPong], work[7 + pingPong])); work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); qMax= Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); dMin= -0.0; } } [CLASS] EigenDecompositionImpl Solver [METHOD] goodStep [RETURN_TYPE] int  final int start final int end [VARIABLES] boolean deflating loop double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	add	
19	[BUG] [BUGGY] work[l - 1] =  Math.min(work[l - 1],    Math.min(work[3 + pingPong], work[7 + pingPong])); [FE] AssertionFailedError testMathpbx02 [CONTEXT] } } final int l = 4 * deflatedEnd + pingPong - 1;  if ((dMin <= 0) || (deflatedEnd < end)) { if (flipIfWarranted(deflatedEnd, 1)) { dMin2 = Math.min(dMin2, work[l - 1]); [BUGGY] work[l - 1] =     Math.min(work[l - 1],               Math.min(work[3 + pingPong], work[7 + pingPong])); [BUGGY] Math.min(work[l - 1], Math.min(work[3 + pingPong], work[7 + pingPong])); work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); qMax= Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); dMin= -0.0; } }  [CLASS] EigenDecompositionImpl Solver [METHOD] goodStep [RETURN_TYPE] int  final int start final int end [VARIABLES] boolean deflating loop double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	
20	[BUG] [BUGGY] [FE] AssertionFailedError testMathpbx02 [CONTEXT] } } final int l = 4 * deflatedEnd + pingPong - 1;  if ((dMin <= 0) || (deflatedEnd < end)) { if (flipIfWarranted(deflatedEnd, 1)) { dMin2 = Math.min(dMin2, work[l - 1]); [BUGGY] [BUGGY] work[l - 1] =     Math.min(work[l - 1],               Math.min(work[3 + pingPong], work[7 + pingPong])); Math.min(work[l - 1], Math.min(work[3 + pingPong], work[7 + pingPong])); work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); qMax= Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); dMin= -0.0; } }  [CLASS] EigenDecompositionImpl Solver [METHOD] goodStep [RETURN_TYPE] int  final int start final int end [VARIABLES] boolean deflating loop double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	add	
